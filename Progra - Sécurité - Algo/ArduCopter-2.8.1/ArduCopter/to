// -*- tab-width: 4; Mode: C++; c-basic-offset: 4; indent-tabs-mode: nil -*-

// Example config file. Take a look at config.h. Any term define there can be overridden by defining it here.

//#define CONFIG_APM_HARDWARE APM_HARDWARE_APM2

// Ordinary users should please ignore the following define.
// APM2_BETA_HARDWARE is used to support early (September-October 2011) APM2
// hardware which had the BMP085 barometer onboard. Only a handful of
// developers have these boards.
//#define APM2_BETA_HARDWARE

// GPS is auto-selected

//#define MAG_ORIENTATION		AP_COMPASS_COMPONENTS_DOWN_PINS_FORWARD
//#define HIL_MODE				HIL_MODE_ATTITUDE
//#define DMP_ENABLED ENABLED
//#define SECONDARY_DMP_ENABLED ENABLED       // allows running DMP in parallel with DCM for testing purposes

//#define FRAME_CONFIG QUAD_FRAME
/*
 *  options:
 *  QUAD_FRAME
 *  TRI_FRAME
 *  HEXA_FRAME
 *  Y6_FRAME
 *  OCTA_FRAME
 *  OCTA_QUAD_FRAME
 *  HELI_FRAME
 */

//#define FRAME_ORIENTATION X_FRAME
/*
 *  PLUS_FRAME
 *  X_FRAME
 *  V_FRAME
 */

//#define CH7_OPTION		CH7_SAVE_WP
/*
 *  CH7_DO_NOTHING
 *  CH7_SET_HOVER
 *  CH7_FLIP
 *  CH7_SIMPLE_MODE
 *  CH7_RTL
 *  CH7_AUTO_TRIM
 *  CH7_ADC_FILTER (experimental)
 *  CH7_SAVE_WP
 *  CH7_MULTI_MODE
 */

//#define TOY_EDF	ENABLED
//#define TOY_MIXER TOY_LOOKUP_TABLE

// Inertia based contollers.  disabled by default, work in progress
//#define ACCEL_ALT_HOLD 0
//#define INERTIAL_NAV ENABLED


#if INERTIAL_NAV == ENABLED
 #define ALT_HOLD_P                      3
 #define ALT_HOLD_I                      0
 #define ALT_HOLD_IMAX           300

// RATE control
 #define THROTTLE_P                      5                      //
 #define THROTTLE_I                      0.4                    //
 #define THROTTLE_D                      0.0                    //

 #define LOITER_P                        0.50
 #define LOITER_I                        0.0
 #define LOITER_RATE_P           5                      //
 #define LOITER_RATE_I           0.1                    // Wind control
 #define LOITER_RATE_D           0.0                    // try 2 or 3 for LOITER_RATE 1
#endif


//#define RATE_ROLL_I   0.18
//#define RATE_PITCH_I	0.18
//#define MOTORS_JD880
//#define MOTORS_JD850


// agmatthews USERHOOKS
// the choice of function names is up to the user and does not have to match these
// uncomment these hooks and ensure there is a matching function on your "UserCode.pde" file
//#define USERHOOK_FASTLOOP userhook_FastLoop();
#define USERHOOK_50HZLOOP userhook_50Hz();
//#define USERHOOK_MEDIUMLOOP userhook_MediumLoop();
//#define USERHOOK_SLOWLOOP userhook_SlowLoop();
//#define USERHOOK_SUPERSLOWLOOP userhook_SuperSlowLoop();
#define USERHOOK_INIT userhook_init();

// the choice of included variables file (*.h) is up to the user and does not have to match this one
// Ensure the defined file exists and is in the arducopter directory
#define USERHOOK_VARIABLES "UserVariables.h"

// to enable, set to 1
// to disable, set to 0
// #define AUTO_THROTTLE_HOLD 1

//#define LOGGING_ENABLED		DISABLED


// Custom channel config - Expert Use Only.
// this for defining your own MOT_n to CH_n mapping.
// Overrides defaults (for APM1 or APM2) found in config_channels.h
// MOT_n variables are used by the Frame mixing code. You must define
// MOT_1 through MOT_m where m is the number of motors on your frame.
// CH_n variables are used for RC output. These can be CH_1 through CH_8,
// and CH_10 or CH_12.
// Sample channel config. Must define all MOT_ channels used by
// your FRAME_TYPE.
// #define CONFIG_CHANNELS CHANNEL_CONFIG_CUSTOM
// #define MOT_1 CH_6
// #define MOT_2 CH_3
// #define MOT_3 CH_2
// #define MOT_4 CH_5
// #define MOT_5 CH_1
// #define MOT_6 CH_4
// #define MOT_7 CH_7
// #define MOT_8 CH_8
// -*- tab-width: 4; Mode: C++; c-basic-offset: 4; indent-tabs-mode: nil -*-

// HIL_MODE SELECTION
//
// Mavlink supports
// 1. HIL_MODE_ATTITUDE : simulated position, airspeed, and attitude
// 2. HIL_MODE_SENSORS: full sensor simulation
#define HIL_MODE            HIL_MODE_ATTITUDE

// HIL_PORT SELCTION
//
// PORT 1
// If you would like to run telemetry communications for a groundstation
// while you are running hardware in the loop it is necessary to set
// HIL_PORT to 1. This uses the port that would have been used for the gps
// as the hardware in the loop port. You will have to solder
// headers onto the gps port connection on the apm
// and connect via an ftdi cable.
//
// The baud rate is set to 115200 in this mode.
//
// PORT 3
// If you don't require telemetry communication with a gcs while running
// hardware in the loop you may use the telemetry port as the hardware in
// the loop port.  Alternatively, use a telemetry/HIL shim like FGShim
// https://ardupilot-mega.googlecode.com/svn/Tools/trunk/FlightGear
//
// The buad rate is controlled by SERIAL3_BAUD in this mode.

#define HIL_PORT            3

// You can set your gps protocol here for your actual
// hardware and leave it without affecting the hardware
// in the loop simulation
#define GPS_PROTOCOL            GPS_PROTOCOL_MTK

// Sensors
// All sensors are supported in all modes.
// The magnetometer is not used in
// HIL_MODE_ATTITUDE but you may leave it
// enabled if you wish.
#define MAGNETOMETER        ENABLED
/// -*- tab-width: 4; Mode: C++; c-basic-offset: 4; indent-tabs-mode: nil -*-

#define THISFIRMWARE "ArduCopter V2.8.1"
/*
 *  ArduCopter Version 2.8
 *  Lead author:	Jason Short
 *  Based on code and ideas from the Arducopter team: Randy Mackay, Pat Hickey, Jose Julio, Jani Hirvinen, Andrew Tridgell, Justin Beech, Adam Rivera, Jean-Louis Naudin, Roberto Navoni
 *  Thanks to:	Chris Anderson, Mike Smith, Jordi Munoz, Doug Weibel, James Goppert, Benjamin Pelletier, Robert Lefebvre, Marco Robustini
 *
 *  This firmware is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 2.1 of the License, or (at your option) any later version.
 *
 *  Special Thanks for Contributors:
 *
 *  Hein Hollander      :Octo Support
 *  Dani Saez           :V Ocoto Support
 *  Max Levine			:Tri Support, Graphics
 *  Jose Julio			:Stabilization Control laws
 *  Randy MacKay		:Heli Support
 *  Jani Hiriven		:Testing feedback
 *  Andrew Tridgell		:Mavlink Support
 *  James Goppert		:Mavlink Support
 *  Doug Weibel			:Libraries
 *  Mike Smith			:Libraries, Coding support
 *  HappyKillmore		:Mavlink GCS
 *  Michael Oborne		:Mavlink GCS
 *  Jack Dunkle			:Alpha testing
 *  Christof Schmid		:Alpha testing
 *  Oliver				:Piezo support
 *  Guntars				:Arming safety suggestion
 *  Igor van Airde      :Control Law optimization
 *  Jean-Louis Naudin   :Auto Landing
 *  Sandro Benigno      :Camera support
 *  Olivier Adler       :PPM Encoder
 *  John Arne Birkeland	:PPM Encoder
 *  Adam M Rivera		:Auto Compass Declination
 *  Marco Robustini		:Alpha testing
 *  Angel Fernandez		:Alpha testing
 *  Robert Lefebvre		:Heli Support & LEDs
 *  Amilcar Lucas		:mount and camera configuration
 *  Gregory Fletcher	:mount orientation math
 *
 *  And much more so PLEASE PM me on DIYDRONES to add your contribution to the List
 *
 *  Requires modified "mrelax" version of Arduino, which can be found here:
 *  http://code.google.com/p/ardupilot-mega/downloads/list
 *
 */

////////////////////////////////////////////////////////////////////////////////
// Header includes
////////////////////////////////////////////////////////////////////////////////

// AVR runtime
#include <avr/io.h>
#include <avr/eeprom.h>
#include <avr/pgmspace.h>
#include <math.h>

// Libraries
#include <FastSerial.h>
#include <AP_Common.h>
#include <AP_Menu.h>
#include <Arduino_Mega_ISR_Registry.h>
#include <APM_RC.h>         // ArduPilot Mega RC Library
#include <AP_GPS.h>         // ArduPilot GPS library
#include <I2C.h>                        // Arduino I2C lib
#include <SPI.h>                        // Arduino SPI lib
#include <SPI3.h>               // SPI3 library
#include <AP_Semaphore.h>   // for removing conflict between optical flow and dataflash on SPI3 bus
#include <DataFlash.h>      // ArduPilot Mega Flash Memory Library
#include <AP_ADC.h>         // ArduPilot Mega Analog to Digital Converter Library
#include <AP_AnalogSource.h>
#include <AP_Baro.h>
#include <AP_Compass.h>     // ArduPilot Mega Magnetometer Library
#include <AP_Math.h>        // ArduPilot Mega Vector/Matrix math Library
#include <AP_Curve.h>       // Curve used to linearlise throttle pwm to thrust
#include <AP_InertialSensor.h> // ArduPilot Mega Inertial Sensor (accel & gyro) Library
#include <AP_IMU.h>         // ArduPilot Mega IMU Library
#include <AP_PeriodicProcess.h>         // Parent header of Timer
                                        // (only included for makefile libpath to work)
#include <AP_TimerProcess.h>            // TimerProcess is the scheduler for MPU6000 reads.
#include <AP_AHRS.h>
#include <APM_PI.h>             // PI library
#include <AC_PID.h>            // PID library
#include <RC_Channel.h>     // RC Channel Library
#include <AP_Motors.h>          // AP Motors library
#include <AP_MotorsQuad.h>      // AP Motors library for Quad
#include <AP_MotorsTri.h>       // AP Motors library for Tri
#include <AP_MotorsHexa.h>      // AP Motors library for Hexa
#include <AP_MotorsY6.h>        // AP Motors library for Y6
#include <AP_MotorsOcta.h>      // AP Motors library for Octa
#include <AP_MotorsOctaQuad.h>  // AP Motors library for OctaQuad
#include <AP_MotorsHeli.h>      // AP Motors library for Heli
#include <AP_MotorsMatrix.h>    // AP Motors library for Heli
#include <AP_RangeFinder.h>     // Range finder library
#include <AP_OpticalFlow.h> // Optical Flow library
#include <Filter.h>                     // Filter library
#include <ModeFilter.h>         // Mode Filter from Filter library
#include <AverageFilter.h>      // Mode Filter from Filter library
#include <AP_LeadFilter.h>      // GPS Lead filter
#include <AP_Relay.h>           // APM relay
#include <AP_Camera.h>          // Photo or video camera
#include <AP_Mount.h>           // Camera/Antenna mount
#include <AP_Airspeed.h>    // needed for AHRS build
#include <memcheck.h>

// Configuration
#include "defines.h"
#include "config.h"
#include "config_channels.h"

#include <GCS_MAVLink.h>    // MAVLink GCS definitions

// Local modules
#include "Parameters.h"
#include "GCS.h"

#include <AP_Declination.h> // ArduPilot Mega Declination Helper Library

// Limits library - Puts limits on the vehicle, and takes recovery actions
#include <AP_Limits.h>
#include <AP_Limit_GPSLock.h> // a limits library module
#include <AP_Limit_Geofence.h> // a limits library module
#include <AP_Limit_Altitude.h> // a limits library module


////////////////////////////////////////////////////////////////////////////////
// Serial ports
////////////////////////////////////////////////////////////////////////////////
//
// Note that FastSerial port buffers are allocated at ::begin time,
// so there is not much of a penalty to defining ports that we don't
// use.
//
FastSerialPort0(Serial);        // FTDI/console
FastSerialPort1(Serial1);       // GPS port
FastSerialPort3(Serial3);       // Telemetry port

// this sets up the parameter table, and sets the default values. This
// must be the first AP_Param variable declared to ensure its
// constructor runs before the constructors of the other AP_Param
// variables
AP_Param param_loader(var_info, WP_START_BYTE);

Arduino_Mega_ISR_Registry isr_registry;

////////////////////////////////////////////////////////////////////////////////
// Parameters
////////////////////////////////////////////////////////////////////////////////
//
// Global parameters are all contained within the 'g' class.
//
static Parameters g;


////////////////////////////////////////////////////////////////////////////////
// prototypes
static void update_events(void);

////////////////////////////////////////////////////////////////////////////////
// RC Hardware
////////////////////////////////////////////////////////////////////////////////
#if CONFIG_APM_HARDWARE == APM_HARDWARE_APM2
APM_RC_APM2 APM_RC;
#else
APM_RC_APM1 APM_RC;
#endif

////////////////////////////////////////////////////////////////////////////////
// Dataflash
////////////////////////////////////////////////////////////////////////////////
AP_Semaphore spi_semaphore;
AP_Semaphore spi3_semaphore;
#if CONFIG_APM_HARDWARE == APM_HARDWARE_APM2
DataFlash_APM2 DataFlash(&spi3_semaphore);
#else
DataFlash_APM1 DataFlash(&spi_semaphore);
#endif


////////////////////////////////////////////////////////////////////////////////
// Sensors
////////////////////////////////////////////////////////////////////////////////
//
// There are three basic options related to flight sensor selection.
//
// - Normal flight mode.  Real sensors are used.
// - HIL Attitude mode.  Most sensors are disabled, as the HIL
//   protocol supplies attitude information directly.
// - HIL Sensors mode.  Synthetic sensors are configured that
//   supply data from the simulation.
//

// All GPS access should be through this pointer.
static GPS         *g_gps;

// flight modes convenience array
static AP_Int8                *flight_modes = &g.flight_mode1;

#if HIL_MODE == HIL_MODE_DISABLED

// real sensors
 #if CONFIG_ADC == ENABLED
AP_ADC_ADS7844 adc;
 #endif

 #ifdef DESKTOP_BUILD
AP_Baro_BMP085_HIL barometer;
AP_Compass_HIL compass;
  #include <SITL.h>
SITL sitl;
 #else

  #if CONFIG_BARO == AP_BARO_BMP085
   # if CONFIG_APM_HARDWARE == APM_HARDWARE_APM2
AP_Baro_BMP085 barometer(true);
   # else
AP_Baro_BMP085 barometer(false);
   # endif
  #elif CONFIG_BARO == AP_BARO_MS5611
AP_Baro_MS5611 barometer;
  #endif

AP_Compass_HMC5843 compass;
 #endif

 #ifdef OPTFLOW_ENABLED
  #if CONFIG_APM_HARDWARE == APM_HARDWARE_APM2
AP_OpticalFlow_ADNS3080 optflow(OPTFLOW_CS_PIN);
  #else
AP_OpticalFlow_ADNS3080 optflow(OPTFLOW_CS_PIN);
  #endif
 #else
AP_OpticalFlow optflow;
 #endif

// real GPS selection
 #if   GPS_PROTOCOL == GPS_PROTOCOL_AUTO
AP_GPS_Auto     g_gps_driver(&Serial1, &g_gps);

 #elif GPS_PROTOCOL == GPS_PROTOCOL_NMEA
AP_GPS_NMEA     g_gps_driver(&Serial1);

 #elif GPS_PROTOCOL == GPS_PROTOCOL_SIRF
AP_GPS_SIRF     g_gps_driver(&Serial1);

 #elif GPS_PROTOCOL == GPS_PROTOCOL_UBLOX
AP_GPS_UBLOX    g_gps_driver(&Serial1);

 #elif GPS_PROTOCOL == GPS_PROTOCOL_MTK
AP_GPS_MTK      g_gps_driver(&Serial1);

 #elif GPS_PROTOCOL == GPS_PROTOCOL_MTK16
AP_GPS_MTK16    g_gps_driver(&Serial1);

 #elif GPS_PROTOCOL == GPS_PROTOCOL_NONE
AP_GPS_None     g_gps_driver(NULL);

 #else
  #error Unrecognised GPS_PROTOCOL setting.
 #endif // GPS PROTOCOL

 #if CONFIG_IMU_TYPE == CONFIG_IMU_MPU6000
AP_InertialSensor_MPU6000 ins;
 #else
AP_InertialSensor_Oilpan ins(&adc);
 #endif
AP_IMU_INS  imu(&ins);

// we don't want to use gps for yaw correction on ArduCopter, so pass
// a NULL GPS object pointer
static GPS         *g_gps_null;

 #if DMP_ENABLED == ENABLED && CONFIG_APM_HARDWARE == APM_HARDWARE_APM2
AP_AHRS_MPU6000  ahrs(&imu, g_gps, &ins);               // only works with APM2
 #else
AP_AHRS_DCM ahrs(&imu, g_gps);
 #endif

// ahrs2 object is the secondary ahrs to allow running DMP in parallel with DCM
  #if SECONDARY_DMP_ENABLED == ENABLED && CONFIG_APM_HARDWARE == APM_HARDWARE_APM2
AP_AHRS_MPU6000  ahrs2(&imu, g_gps, &ins);               // only works with APM2
  #endif

#elif HIL_MODE == HIL_MODE_SENSORS
// sensor emulators
AP_ADC_HIL adc;
AP_Baro_BMP085_HIL barometer;
AP_Compass_HIL compass;
AP_GPS_HIL              g_gps_driver(NULL);
AP_IMU_Shim imu;
AP_AHRS_DCM                         ahrs(&imu, g_gps);
AP_InertialSensor_Stub ins;

static int32_t gps_base_alt;

#elif HIL_MODE == HIL_MODE_ATTITUDE
AP_ADC_HIL adc;
AP_IMU_Shim imu;
AP_AHRS_HIL             ahrs(&imu, g_gps);
AP_GPS_HIL              g_gps_driver(NULL);
AP_Compass_HIL compass;                  // never used
AP_Baro_BMP085_HIL barometer;
AP_InertialSensor_Stub ins;
#ifdef OPTFLOW_ENABLED
#if CONFIG_APM_HARDWARE == APM_HARDWARE_APM2
AP_OpticalFlow_ADNS3080 optflow(&spi3_semaphore,OPTFLOW_CS_PIN);
#else
AP_OpticalFlow_ADNS3080 optflow(NULL,OPTFLOW_CS_PIN);
#endif
#endif
 #ifdef DESKTOP_BUILD
  #include <SITL.h>
SITL sitl;
 #endif
static int32_t gps_base_alt;
#else
 #error Unrecognised HIL_MODE setting.
#endif // HIL MODE

// we always have a timer scheduler
AP_TimerProcess timer_scheduler;

////////////////////////////////////////////////////////////////////////////////
// GCS selection
////////////////////////////////////////////////////////////////////////////////
GCS_MAVLINK gcs0;
GCS_MAVLINK gcs3;

////////////////////////////////////////////////////////////////////////////////
// SONAR selection
////////////////////////////////////////////////////////////////////////////////
//
ModeFilterInt16_Size5 sonar_mode_filter(2);
#if CONFIG_SONAR == ENABLED
 #if CONFIG_SONAR_SOURCE == SONAR_SOURCE_ADC
AP_AnalogSource_ADC sonar_analog_source( &adc, CONFIG_SONAR_SOURCE_ADC_CHANNEL, 0.25);
 #elif CONFIG_SONAR_SOURCE == SONAR_SOURCE_ANALOG_PIN
AP_AnalogSource_Arduino sonar_analog_source(CONFIG_SONAR_SOURCE_ANALOG_PIN);
 #endif
AP_RangeFinder_MaxsonarXL sonar(&sonar_analog_source, &sonar_mode_filter);
#endif

// agmatthews USERHOOKS
////////////////////////////////////////////////////////////////////////////////
// User variables
////////////////////////////////////////////////////////////////////////////////
#ifdef USERHOOK_VARIABLES
 #include USERHOOK_VARIABLES
#endif

////////////////////////////////////////////////////////////////////////////////
// Global variables
////////////////////////////////////////////////////////////////////////////////

/* Radio values
 *               Channel assignments
 *                       1	Ailerons (rudder if no ailerons)
 *                       2	Elevator
 *                       3	Throttle
 *                       4	Rudder (if we have ailerons)
 *                       5	Mode - 3 position switch
 *                       6  User assignable
 *                       7	trainer switch - sets throttle nominal (toggle switch), sets accels to Level (hold > 1 second)
 *                       8	TBD
 *               Each Aux channel can be configured to have any of the available auxiliary functions assigned to it.
 *               See libraries/RC_Channel/RC_Channel_aux.h for more information
 */

//Documentation of GLobals:

////////////////////////////////////////////////////////////////////////////////
// The GPS based velocity calculated by offsetting the Latitude and Longitude
// updated after GPS read - 5-10hz
static int16_t x_actual_speed;
static int16_t y_actual_speed;


// The difference between the desired rate of travel and the actual rate of travel
// updated after GPS read - 5-10hz
static int16_t x_rate_error;
static int16_t y_rate_error;

////////////////////////////////////////////////////////////////////////////////
// Radio
////////////////////////////////////////////////////////////////////////////////
// This is the state of the flight control system
// There are multiple states defined such as STABILIZE, ACRO,
static int8_t control_mode            = STABILIZE;
// This is the state of simple mode.
// Set in the control_mode.pde file when the control switch is read
static bool do_simple                       = false;
// Used to maintain the state of the previous control switch position
// This is set to -1 when we need to re-read the switch
static byte oldSwitchPosition;


////////////////////////////////////////////////////////////////////////////////
// Motor Output
////////////////////////////////////////////////////////////////////////////////
// This is the array of PWM values being sent to the motors
//static int16_t  motor_out[11];
// This is the array of PWM values being sent to the motors that has been lightly filtered with a simple LPF
// This was added to try and deal with biger motors
//static int16_t  motor_filtered[11];

#if FRAME_CONFIG ==     QUAD_FRAME
 #define MOTOR_CLASS AP_MotorsQuad
#endif
#if FRAME_CONFIG ==     TRI_FRAME
 #define MOTOR_CLASS AP_MotorsTri
#endif
#if FRAME_CONFIG ==     HEXA_FRAME
 #define MOTOR_CLASS AP_MotorsHexa
#endif
#if FRAME_CONFIG ==     Y6_FRAME
 #define MOTOR_CLASS AP_MotorsY6
#endif
#if FRAME_CONFIG ==     OCTA_FRAME
 #define MOTOR_CLASS AP_MotorsOcta
#endif
#if FRAME_CONFIG ==     OCTA_QUAD_FRAME
 #define MOTOR_CLASS AP_MotorsOctaQuad
#endif
#if FRAME_CONFIG ==     HELI_FRAME
 #define MOTOR_CLASS AP_MotorsHeli
#endif

#if FRAME_CONFIG ==     HELI_FRAME  // helicopter constructor requires more arguments
MOTOR_CLASS     motors(CONFIG_APM_HARDWARE, &APM_RC, &g.rc_1, &g.rc_2, &g.rc_3, &g.rc_4, &g.rc_8, &g.heli_servo_1, &g.heli_servo_2, &g.heli_servo_3, &g.heli_servo_4);
#elif FRAME_CONFIG == TRI_FRAME  // tri constructor requires additional rc_7 argument to allow tail servo reversing
MOTOR_CLASS     motors(CONFIG_APM_HARDWARE, &APM_RC, &g.rc_1, &g.rc_2, &g.rc_3, &g.rc_4, &g.rc_7);
#else
MOTOR_CLASS     motors(CONFIG_APM_HARDWARE, &APM_RC, &g.rc_1, &g.rc_2, &g.rc_3, &g.rc_4);
#endif

////////////////////////////////////////////////////////////////////////////////
// Mavlink/HIL control
////////////////////////////////////////////////////////////////////////////////
// Used to track the GCS based control input
// Allow override of RC channel values for HIL
static int16_t rc_override[8] = {0,0,0,0,0,0,0,0};
// Status flag that tracks whether we are under GCS control
static bool rc_override_active = false;
// Status flag that tracks whether we are under GCS control
static uint32_t rc_override_fs_timer;

////////////////////////////////////////////////////////////////////////////////
// Failsafe
////////////////////////////////////////////////////////////////////////////////
// A status flag for the failsafe state
// did our throttle dip below the failsafe value?
static boolean failsafe;

////////////////////////////////////////////////////////////////////////////////
// PIDs
////////////////////////////////////////////////////////////////////////////////
// This is a convienience accessor for the IMU roll rates. It's currently the raw IMU rates
// and not the adjusted omega rates, but the name is stuck
static Vector3f omega;
// This is used to hold radio tuning values for in-flight CH6 tuning
float tuning_value;
// This will keep track of the percent of roll or pitch the user is applying
float roll_scale_d, pitch_scale_d;

////////////////////////////////////////////////////////////////////////////////
// LED output
////////////////////////////////////////////////////////////////////////////////
// status of LED based on the motor_armed variable
// Flashing indicates we are not armed
// Solid indicates Armed state
static boolean motor_light;
// Flashing indicates we are reading the GPS Strings
// Solid indicates we have full 3D lock and can navigate
static boolean GPS_light;
// This is current status for the LED lights state machine
// setting this value changes the output of the LEDs
static byte led_mode = NORMAL_LEDS;
// Blinking indicates GPS status
static byte copter_leds_GPS_blink = 0;
// Blinking indicates battery status
static byte copter_leds_motor_blink = 0;
// Navigation confirmation blinks
static int8_t copter_leds_nav_blink = 0;

////////////////////////////////////////////////////////////////////////////////
// GPS variables
////////////////////////////////////////////////////////////////////////////////
// This is used to scale GPS values for EEPROM storage
// 10^7 times Decimal GPS means 1 == 1cm
// This approximation makes calculations integer and it's easy to read
static const float t7                        = 10000000.0;
// We use atan2 and other trig techniques to calaculate angles
// We need to scale the longitude up to make these calcs work
// to account for decreasing distance between lines of longitude away from the equator
static float scaleLongUp                     = 1;
// Sometimes we need to remove the scaling for distance calcs
static float scaleLongDown           = 1;


////////////////////////////////////////////////////////////////////////////////
// Mavlink specific
////////////////////////////////////////////////////////////////////////////////
// Used by Mavlink for unknow reasons
static const float radius_of_earth      = 6378100;              // meters
// Used by Mavlink for unknow reasons
static const float gravity                      = 9.81;                 // meters/ sec^2

// Unions for getting byte values
union float_int {
    int32_t int_value;
    float float_value;
} float_int;


////////////////////////////////////////////////////////////////////////////////
// Location & Navigation
////////////////////////////////////////////////////////////////////////////////
// Status flag indicating we have data that can be used to navigate
// Set by a GPS read with 3D fix, or an optical flow read
static bool nav_ok;
// This is the angle from the copter to the "next_WP" location in degrees * 100
static int32_t target_bearing;
// Status of the Waypoint tracking mode. Options include:
// NO_NAV_MODE, WP_MODE, LOITER_MODE, CIRCLE_MODE
static byte wp_control;
// Register containing the index of the current navigation command in the mission script
static int16_t command_nav_index;
// Register containing the index of the previous navigation command in the mission script
// Used to manage the execution of conditional commands
static uint8_t prev_nav_index;
// Register containing the index of the current conditional command in the mission script
static uint8_t command_cond_index;
// Used to track the required WP navigation information
// options include
// NAV_ALTITUDE - have we reached the desired altitude?
// NAV_LOCATION - have we reached the desired location?
// NAV_DELAY    - have we waited at the waypoint the desired time?
static uint8_t wp_verify_byte;                                                  // used for tracking state of navigating waypoints
// used to limit the speed ramp up of WP navigation
// Acceleration is limited to .5m/s/s
static int16_t waypoint_speed_gov;
// Used to track how many cm we are from the "next_WP" location
static int32_t long_error, lat_error;
// Are we navigating while holding a positon? This is set to false once the speed drops below 1m/s
static boolean loiter_override;
static int16_t waypoint_radius;

static int16_t control_roll;
static int16_t control_pitch;

////////////////////////////////////////////////////////////////////////////////
// Orientation
////////////////////////////////////////////////////////////////////////////////
// Convienience accessors for commonly used trig functions. These values are generated
// by the DCM through a few simple equations. They are used throughout the code where cos and sin
// would normally be used.
// The cos values are defaulted to 1 to get a decent initial value for a level state
static float cos_roll_x         = 1;
static float cos_pitch_x        = 1;
static float cos_yaw_x          = 1;
static float sin_yaw_y;
static float sin_roll;
static float sin_pitch;

////////////////////////////////////////////////////////////////////////////////
// SIMPLE Mode
////////////////////////////////////////////////////////////////////////////////
// Used to track the orientation of the copter for Simple mode. This value is reset at each arming
// or in SuperSimple mode when the copter leaves a 20m radius from home.
static int32_t initial_simple_bearing;

////////////////////////////////////////////////////////////////////////////////
// Rate contoller targets
////////////////////////////////////////////////////////////////////////////////
static uint8_t rate_targets_frame = EARTH_FRAME;    // indicates whether rate targets provided in earth or body frame
static int32_t roll_rate_target_ef = 0;
static int32_t pitch_rate_target_ef = 0;
static int32_t yaw_rate_target_ef = 0;
static int32_t roll_rate_target_bf = 0;     // body frame roll rate target
static int32_t pitch_rate_target_bf = 0;    // body frame pitch rate target
static int32_t yaw_rate_target_bf = 0;      // body frame yaw rate target

////////////////////////////////////////////////////////////////////////////////
// ACRO Mode
////////////////////////////////////////////////////////////////////////////////
// Used to control Axis lock
int32_t roll_axis;
int32_t pitch_axis;

// Filters
AP_LeadFilter xLeadFilter;      // Long GPS lag filter
AP_LeadFilter yLeadFilter;      // Lat  GPS lag filter

AverageFilterInt32_Size3 roll_rate_d_filter;    // filtered acceleration
AverageFilterInt32_Size3 pitch_rate_d_filter;   // filtered pitch acceleration

// Barometer filter
AverageFilterInt32_Size5 baro_filter;   // filtered pitch acceleration

////////////////////////////////////////////////////////////////////////////////
// Circle Mode / Loiter control
////////////////////////////////////////////////////////////////////////////////
// used to determin the desired location in Circle mode
// increments at circle_rate / second
static float circle_angle;
// used to control the speed of Circle mode
// units are in radians, default is 5° per second
static const float circle_rate = 0.0872664625;
// used to track the delat in Circle Mode
static int32_t old_target_bearing;
// deg : how many times to circle * 360 for Loiter/Circle Mission command
static int16_t loiter_total;
// deg : how far we have turned around a waypoint
static int16_t loiter_sum;
// How long we should stay in Loiter Mode for mission scripting
static uint16_t loiter_time_max;
// How long have we been loitering - The start time in millis
static uint32_t loiter_time;
// The synthetic location created to make the copter do circles around a WP
static struct   Location circle_WP;


////////////////////////////////////////////////////////////////////////////////
// CH7 control
////////////////////////////////////////////////////////////////////////////////
// Used to enable Jose's flip code
// when true the Roll/Pitch/Throttle control is sent to the flip state machine
static bool do_flip = false;
// Used to track the CH7 toggle state.
// When CH7 goes LOW PWM from HIGH PWM, this value will have been set true
// Allows advanced functionality to know when to execute
static boolean CH7_flag;
// This register tracks the current Mission Command index when writing
// a mission using CH7 in flight
static int8_t CH7_wp_index;


////////////////////////////////////////////////////////////////////////////////
// Battery Sensors
////////////////////////////////////////////////////////////////////////////////
// Battery Voltage of battery, initialized above threshold for filter
static float battery_voltage1                = LOW_VOLTAGE * 1.05;
// refers to the instant amp draw – based on an Attopilot Current sensor
static float current_amps1;
// refers to the total amps drawn – based on an Attopilot Current sensor
static float current_total1;
// Used to track if the battery is low - LED output flashes when the batt is low
static bool low_batt = false;


////////////////////////////////////////////////////////////////////////////////
// Altitude
////////////////////////////////////////////////////////////////////////////////
// The cm we are off in altitude from next_WP.alt – Positive value means we are below the WP
static int32_t altitude_error;
// The cm/s we are moving up or down based on sensor data - Positive = UP
static int16_t climb_rate_actual;
// Used to dither our climb_rate over 50hz
static int16_t climb_rate_error;
// The cm/s we are moving up or down based on filtered data - Positive = UP
static int16_t climb_rate;
// The altitude as reported by Sonar in cm – Values are 20 to 700 generally.
static int16_t sonar_alt;
// The climb_rate as reported by sonar in cm/s
static int16_t sonar_rate;
// The altitude as reported by Baro in cm – Values can be quite high
static int32_t baro_alt;
// The climb_rate as reported by Baro in cm/s
static int16_t baro_rate;
// used to switch out of Manual Boost
static uint8_t reset_throttle_counter;
// used to track when to read sensors vs estimate alt
static boolean alt_sensor_flag;
static int16_t saved_toy_throttle;


////////////////////////////////////////////////////////////////////////////////
// flight modes
////////////////////////////////////////////////////////////////////////////////
// Flight modes are combinations of Roll/Pitch, Yaw and Throttle control modes
// Each Flight mode is a unique combination of these modes
//
// The current desired control scheme for Yaw
static byte yaw_mode;
// The current desired control scheme for roll and pitch / navigation
static byte roll_pitch_mode;
// The current desired control scheme for altitude hold
static byte throttle_mode;


////////////////////////////////////////////////////////////////////////////////
// flight specific
////////////////////////////////////////////////////////////////////////////////
// Flag for monitoring the status of flight
// We must be in the air with throttle for 5 seconds before this flag is true
// This flag is reset when we are in a manual throttle mode with 0 throttle or disarmed
static boolean takeoff_complete;
// Used to see if we have landed and if we should shut our engines - not fully implemented
static boolean land_complete = true;
// An additional throttle added to keep the copter at the same altitude when banking
static int16_t angle_boost;
// Push copter down for clean landing
static int16_t landing_boost;
// for controlling the landing throttle curve
//verifies landings
static int16_t ground_detector;
// have we reached our desired altitude brefore heading home?
static bool rtl_reached_alt;


////////////////////////////////////////////////////////////////////////////////
// Navigation general
////////////////////////////////////////////////////////////////////////////////
// The location of the copter in relation to home, updated every GPS read
static int32_t home_to_copter_bearing;
// distance between plane and home in cm
static int32_t home_distance;
// distance between plane and next_WP in cm
// is not static because AP_Camera uses it
int32_t wp_distance;

////////////////////////////////////////////////////////////////////////////////
// 3D Location vectors
////////////////////////////////////////////////////////////////////////////////
// home location is stored when we have a good GPS lock and arm the copter
// Can be reset each the copter is re-armed
static struct   Location home;
// Flag for if we have g_gps lock and have set the home location
static boolean home_is_set;
// Current location of the copter
static struct   Location current_loc;
// lead filtered loc
static struct   Location filtered_loc;
// Next WP is the desired location of the copter - the next waypoint or loiter location
static struct   Location next_WP;
// Prev WP is used to get the optimum path from one WP to the next
static struct   Location prev_WP;
// Holds the current loaded command from the EEPROM for navigation
static struct   Location command_nav_queue;
// Holds the current loaded command from the EEPROM for conditional scripts
static struct   Location command_cond_queue;
// Holds the current loaded command from the EEPROM for guided mode
static struct   Location guided_WP;


////////////////////////////////////////////////////////////////////////////////
// Crosstrack
////////////////////////////////////////////////////////////////////////////////
// deg * 100, The original angle to the next_WP when the next_WP was set
// Also used to check when we pass a WP
static int32_t original_target_bearing;
// The amount of angle correction applied to target_bearing to bring the copter back on its optimum path
static int16_t crosstrack_error;
// should we take the waypoint quickly or slow down?
static bool fast_corner;


////////////////////////////////////////////////////////////////////////////////
// Navigation Roll/Pitch functions
////////////////////////////////////////////////////////////////////////////////
// all angles are deg * 100 : target yaw angle
// The Commanded ROll from the autopilot.
static int32_t nav_roll;
// The Commanded pitch from the autopilot. negative Pitch means go forward.
static int32_t nav_pitch;
// The desired bank towards North (Positive) or South (Negative)
static int32_t auto_roll;
static int32_t auto_pitch;

// Don't be fooled by the fact that Pitch is reversed from Roll in its sign!
static int16_t nav_lat;
// The desired bank towards East (Positive) or West (Negative)
static int16_t nav_lon;
// The Commanded ROll from the autopilot based on optical flow sensor.
static int32_t of_roll;
// The Commanded pitch from the autopilot based on optical flow sensor. negative Pitch means go forward.
static int32_t of_pitch;
static bool slow_wp = false;


////////////////////////////////////////////////////////////////////////////////
// Navigation Throttle control
////////////////////////////////////////////////////////////////////////////////
// The Commanded Throttle from the autopilot.
static int16_t nav_throttle;                                            // 0-1000 for throttle control
// This is a simple counter to track the amount of throttle used during flight
// This could be useful later in determining and debuging current usage and predicting battery life
static uint32_t throttle_integrator;

////////////////////////////////////////////////////////////////////////////////
// Climb rate control
////////////////////////////////////////////////////////////////////////////////
// Time when we intiated command in millis - used for controlling decent rate
// Used to track the altitude offset for climbrate control
static int8_t alt_change_flag;

////////////////////////////////////////////////////////////////////////////////
// Navigation Yaw control
////////////////////////////////////////////////////////////////////////////////
// The Commanded Yaw from the autopilot.
static int32_t nav_yaw;
// A speed governer for Yaw control - limits the rate the quad can be turned by the autopilot
static int32_t auto_yaw;
// Used to manage the Yaw hold capabilities -
static bool yaw_stopped;
static uint8_t yaw_timer;
// Options include: no tracking, point at next wp, or at a target
static byte yaw_tracking = MAV_ROI_WPNEXT;
// In AP Mission scripting we have a fine level of control for Yaw
// This is our initial angle for relative Yaw movements
static int32_t command_yaw_start;
// Timer values used to control the speed of Yaw movements
static uint32_t command_yaw_start_time;
static uint16_t command_yaw_time;                                       // how long we are turning
static int32_t command_yaw_end;                                         // what angle are we trying to be
// how many degrees will we turn
static int32_t command_yaw_delta;
// Deg/s we should turn
static int16_t command_yaw_speed;
// Direction we will turn –  1 = CW, 0 or -1 = CCW
static byte command_yaw_dir;
// Direction we will turn – 1 = relative, 0 = Absolute
static byte command_yaw_relative;
// Yaw will point at this location if yaw_tracking is set to MAV_ROI_LOCATION
static struct   Location target_WP;



////////////////////////////////////////////////////////////////////////////////
// Repeat Mission Scripting Command
////////////////////////////////////////////////////////////////////////////////
// The type of repeating event - Toggle a servo channel, Toggle the APM1 relay, etc
static byte event_id;
// Used to manage the timimng of repeating events
static uint32_t event_timer;
// How long to delay the next firing of event in millis
static uint16_t event_delay;
// how many times to fire : 0 = forever, 1 = do once, 2 = do twice
static int16_t event_repeat;
// per command value, such as PWM for servos
static int16_t event_value;
// the stored value used to undo commands - such as original PWM command
static int16_t event_undo_value;

////////////////////////////////////////////////////////////////////////////////
// Delay Mission Scripting Command
////////////////////////////////////////////////////////////////////////////////
static int32_t condition_value;  // used in condition commands (eg delay, change alt, etc.)
static uint32_t condition_start;


////////////////////////////////////////////////////////////////////////////////
// IMU variables
////////////////////////////////////////////////////////////////////////////////
// Integration time for the gyros (DCM algorithm)
// Updated with the fast loop
static float G_Dt               = 0.02;

////////////////////////////////////////////////////////////////////////////////
// Inertial Navigation
////////////////////////////////////////////////////////////////////////////////
#if INERTIAL_NAV == ENABLED
// The rotated accelerometer values
static Vector3f accels_velocity;
static Vector3f accels_position;

// accels rotated to world frame
static Vector3f accels_rotated;
//static Vector3f position_error;

// error correction
static Vector3f speed_error;

// Manage accel drift
//static float z_offset;
//static Vector3f accels_scale;

#endif

////////////////////////////////////////////////////////////////////////////////
// Performance monitoring
////////////////////////////////////////////////////////////////////////////////
// Used to manage the rate of performance logging messages
static int16_t perf_mon_counter;
// The number of GPS fixes we have had
static int16_t gps_fix_count;
// gps_watchdog checks for bad reads and if we miss 12 in a row, we stop navigating
// by lowering nav_lat and navlon to 0 gradually
static byte gps_watchdog;

// System Timers
// --------------
// Time in microseconds of main control loop
static uint32_t fast_loopTimer;
// Time in microseconds of 50hz control loop
static uint32_t fiftyhz_loopTimer = 0;
// Counters for branching from 10 hz control loop
static byte medium_loopCounter;
// Counters for branching from 3 1/3hz control loop
static byte slow_loopCounter;
// Counters for branching at 1 hz
static byte counter_one_herz;
// Counter of main loop executions.  Used for performance monitoring and failsafe processing
static uint16_t mainLoop_count;
// used to track the elapsed time between GPS reads
static uint32_t nav_loopTimer;
// Delta Time in milliseconds for navigation computations, updated with every good GPS read
static float dTnav;
// Counters for branching from 4 minute control loop used to save Compass offsets
static int16_t superslow_loopCounter;
// Loiter timer - Records how long we have been in loiter
static uint32_t loiter_timer;
// disarms the copter while in Acro or Stabilize mode after 30 seconds of no flight
static uint8_t auto_disarming_counter;
// prevents duplicate GPS messages from entering system
static uint32_t last_gps_time;

// Set true if we have new PWM data to act on from the Radio
static bool new_radio_frame;
// Used to auto exit the in-flight leveler
static int16_t auto_level_counter;

// Reference to the AP relay object - APM1 only
AP_Relay relay;

// APM2 only
#if USB_MUX_PIN > 0
static bool usb_connected;
#endif

#if CLI_ENABLED == ENABLED
    static int8_t   setup_show (uint8_t argc, const Menu::arg *argv);
#endif

// Camera/Antenna mount tracking and stabilisation stuff
// --------------------------------------
#if MOUNT == ENABLED
// current_loc uses the baro/gps soloution for altitude rather than gps only.
// mabe one could use current_loc for lat/lon too and eliminate g_gps alltogether?
AP_Mount camera_mount(&current_loc, g_gps, &ahrs, 0);
#endif

#if MOUNT2 == ENABLED
// current_loc uses the baro/gps soloution for altitude rather than gps only.
// mabe one could use current_loc for lat/lon too and eliminate g_gps alltogether?
AP_Mount camera_mount2(&current_loc, g_gps, &ahrs, 1);
#endif

#if CAMERA == ENABLED
//pinMode(camtrig, OUTPUT);			// these are free pins PE3(5), PH3(15), PH6(18), PB4(23), PB5(24), PL1(36), PL3(38), PA6(72), PA7(71), PK0(89), PK1(88), PK2(87), PK3(86), PK4(83), PK5(84), PK6(83), PK7(82)
#endif

////////////////////////////////////////////////////////////////////////////////
// Experimental AP_Limits library - set constraints, limits, fences, minima, maxima on various parameters
////////////////////////////////////////////////////////////////////////////////
#ifdef AP_LIMITS

AP_Limits limits;

AP_Limit_GPSLock        gpslock_limit(g_gps);

AP_Limit_Geofence       geofence_limit(FENCE_START_BYTE, FENCE_WP_SIZE, MAX_FENCEPOINTS, g_gps, &home, &current_loc);

AP_Limit_Altitude       altitude_limit(&current_loc);

#endif

////////////////////////////////////////////////////////////////////////////////
// Top-level logic
////////////////////////////////////////////////////////////////////////////////

void setup() {
    memcheck_init();
    init_ardupilot();
}

void loop()
{
    uint32_t timer                  = micros();
    static bool run_50hz_loop = false;
    uint16_t num_samples;

    // We want this to execute fast
    // ----------------------------
    num_samples = imu.num_samples_available();
    if (num_samples >= NUM_IMU_SAMPLES_FOR_100HZ) {

		#if DEBUG_FAST_LOOP == ENABLED
        Log_Write_Data(50, (int32_t)(timer - fast_loopTimer));
        #endif

        //PORTK |= B00010000;
        G_Dt                            = (float)(timer - fast_loopTimer) / 1000000.f;                  // used by PI Loops
        fast_loopTimer          = timer;

        // for mainloop failure monitoring
        mainLoop_count++;

        // Execute the fast loop
        // ---------------------
        fast_loop();////

        // run the 50hz loop 1/2 the time
        run_50hz_loop = !run_50hz_loop;

        if( run_50hz_loop ) {

            #if DEBUG_MED_LOOP == ENABLED
            Log_Write_Data(51, (int32_t)(timer - fiftyhz_loopTimer));
            #endif

            // store the micros for the 50 hz timer
            fiftyhz_loopTimer               = timer;

            // port manipulation for external timing of main loops
            //PORTK |= B01000000;

            // reads all of the necessary trig functions for cameras, throttle, etc.
            // --------------------------------------------------------------------
            update_trig();

            // Rotate the Nav_lon and nav_lat vectors based on Yaw
            // ---------------------------------------------------
            calc_loiter_pitch_roll();

            // check for new GPS messages
            // --------------------------
            update_GPS();

            // perform 10hz tasks
            // ------------------
            medium_loop();

            // Stuff to run at full 50hz, but after the med loops
            // --------------------------------------------------
            fifty_hz_loop();

            counter_one_herz++;

            // trgger our 1 hz loop
            if(counter_one_herz >= 50) {
                super_slow_loop();
                counter_one_herz = 0;
            }
            perf_mon_counter++;
            if (perf_mon_counter > 600 ) {
                if (g.log_bitmask & MASK_LOG_PM)
                    Log_Write_Performance();

                gps_fix_count           = 0;
                perf_mon_counter        = 0;
            }
            //PORTK &= B10111111;
        }
    } else {
#ifdef DESKTOP_BUILD
        usleep(1000);
#endif
        if (num_samples < NUM_IMU_SAMPLES_FOR_100HZ-1) {
            // we have some spare cycles available
            // less than 20ms has passed. We have at least one millisecond
            // of free time. The most useful thing to do with that time is
            // to accumulate some sensor readings, specifically the
            // compass, which is often very noisy but is not interrupt
            // driven, so it can't accumulate readings by itself
            if (g.compass_enabled) {
                compass.accumulate();
            }
        }
    }

    // port manipulation for external timing of main loops
    //PORTK &= B11101111;

}
//  PORTK |= B01000000;
//	PORTK &= B10111111;

// Main loop - 100hz
static void fast_loop()
{
    // try to send any deferred messages if the serial port now has
    // some space available
    gcs_send_message(MSG_RETRY_DEFERRED);

    // run low level rate controllers that only require IMU data
    run_rate_controllers();

    // write out the servo PWM values
    // ------------------------------
    set_servos_4();

    // Read radio
    // ----------
    read_radio();

    // IMU DCM Algorithm
    // --------------------
    read_AHRS();

    // Inertial Nav
    // --------------------
#if INERTIAL_NAV == ENABLED
    calc_inertia();
#endif

    // optical flow
    // --------------------
#ifdef OPTFLOW_ENABLED
    if(g.optflow_enabled) {
        update_optical_flow();
    }
#endif

    // custom code/exceptions for flight modes
    // ---------------------------------------
    update_yaw_mode();
    update_roll_pitch_mode();

    // update targets to rate controllers
    update_rate_contoller_targets();

    // agmatthews - USERHOOKS
#ifdef USERHOOK_FASTLOOP
    USERHOOK_FASTLOOP
#endif

}

static void medium_loop()
{
    // This is the start of the medium (10 Hz) loop pieces
    // -----------------------------------------
    switch(medium_loopCounter) {

    // This case deals with the GPS and Compass
    //-----------------------------------------
    case 0:
        medium_loopCounter++;

#if HIL_MODE != HIL_MODE_ATTITUDE                                                               // don't execute in HIL mode
        if(g.compass_enabled) {
            if (compass.read()) {
                compass.null_offsets();
            }
        }
#endif

        // auto_trim, uses an auto_level algorithm
        auto_trim();

        // record throttle output
        // ------------------------------
        throttle_integrator += g.rc_3.servo_out;
        break;

    // This case performs some navigation computations
    //------------------------------------------------
    case 1:
        medium_loopCounter++;

        // calculate the copter's desired bearing and WP distance
        // ------------------------------------------------------
        if(nav_ok) {
            // clear nav flag
            nav_ok = false;

            // calculate distance, angles to target
            navigate();

            // update flight control system
            update_navigation();

            // update log
            if (g.log_bitmask & MASK_LOG_NTUN && motors.armed()) {
                Log_Write_Nav_Tuning();
            }
        }
        break;

    // command processing
    //-------------------
    case 2:
        medium_loopCounter++;

        if(control_mode == TOY_A) {
            update_toy_throttle();

            if(throttle_mode == THROTTLE_AUTO) {
                update_toy_altitude();
            }
        }

        alt_sensor_flag = true;
        break;

    // This case deals with sending high rate telemetry
    //-------------------------------------------------
    case 3:
        medium_loopCounter++;

        // perform next command
        // --------------------
        if(control_mode == AUTO) {
            if(home_is_set == true && g.command_total > 1) {
                update_commands();
            }
        }

        if(motors.armed()) {
            if (g.log_bitmask & MASK_LOG_ATTITUDE_MED) {
                Log_Write_Attitude();
#if SECONDARY_DMP_ENABLED == ENABLED
                Log_Write_DMP();
#endif
            }

            if (g.log_bitmask & MASK_LOG_MOTORS)
                Log_Write_Motors();
        }
        break;

    // This case controls the slow loop
    //---------------------------------
    case 4:
        medium_loopCounter = 0;

        if (g.battery_monitoring != 0) {
            read_battery();
        }

        // Accel trims      = hold > 2 seconds
        // Throttle cruise  = switch less than 1 second
        // --------------------------------------------
        read_trim_switch();

        // Check for engine arming
        // -----------------------
        arm_motors();

        // agmatthews - USERHOOKS
#ifdef USERHOOK_MEDIUMLOOP
        USERHOOK_MEDIUMLOOP
#endif

#if COPTER_LEDS == ENABLED
        update_copter_leds();
#endif

        slow_loop();
        break;

    default:
        // this is just a catch all
        // ------------------------
        medium_loopCounter = 0;
        break;
    }
}

// stuff that happens at 50 hz
// ---------------------------
static void fifty_hz_loop()
{
    // read altitude sensors or estimate altitude
    // ------------------------------------------
    update_altitude_est();

    // Update the throttle ouput
    // -------------------------
    update_throttle_mode();

    // Read Sonar
    // ----------
# if CONFIG_SONAR == ENABLED
    if(g.sonar_enabled) {
        sonar_alt = sonar.read();
    }
#endif

#if TOY_EDF == ENABLED
    edf_toy();
#endif

#ifdef USERHOOK_50HZLOOP
    USERHOOK_50HZLOOP
#endif


#if HIL_MODE != HIL_MODE_DISABLED && FRAME_CONFIG != HELI_FRAME
    // HIL for a copter needs very fast update of the servo values
    gcs_send_message(MSG_RADIO_OUT);
#endif

#if MOUNT == ENABLED
    // update camera mount's position
    camera_mount.update_mount_position();
#endif

#if MOUNT2 == ENABLED
    // update camera mount's position
    camera_mount2.update_mount_position();
#endif

#if CAMERA == ENABLED
    g.camera.trigger_pic_cleanup();
#endif

# if HIL_MODE == HIL_MODE_DISABLED
    if (g.log_bitmask & MASK_LOG_ATTITUDE_FAST && motors.armed()) {
        Log_Write_Attitude();
#if SECONDARY_DMP_ENABLED == ENABLED
        Log_Write_DMP();
#endif
    }

    if (g.log_bitmask & MASK_LOG_RAW && motors.armed())
        Log_Write_Raw();
#endif

    // kick the GCS to process uplink data
    gcs_update();
    gcs_data_stream_send();
}


static void slow_loop()
{

#if AP_LIMITS == ENABLED

    // Run the AP_Limits main loop
    limits_loop();

#endif // AP_LIMITS_ENABLED

    // This is the slow (3 1/3 Hz) loop pieces
    //----------------------------------------
    switch (slow_loopCounter) {
    case 0:
        slow_loopCounter++;
        superslow_loopCounter++;

        if(superslow_loopCounter > 1200) {
#if HIL_MODE != HIL_MODE_ATTITUDE
            if(g.rc_3.control_in == 0 && control_mode == STABILIZE && g.compass_enabled) {
                compass.save_offsets();
                superslow_loopCounter = 0;
            }
#endif
        }


        if(motors.armed()) {
            if (g.log_bitmask & MASK_LOG_ITERM)
                Log_Write_Iterm();
        }else{
            // check the user hasn't updated the frame orientation
            motors.set_frame_orientation(g.frame_orientation);
        }

        break;

    case 1:
        slow_loopCounter++;

        // Read 3-position switch on radio
        // -------------------------------
        read_control_switch();

#if MOUNT == ENABLED
        update_aux_servo_function(&g.rc_5, &g.rc_6, &g.rc_7, &g.rc_8, &g.rc_10, &g.rc_11);
#endif
        enable_aux_servos();

#if MOUNT == ENABLED
        camera_mount.update_mount_type();
#endif

#if MOUNT2 == ENABLED
        camera_mount2.update_mount_type();
#endif

        // agmatthews - USERHOOKS
#ifdef USERHOOK_SLOWLOOP
        USERHOOK_SLOWLOOP
#endif

        break;

    case 2:
        slow_loopCounter = 0;
        update_events();

        // blink if we are armed
        update_lights();

        if(g.radio_tuning > 0)
            tuning();

#if USB_MUX_PIN > 0
        check_usb_mux();
#endif
        break;

    default:
        slow_loopCounter = 0;
        break;
    }
}

#define AUTO_DISARMING_DELAY 25
// 1Hz loop
static void super_slow_loop()
{
    if (g.log_bitmask & MASK_LOG_CUR && motors.armed())
        Log_Write_Current();


#if 0         //CENTER_THROTTLE == 1
    // recalibrate the throttle_cruise to center on the sticks
    g.rc_3.set_range((g.throttle_cruise - (MAXIMUM_THROTTLE - g.throttle_cruise)), MAXIMUM_THROTTLE);
    g.rc_3.set_range_out(0,1000);
#endif

    // this function disarms the copter if it has been sitting on the ground for any moment of time greater than 25 seconds
    // but only of the control mode is manual
    if((control_mode <= ACRO) && (g.rc_3.control_in == 0)) {
        auto_disarming_counter++;

        if(auto_disarming_counter == AUTO_DISARMING_DELAY) {
            init_disarm_motors();
        }else if (auto_disarming_counter > AUTO_DISARMING_DELAY) {
            auto_disarming_counter = AUTO_DISARMING_DELAY + 1;
        }
    }else{
        auto_disarming_counter = 0;
    }

    gcs_send_message(MSG_HEARTBEAT);

    // agmatthews - USERHOOKS
#ifdef USERHOOK_SUPERSLOWLOOP
    USERHOOK_SUPERSLOWLOOP
#endif

    /*
     *  //Serial.printf("alt %d, next.alt %d, alt_err: %d, cruise: %d, Alt_I:%1.2f, wp_dist %d, tar_bear %d, home_d %d, homebear %d\n",
     *                               current_loc.alt,
     *                               next_WP.alt,
     *                               altitude_error,
     *                               g.throttle_cruise.get(),
     *                               g.pi_alt_hold.get_integrator(),
     *                               wp_distance,
     *                               target_bearing,
     *                               home_distance,
     *                               home_to_copter_bearing);
     */
}

// called at 100hz but data from sensor only arrives at 20 Hz
#ifdef OPTFLOW_ENABLED
static void update_optical_flow(void)
{
    static uint32_t last_of_update = 0;
    static int log_counter = 0;

    // if new data has arrived, process it
    if( optflow.last_update != last_of_update ) {
        last_of_update = optflow.last_update;
        optflow.update_position(ahrs.roll, ahrs.pitch, cos_yaw_x, sin_yaw_y, current_loc.alt);      // updates internal lon and lat with estimation based on optical flow

        // write to log at 5hz
        log_counter++;
        if( log_counter >= 4 ) {
            log_counter = 0;
            if (g.log_bitmask & MASK_LOG_OPTFLOW) {
                Log_Write_Optflow();
            }
        }
    }
}
#endif

// called at 50hz
static void update_GPS(void)
{
    // A counter that is used to grab at least 10 reads before commiting the Home location
    static byte ground_start_count  = 10;

    g_gps->update();
    update_GPS_light();

    if (gps_watchdog < 30) {
        gps_watchdog++;
    }else{
        // after 12 reads we guess we may have lost GPS signal, stop navigating
        // we have lost GPS signal for a moment. Reduce our error to avoid flyaways
        auto_roll  >>= 1;
        auto_pitch >>= 1;
    }

    if (g_gps->new_data && g_gps->fix) {
        // clear new data flag
        g_gps->new_data = false;

        // check for duiplicate GPS messages
        if(last_gps_time != g_gps->time) {

            // look for broken GPS
            // ---------------
            gps_watchdog = 0;

            // OK to run the nav routines
            // ---------------
            nav_ok = true;

            // for performance monitoring
            // --------------------------
            gps_fix_count++;

            // used to calculate speed in X and Y, iterms
            // ------------------------------------------
            dTnav                           = (float)(millis() - nav_loopTimer)/ 1000.0;
            nav_loopTimer           = millis();

            // prevent runup from bad GPS
            // --------------------------
            dTnav = min(dTnav, 1.0);

            if(ground_start_count > 1) {
                ground_start_count--;

            } else if (ground_start_count == 1) {

                // We countdown N number of good GPS fixes
                // so that the altitude is more accurate
                // -------------------------------------
                if (current_loc.lat == 0) {
                    ground_start_count = 5;

                }else{
                    if (g.compass_enabled) {
                        // Set compass declination automatically
                        compass.set_initial_location(g_gps->latitude, g_gps->longitude);
                    }
                    // save home to eeprom (we must have a good fix to have reached this point)
                    init_home();
                    ground_start_count = 0;
                }
            }

            current_loc.lng = g_gps->longitude;                 // Lon * 10^7
            current_loc.lat = g_gps->latitude;                  // Lat * 10^7

            calc_XY_velocity();

            if (g.log_bitmask & MASK_LOG_GPS && motors.armed()) {
                Log_Write_GPS();
            }

#if HIL_MODE == HIL_MODE_ATTITUDE                                                               // only execute in HIL mode
            //update_altitude();
            alt_sensor_flag = true;
#endif
        }

        // save GPS time so we don't get duplicate reads
        last_gps_time = g_gps->time;
    }
}

void update_yaw_mode(void)
{
    switch(yaw_mode) {
    case YAW_ACRO:
        if(g.axis_enabled) {
            get_yaw_rate_stabilized_ef(g.rc_4.control_in);
        }else{
            get_acro_yaw(g.rc_4.control_in);
        }
        return;
        break;

        // update to allow external roll/yaw mixing
#if TOY_LOOKUP == TOY_EXTERNAL_MIXER
    case YAW_TOY:
#endif

    case YAW_HOLD:
    	get_yaw_rate_stabilized_ef(g.rc_4.control_in);
        break;

    case YAW_LOOK_AT_HOME:
        //nav_yaw updated in update_navigation()
        get_stabilize_yaw(nav_yaw);
        break;

    case YAW_AUTO:
        nav_yaw += constrain(wrap_180(auto_yaw - nav_yaw), -60, 60);                 // 40 deg a second
        //Serial.printf("nav_yaw %d ", nav_yaw);
        nav_yaw  = wrap_360(nav_yaw);
        get_stabilize_yaw(nav_yaw);
        break;
    }
}

void update_roll_pitch_mode(void)
{
    if (do_flip) {
        if(abs(g.rc_1.control_in) < 4000) {
            roll_flip();
            return;
        }else{
            // force an exit from the loop if we are not hands off sticks.
            do_flip = false;
        }
    }

    switch(roll_pitch_mode) {
    case ROLL_PITCH_ACRO:
        if(g.axis_enabled) {
            get_roll_rate_stabilized_ef(g.rc_1.control_in);
            get_pitch_rate_stabilized_ef(g.rc_2.control_in);
        }else{
            // ACRO does not get SIMPLE mode ability
#if FRAME_CONFIG == HELI_FRAME
            if (motors.flybar_mode == 1) {
                g.rc_1.servo_out = g.rc_1.control_in;
                g.rc_2.servo_out = g.rc_2.control_in;
            } else {
                get_acro_roll(g.rc_1.control_in);
                get_acro_pitch(g.rc_2.control_in);
            }
#else
            get_acro_roll(g.rc_1.control_in);
            get_acro_pitch(g.rc_2.control_in);
#endif
        }
        break;

    case ROLL_PITCH_STABLE:
        // apply SIMPLE mode transform
        if(do_simple && new_radio_frame) {
            update_simple_mode();
        }

        control_roll            = g.rc_1.control_in;
        control_pitch           = g.rc_2.control_in;
     
        get_stabilize_roll(control_roll);
        get_stabilize_pitch(control_pitch);

        break;

    case ROLL_PITCH_AUTO:
        // apply SIMPLE mode transform
        if(do_simple && new_radio_frame) {
            update_simple_mode();
        }
        // mix in user control with Nav control
        nav_roll                += constrain(wrap_180(auto_roll  - nav_roll),  -g.auto_slew_rate.get(), g.auto_slew_rate.get());                 // 40 deg a second
        nav_pitch               += constrain(wrap_180(auto_pitch - nav_pitch), -g.auto_slew_rate.get(), g.auto_slew_rate.get());                 // 40 deg a second

        control_roll            = g.rc_1.control_mix(nav_roll);
        control_pitch           = g.rc_2.control_mix(nav_pitch);

        get_stabilize_roll(control_roll);
        get_stabilize_pitch(control_pitch);
        break;

    case ROLL_PITCH_STABLE_OF:
        // apply SIMPLE mode transform
        if(do_simple && new_radio_frame) {
            update_simple_mode();
        }

        control_roll            = g.rc_1.control_in;
        control_pitch           = g.rc_2.control_in;

        // mix in user control with optical flow
        get_stabilize_roll(get_of_roll(control_roll));
        get_stabilize_pitch(get_of_pitch(control_pitch));
        break;

    // THOR
    // a call out to the main toy logic
    case ROLL_PITCH_TOY:
        roll_pitch_toy();
        break;
    }

    if(g.rc_3.control_in == 0 && control_mode <= ACRO) {
        reset_rate_I();
        reset_stability_I();
    }

    //if(takeoff_complete == false){
    // reset these I terms to prevent awkward tipping on takeoff
    //reset_rate_I();
    //reset_stability_I();
    //}

    if(new_radio_frame) {
        // clear new radio frame info
        new_radio_frame = false;

        // These values can be used to scale the PID gains
        // This allows for a simple gain scheduling implementation
        roll_scale_d    = g.stabilize_d_schedule * (float)abs(g.rc_1.control_in);
        roll_scale_d    = (1 - (roll_scale_d / 4500.0));
        roll_scale_d    = constrain(roll_scale_d, 0, 1) * g.stabilize_d;

        pitch_scale_d   = g.stabilize_d_schedule * (float)abs(g.rc_2.control_in);
        pitch_scale_d   = (1 - (pitch_scale_d / 4500.0));
        pitch_scale_d   = constrain(pitch_scale_d, 0, 1) * g.stabilize_d;
    }
}

// new radio frame is used to make sure we only call this at 50hz
void update_simple_mode(void)
{
    static byte simple_counter = 0;             // State machine counter for Simple Mode
    static float simple_sin_y=0, simple_cos_x=0;

    // used to manage state machine
    // which improves speed of function
    simple_counter++;

    int16_t delta = wrap_360(ahrs.yaw_sensor - initial_simple_bearing)/100;

    if (simple_counter == 1) {
        // roll
        simple_cos_x = sin(radians(90 - delta));

    }else if (simple_counter > 2) {
        // pitch
        simple_sin_y = cos(radians(90 - delta));
        simple_counter = 0;
    }

    // Rotate input by the initial bearing
    int16_t _roll   = g.rc_1.control_in * simple_cos_x + g.rc_2.control_in * simple_sin_y;
    int16_t _pitch  = -(g.rc_1.control_in * simple_sin_y - g.rc_2.control_in * simple_cos_x);

    g.rc_1.control_in = _roll;
    g.rc_2.control_in = _pitch;
}

#define THROTTLE_FILTER_SIZE 2

// 50 hz update rate
// controls all throttle behavior
void update_throttle_mode(void)
{
    if(do_flip)     // this is pretty bad but needed to flip in AP modes.
        return;

    int16_t throttle_out;

#if AUTO_THROTTLE_HOLD != 0
    static float throttle_avg = 0;      // this is initialised to g.throttle_cruise later
#endif

#if FRAME_CONFIG != HELI_FRAME
    // calculate angle boost
    if(throttle_mode ==  THROTTLE_MANUAL) {
        angle_boost = get_angle_boost(g.rc_3.control_in);
    }else{
        angle_boost = get_angle_boost(g.throttle_cruise);
    }
#endif

    switch(throttle_mode) {
    case THROTTLE_MANUAL:
        if (g.rc_3.control_in > 0) {
#if FRAME_CONFIG == HELI_FRAME
            g.rc_3.servo_out = heli_get_angle_boost(g.rc_3.control_in);
#else
            if (control_mode == ACRO) {
                g.rc_3.servo_out        = g.rc_3.control_in;
            }else{
                g.rc_3.servo_out        = g.rc_3.control_in + angle_boost;
            }
#endif

#if AUTO_THROTTLE_HOLD != 0
            // ensure throttle_avg has been initialised
            if( throttle_avg == 0 ) {
                throttle_avg = g.throttle_cruise;
            }
            // calc average throttle
            if ((g.rc_3.control_in > g.throttle_min) && abs(climb_rate) < 60) {
                throttle_avg = throttle_avg * .99 + (float)g.rc_3.control_in * .01;
                g.throttle_cruise = throttle_avg;
            }
#endif

            if (takeoff_complete == false && motors.armed()) {
                if (g.rc_3.control_in > g.throttle_cruise) {
                    // we must be in the air by now
                    takeoff_complete = true;
                }
            }

        }else{

            // make sure we also request 0 throttle out
            // so the props stop ... properly
            // ----------------------------------------
            g.rc_3.servo_out = 0;
        }
        break;

    case THROTTLE_HOLD:
        // allow interactive changing of atitude
        if(g.rc_3.radio_in < (g.rc_3.radio_min + 200)){
            int16_t _rate = 120 - (((g.rc_3.radio_in - g.rc_3.radio_min) * 12) / 20);
            reset_throttle_counter = 150;
            nav_throttle        = get_throttle_rate(-_rate);
            g.rc_3.servo_out    = g.throttle_cruise + nav_throttle + angle_boost;
            break;
        }else if(g.rc_3.radio_in > (g.rc_3.radio_max - 200)){
            int16_t _rate = 180 - ((g.rc_3.radio_max -  g.rc_3.radio_in) * 18) / 20;
            reset_throttle_counter = 150;
            nav_throttle        = get_throttle_rate(_rate);
            g.rc_3.servo_out    = g.throttle_cruise + nav_throttle + angle_boost;
            break;
        }


        // allow 1 second of slow down after pilot moves throttle back into deadzone
        if(reset_throttle_counter > 0) {
            reset_throttle_counter--;
            // if 1 second has passed set the target altitude to the current altitude
            if(reset_throttle_counter == 0) {
                force_new_altitude(max(current_loc.alt, 100));
            }else{
                nav_throttle            = get_throttle_rate(0);
                g.rc_3.servo_out        = g.throttle_cruise + nav_throttle + angle_boost;
                break;
            }
        }

    // else fall through

    case THROTTLE_AUTO:

        if(motors.auto_armed() == true) {

            // how far off are we
            altitude_error = get_altitude_error();

            int16_t desired_speed;
            if(alt_change_flag == REACHED_ALT) {                    // we are at or above the target alt
                desired_speed           = g.pi_alt_hold.get_p(altitude_error);                                          // calculate desired speed from lon error
                update_throttle_cruise(g.pi_alt_hold.get_i(altitude_error, .02));
                desired_speed           = constrain(desired_speed, -250, 250);
                nav_throttle            = get_throttle_rate(desired_speed);
            }else{
                desired_speed           = get_desired_climb_rate();
                nav_throttle            = get_throttle_rate(desired_speed);
            }
        }

        // hack to remove the influence of the ground effect
        if(g.sonar_enabled && current_loc.alt < 100 && landing_boost != 0) {
            nav_throttle = min(nav_throttle, 0);
        }

#if FRAME_CONFIG == HELI_FRAME
        throttle_out = heli_get_angle_boost(g.throttle_cruise + nav_throttle - landing_boost);
#else
        throttle_out = g.throttle_cruise + nav_throttle + angle_boost - landing_boost;
#endif

        g.rc_3.servo_out = throttle_out;
        break;
    }
}

// called after a GPS read
static void update_navigation()
{
    // wp_distance is in CM
    // --------------------
    switch(control_mode) {
    case AUTO:
        // note: wp_control is handled by commands_logic
        verify_commands();

        // calculates desired Yaw
        update_auto_yaw();

        // calculates the desired Roll and Pitch
        update_nav_wp();
        break;

    case GUIDED:
        wp_control = WP_MODE;
        // check if we are close to point > loiter
        wp_verify_byte = 0;
        verify_nav_wp();

        if (wp_control == WP_MODE) {
            update_auto_yaw();
        } else {
            set_mode(LOITER);
        }
        update_nav_wp();
        break;

    case RTL:
        // have we reached the desired Altitude?
        if(alt_change_flag <= REACHED_ALT) {                // we are at or above the target alt
            if(rtl_reached_alt == false) {
                rtl_reached_alt = true;
                do_RTL();
            }
            wp_control = WP_MODE;
            // checks if we have made it to home
            update_nav_RTL();
        } else{
            // we need to loiter until we are ready to come home
            wp_control = LOITER_MODE;
        }

        // calculates desired Yaw
#if FRAME_CONFIG ==     HELI_FRAME
        update_auto_yaw();
#endif

        // calculates the desired Roll and Pitch
        update_nav_wp();
        break;

    // switch passthrough to LOITER
    case LOITER:
    case POSITION:
        // This feature allows us to reposition the quad when the user lets
        // go of the sticks

        if((abs(g.rc_2.control_in) + abs(g.rc_1.control_in)) > 500) {
            if(wp_distance > 500)
                loiter_override         = true;
        }

        // Allow the user to take control temporarily,
        if(loiter_override) {
            // this sets the copter to not try and nav while we control it
            wp_control      = NO_NAV_MODE;

            // reset LOITER to current position
            next_WP.lat = current_loc.lat;
            next_WP.lng = current_loc.lng;

            if(g.rc_2.control_in == 0 && g.rc_1.control_in == 0) {
                loiter_override         = false;
                wp_control                      = LOITER_MODE;
            }
        }else{
            wp_control = LOITER_MODE;
        }

        if(loiter_timer != 0) {
            // If we have a safe approach alt set and we have been loitering for 20 seconds(default), begin approach
            if((millis() - loiter_timer) > (uint32_t)g.auto_land_timeout.get()) {
                // just to make sure we clear the timer
                loiter_timer = 0;
                if(g.rtl_approach_alt == 0) {
                    set_mode(LAND);
                    if(home_distance < 300) {
                        next_WP.lat = home.lat;
                        next_WP.lng = home.lng;
                    }
                }else{
                    if(g.rtl_approach_alt < current_loc.alt) {
                        set_new_altitude(g.rtl_approach_alt);
                    }
                }
            }
        }

        // calculates the desired Roll and Pitch
        update_nav_wp();
        break;

    case LAND:
        if(g.sonar_enabled)
            verify_land_sonar();
        else
            verify_land_baro();

        // calculates the desired Roll and Pitch
        update_nav_wp();
        break;

    case CIRCLE:
        wp_control              = CIRCLE_MODE;

        // calculates desired Yaw
        update_auto_yaw();
        update_nav_wp();
        break;

    case STABILIZE:
    case TOY_A:
    case TOY_M:
        wp_control = NO_NAV_MODE;
        update_nav_wp();
        break;
    }

    // are we in SIMPLE mode?
    if(do_simple && g.super_simple) {
        // get distance to home
        if(home_distance > SUPER_SIMPLE_RADIUS) {        // 10m from home
            // we reset the angular offset to be a vector from home to the quad
            initial_simple_bearing = home_to_copter_bearing;
            //Serial.printf("ISB: %d\n", initial_simple_bearing);
        }
    }

    if(yaw_mode == YAW_LOOK_AT_HOME) {
        if(home_is_set) {
            nav_yaw = get_bearing_cd(&current_loc, &home);
        } else {
            nav_yaw = 0;
        }
    }
}

static void update_nav_RTL()
{
    // Have we have reached Home?
    if(wp_distance <= 200 || check_missed_wp()) {
        // if loiter_timer value > 0, we are set to trigger auto_land or approach
        set_mode(LOITER);

        // just in case we arrive and we aren't at the lower RTL alt yet.
        set_new_altitude(get_RTL_alt());

        // force loitering above home
        next_WP.lat = home.lat;
        next_WP.lng = home.lng;

        // If failsafe OR auto approach altitude is set
        // we will go into automatic land, (g.rtl_approach_alt) is the lowest point
        // -1 means disable feature
        if(failsafe || g.rtl_approach_alt >= 0)
            loiter_timer = millis();
        else
            loiter_timer = 0;
    }

    slow_wp = true;
}

static void read_AHRS(void)
{
    // Perform IMU calculations and get attitude info
    //-----------------------------------------------
#if HIL_MODE != HIL_MODE_DISABLED
    // update hil before ahrs update
    gcs_update();
#endif

    ahrs.update();
    omega = imu.get_gyro();

#if SECONDARY_DMP_ENABLED == ENABLED
    ahrs2.update();
#endif
}

static void update_trig(void){
    Vector2f yawvector;
    Matrix3f temp   = ahrs.get_dcm_matrix();

    yawvector.x     = temp.a.x;     // sin
    yawvector.y     = temp.b.x;         // cos
    yawvector.normalize();

    cos_pitch_x     = safe_sqrt(1 - (temp.c.x * temp.c.x));     // level = 1
    cos_roll_x          = temp.c.z / cos_pitch_x;                       // level = 1

    cos_pitch_x = constrain(cos_pitch_x, 0, 1.0);
    // this relies on constrain() of infinity doing the right thing,
    // which it does do in avr-libc
    cos_roll_x  = constrain(cos_roll_x, -1.0, 1.0);

    sin_yaw_y               = yawvector.x;                                              // 1y = north
    cos_yaw_x               = yawvector.y;                                              // 0x = north

    // added to convert earth frame to body frame for rate controllers
    sin_pitch = -temp.c.x;
    sin_roll = temp.c.y / cos_pitch_x;

    //flat:
    // 0 ° = cos_yaw:  0.00, sin_yaw:  1.00,
    // 90° = cos_yaw:  1.00, sin_yaw:  0.00,
    // 180 = cos_yaw:  0.00, sin_yaw: -1.00,
    // 270 = cos_yaw: -1.00, sin_yaw:  0.00,
}

// updated at 10hz
static void update_altitude()
{
    static int16_t old_sonar_alt   = 0;
    static int32_t old_baro_alt    = 0;

#if HIL_MODE == HIL_MODE_ATTITUDE
    // we are in the SIM, fake out the baro and Sonar
    int16_t fake_relative_alt = g_gps->altitude - gps_base_alt;
    baro_alt                = fake_relative_alt;
    sonar_alt               = fake_relative_alt;

    baro_rate               = (baro_alt - old_baro_alt) * 5;             // 5hz
    old_baro_alt            = baro_alt;

#else
    // This is real life

 #if INERTIAL_NAV == ENABLED
    baro_rate                       = accels_velocity.z;

 #else
    // read in Actual Baro Altitude
    baro_alt                        = read_barometer();

    // calc the vertical accel rate

     // 2.6 way
     int16_t temp		= (baro_alt - old_baro_alt) * 10;
     baro_rate          = (temp + baro_rate) >> 1;
     baro_rate			= constrain(baro_rate, -300, 300);
     old_baro_alt		= baro_alt;

    // Using Tridge's new clamb rate calc
    /*
    int16_t temp                    = barometer.get_climb_rate() * 100;
    baro_rate                       = (temp + baro_rate) >> 1;
    baro_rate                       = constrain(baro_rate, -300, 300);
    */
 #endif

    // Note: sonar_alt is calculated in a faster loop and filtered with a mode filter
#endif

    if(g.sonar_enabled) {
        // filter out offset
        float scale;

        // calc rate of change for Sonar
#if HIL_MODE == HIL_MODE_ATTITUDE
        // we are in the SIM, fake outthe Sonar rate
        sonar_rate              = baro_rate;
#else
        // This is real life
        // calc the vertical accel rate
        // positive = going up.
        sonar_rate              = (sonar_alt - old_sonar_alt) * 10;
        sonar_rate              = constrain(sonar_rate, -150, 150);
        old_sonar_alt   = sonar_alt;
#endif

        if(baro_alt < 800) {
#if SONAR_TILT_CORRECTION == 1
            // correct alt for angle of the sonar
            float temp = cos_pitch_x * cos_roll_x;
            temp = max(temp, 0.707);
            sonar_alt = (float)sonar_alt * temp;
#endif

            scale = (float)(sonar_alt - 400) / 200.0;
            scale = constrain(scale, 0.0, 1.0);
            // solve for a blended altitude
            current_loc.alt = ((float)sonar_alt * (1.0 - scale)) + ((float)baro_alt * scale);

            // solve for a blended climb_rate
            climb_rate_actual = ((float)sonar_rate * (1.0 - scale)) + (float)baro_rate * scale;

        }else{
            // we must be higher than sonar (>800), don't get tricked by bad sonar reads
            current_loc.alt = baro_alt;
            // dont blend, go straight baro

            climb_rate_actual       = baro_rate;
        }

    }else{
        // NO Sonar case
        current_loc.alt = baro_alt;
        climb_rate_actual = baro_rate;
    }

    // update the target altitude
    verify_altitude();

    // calc error
    climb_rate_error = (climb_rate_actual - climb_rate) / 5;

#if INERTIAL_NAV == ENABLED
    // inertial_nav
    z_error_correction();
#endif
}

static void update_altitude_est()
{
    if(alt_sensor_flag) {
        update_altitude();
        alt_sensor_flag = false;

        if(g.log_bitmask & MASK_LOG_CTUN && motors.armed()) {
            Log_Write_Control_Tuning();
        }

    }else{
        // simple dithering of climb rate
        climb_rate += climb_rate_error;
        current_loc.alt += (climb_rate / 50);
    }
    //Serial.printf(" %d, %d, %d, %d\n", climb_rate_actual, climb_rate_error, climb_rate, current_loc.alt);
}

static void tuning(){
    tuning_value = (float)g.rc_6.control_in / 1000.0;
    g.rc_6.set_range(g.radio_tuning_low,g.radio_tuning_high);                   // 0 to 1

    switch(g.radio_tuning) {

    case CH6_RATE_KD:
        g.pid_rate_roll.kD(tuning_value);
        g.pid_rate_pitch.kD(tuning_value);
        break;

    case CH6_STABILIZE_KP:
        g.pi_stabilize_roll.kP(tuning_value);
        g.pi_stabilize_pitch.kP(tuning_value);
        break;

    case CH6_STABILIZE_KI:
        g.pi_stabilize_roll.kI(tuning_value);
        g.pi_stabilize_pitch.kI(tuning_value);
        break;

    case CH6_DAMP:
    case CH6_STABILIZE_KD:
        g.stabilize_d = tuning_value;
        break;

    case CH6_ACRO_KP:
        g.acro_p = tuning_value;
        break;

    case CH6_RATE_KP:
        g.pid_rate_roll.kP(tuning_value);
        g.pid_rate_pitch.kP(tuning_value);
        break;

    case CH6_RATE_KI:
        g.pid_rate_roll.kI(tuning_value);
        g.pid_rate_pitch.kI(tuning_value);
        break;

    case CH6_YAW_KP:
        g.pi_stabilize_yaw.kP(tuning_value);
        break;

    case CH6_YAW_KI:
        g.pi_stabilize_yaw.kI(tuning_value);
        break;

    case CH6_YAW_RATE_KP:
        g.pid_rate_yaw.kP(tuning_value);
        break;

    case CH6_YAW_RATE_KD:
        g.pid_rate_yaw.kD(tuning_value);
        break;

    case CH6_THROTTLE_KP:
        g.pid_throttle.kP(tuning_value);
        break;

    case CH6_TOP_BOTTOM_RATIO:
        motors.top_bottom_ratio = tuning_value;
        break;

    case CH6_RELAY:
        if (g.rc_6.control_in > 525) relay.on();
        if (g.rc_6.control_in < 475) relay.off();
        break;

    case CH6_TRAVERSE_SPEED:
        g.waypoint_speed_max = g.rc_6.control_in;
        break;

    case CH6_LOITER_KP:
        g.pi_loiter_lat.kP(tuning_value);
        g.pi_loiter_lon.kP(tuning_value);
        break;

    case CH6_LOITER_KI:
        g.pi_loiter_lat.kI(tuning_value);
        g.pi_loiter_lon.kI(tuning_value);
        break;

    case CH6_NAV_KP:
        g.pid_nav_lat.kP(tuning_value);
        g.pid_nav_lon.kP(tuning_value);
        break;

    case CH6_LOITER_RATE_KP:
        g.pid_loiter_rate_lon.kP(tuning_value);
        g.pid_loiter_rate_lat.kP(tuning_value);
        break;

    case CH6_LOITER_RATE_KI:
        g.pid_loiter_rate_lon.kI(tuning_value);
        g.pid_loiter_rate_lat.kI(tuning_value);
        break;

    case CH6_LOITER_RATE_KD:
        g.pid_loiter_rate_lon.kD(tuning_value);
        g.pid_loiter_rate_lat.kD(tuning_value);
        break;

    case CH6_NAV_I:
        g.pid_nav_lat.kI(tuning_value);
        g.pid_nav_lon.kI(tuning_value);
        break;

#if FRAME_CONFIG == HELI_FRAME
    case CH6_HELI_EXTERNAL_GYRO:
        motors.ext_gyro_gain = tuning_value;
        break;
#endif

    case CH6_THR_HOLD_KP:
        g.pi_alt_hold.kP(tuning_value);
        break;

    case CH6_OPTFLOW_KP:
        g.pid_optflow_roll.kP(tuning_value);
        g.pid_optflow_pitch.kP(tuning_value);
        break;

    case CH6_OPTFLOW_KI:
        g.pid_optflow_roll.kI(tuning_value);
        g.pid_optflow_pitch.kI(tuning_value);
        break;

    case CH6_OPTFLOW_KD:
        g.pid_optflow_roll.kD(tuning_value);
        g.pid_optflow_pitch.kD(tuning_value);
        break;

#if HIL_MODE != HIL_MODE_ATTITUDE                                       // do not allow modifying _kp or _kp_yaw gains in HIL mode
    case CH6_AHRS_YAW_KP:
        ahrs._kp_yaw.set(tuning_value);
        break;

    case CH6_AHRS_KP:
        ahrs._kp.set(tuning_value);
        break;
#endif

    }
}

// Outputs Nav_Pitch and Nav_Roll
static void update_nav_wp()
{
    if(wp_control == LOITER_MODE) {

        // calc error to target
        calc_location_error(&next_WP);

        // use error as the desired rate towards the target
        calc_loiter(long_error, lat_error);

    }else if(wp_control == CIRCLE_MODE) {

        // check if we have missed the WP
        int16_t loiter_delta = (target_bearing - old_target_bearing)/100;

        // reset the old value
        old_target_bearing = target_bearing;

        // wrap values
        if (loiter_delta > 180) loiter_delta -= 360;
        if (loiter_delta < -180) loiter_delta += 360;

        // sum the angle around the WP
        loiter_sum += loiter_delta;

        // create a virtual waypoint that circles the next_WP
        // Count the degrees we have circulated the WP
        //int16_t circle_angle = wrap_360(target_bearing + 3000 + 18000) / 100;

        circle_angle += (circle_rate * dTnav);
        //1° = 0.0174532925 radians

        // wrap
        if (circle_angle > 6.28318531)
            circle_angle -= 6.28318531;

        next_WP.lng = circle_WP.lng + (g.loiter_radius * 100 * cos(1.57 - circle_angle) * scaleLongUp);
        next_WP.lat = circle_WP.lat + (g.loiter_radius * 100 * sin(1.57 - circle_angle));

        // use error as the desired rate towards the target
        // nav_lon, nav_lat is calculated

        if(wp_distance > 400) {
            calc_nav_rate(get_desired_speed(g.waypoint_speed_max, true));
        }else{
            // calc the lat and long error to the target
            calc_location_error(&next_WP);

            calc_loiter(long_error, lat_error);
        }

        //CIRCLE: angle:29, dist:0, lat:400, lon:242

        // debug
        //int16_t angleTest = degrees(circle_angle);
        //int16_t nroll = nav_roll;
        //int16_t npitch = nav_pitch;
        //Serial.printf("CIRCLE: angle:%d, dist:%d, X:%d, Y:%d, P:%d, R:%d  \n", angleTest, (int)wp_distance , (int)long_error, (int)lat_error, npitch, nroll);

    }else if(wp_control == WP_MODE) {
        // calc error to target
        calc_location_error(&next_WP);

        int16_t speed = get_desired_speed(g.waypoint_speed_max, slow_wp);
        // use error as the desired rate towards the target
        calc_nav_rate(speed);

    }else if(wp_control == NO_NAV_MODE) {
        // clear out our nav so we can do things like land straight down
        // or change Loiter position

        // We bring copy over our Iterms for wind control, but we don't navigate
        nav_lon = g.pid_loiter_rate_lon.get_integrator();
        nav_lat = g.pid_loiter_rate_lon.get_integrator();

        nav_lon                 = constrain(nav_lon, -2000, 2000);                              // 20°
        nav_lat                 = constrain(nav_lat, -2000, 2000);                              // 20°
    }
}

static void update_auto_yaw()
{
    if(wp_control == CIRCLE_MODE) {
        auto_yaw = get_bearing_cd(&current_loc, &circle_WP);

    }else if(wp_control == LOITER_MODE) {
        // just hold nav_yaw

    }else if(yaw_tracking == MAV_ROI_LOCATION) {
        auto_yaw = get_bearing_cd(&current_loc, &target_WP);

    }else if(yaw_tracking == MAV_ROI_WPNEXT) {
        // Point towards next WP
        auto_yaw = original_target_bearing;
    }
}
/// -*- tab-width: 4; Mode: C++; c-basic-offset: 4; indent-tabs-mode: nil -*-

static void
get_stabilize_roll(int32_t target_angle)
{
    // angle error
    target_angle            = wrap_180(target_angle - ahrs.roll_sensor);

#if FRAME_CONFIG == HELI_FRAME

    // limit the error we're feeding to the PID
    target_angle            = constrain(target_angle, -4500, 4500);

    // convert to desired Rate:
    target_angle            = g.pi_stabilize_roll.get_pi(target_angle, G_Dt);

    // output control - we do not use rate controllers for helicopters so send directly to servos
    g.rc_1.servo_out = constrain(target_angle, -4500, 4500);
#else

    // convert to desired Rate:
    int32_t target_rate = g.pi_stabilize_roll.get_p(target_angle);

    int16_t i_stab;
    if(labs(ahrs.roll_sensor) < 500) {
        target_angle            = constrain(target_angle, -500, 500);
        i_stab                          = g.pi_stabilize_roll.get_i(target_angle, G_Dt);
    }else{
        i_stab                          = g.pi_stabilize_roll.get_integrator();
    }

    // set targets for rate controller
    set_roll_rate_target(target_rate+i_stab, EARTH_FRAME);
#endif
}

static void
get_stabilize_pitch(int32_t target_angle)
{
    // angle error
    target_angle            = wrap_180(target_angle - ahrs.pitch_sensor);

#if FRAME_CONFIG == HELI_FRAME
    // limit the error we're feeding to the PID
    target_angle            = constrain(target_angle, -4500, 4500);

    // convert to desired Rate:
    target_angle            = g.pi_stabilize_pitch.get_pi(target_angle, G_Dt);

    // output control - we do not use rate controllers for helicopters so send directly to servos
    g.rc_2.servo_out = constrain(target_angle, -4500, 4500);
#else

    // convert to desired Rate:
    int32_t target_rate = g.pi_stabilize_pitch.get_p(target_angle);

    int16_t i_stab;
    if(labs(ahrs.pitch_sensor) < 500) {
        target_angle            = constrain(target_angle, -500, 500);
        i_stab                          = g.pi_stabilize_pitch.get_i(target_angle, G_Dt);
    }else{
        i_stab                          = g.pi_stabilize_pitch.get_integrator();
    }

    // set targets for rate controller
    set_pitch_rate_target(target_rate + i_stab, EARTH_FRAME);
#endif
}

static void
get_stabilize_yaw(int32_t target_angle)
{
    int32_t target_rate,i_term;
    int32_t angle_error;
    int32_t output = 0;

    // angle error
    angle_error             = wrap_180(target_angle - ahrs.yaw_sensor);

    // limit the error we're feeding to the PID
#if FRAME_CONFIG == HELI_FRAME
    angle_error             = constrain(angle_error, -4500, 4500);
#else
    angle_error             = constrain(angle_error, -4000, 4000);
#endif

    // convert angle error to desired Rate:
    target_rate = g.pi_stabilize_yaw.get_p(angle_error);
    i_term = g.pi_stabilize_yaw.get_i(angle_error, G_Dt);

    // do not use rate controllers for helicotpers with external gyros
#if FRAME_CONFIG == HELI_FRAME
    if(motors.ext_gyro_enabled) {
        g.rc_4.servo_out = constrain((target_rate + i_term), -4500, 4500);
    }
#endif

#if LOGGING_ENABLED == ENABLED
    static int8_t log_counter = 0;              // used to slow down logging of PID values to dataflash
    // log output if PID logging is on and we are tuning the yaw
    if( g.log_bitmask & MASK_LOG_PID && (g.radio_tuning == CH6_YAW_KP || g.radio_tuning == CH6_YAW_RATE_KP) ) {
        log_counter++;
        if( log_counter >= 10 ) {               // (update rate / desired output rate) = (100hz / 10hz) = 10
            log_counter = 0;
            Log_Write_PID(CH6_YAW_KP, angle_error, target_rate, i_term, 0, output, tuning_value);
        }
    }
#endif

    // set targets for rate controller
    set_yaw_rate_target(target_rate+i_term, EARTH_FRAME);
}

static void
get_stabilize_rate_yaw(int32_t target_rate)
{
    target_rate = g.pi_stabilize_yaw.get_p(target_rate);

    // set targets for rate controller
    set_yaw_rate_target(target_rate, EARTH_FRAME);
}

static void
get_acro_roll(int32_t target_rate)
{
    target_rate = target_rate * g.acro_p;

    // set targets for rate controller
    set_roll_rate_target(target_rate, BODY_FRAME);
}

static void
get_acro_pitch(int32_t target_rate)
{
    target_rate = target_rate * g.acro_p;

    // set targets for rate controller
    set_pitch_rate_target(target_rate, BODY_FRAME);
}

static void
get_acro_yaw(int32_t target_rate)
{
    target_rate = target_rate * g.acro_p;

    // set targets for rate controller
    set_yaw_rate_target(target_rate, BODY_FRAME);
}

// Roll with rate input and stabilized in the earth frame
static void
get_roll_rate_stabilized_ef(int32_t stick_angle)
{
    int32_t angle_error = 0;

    // convert the input to the desired roll rate
    int32_t target_rate = stick_angle * g.acro_p - (roll_axis * ACRO_ROLL_STABILISE)/100;

    // convert the input to the desired roll rate
    roll_axis += target_rate * G_Dt;
    roll_axis = wrap_180(roll_axis);

    // ensure that we don't reach gimbal lock
    if (roll_axis > 4500 || roll_axis < -4500) {
        roll_axis	= constrain(roll_axis, -4500, 4500);
        angle_error = wrap_180(roll_axis - ahrs.roll_sensor);
    } else {
        // angle error with maximum of +- max_angle_overshoot
        angle_error = wrap_180(roll_axis - ahrs.roll_sensor);
        angle_error	= constrain(angle_error, -MAX_ROLL_OVERSHOOT, MAX_ROLL_OVERSHOOT);
    }

    if (motors.armed() == false || ((g.rc_3.control_in == 0) && !failsafe)) {
        angle_error = 0;
    }

    // update roll_axis to be within max_angle_overshoot of our current heading
    roll_axis = wrap_180(angle_error + ahrs.roll_sensor);

    // set earth frame targets for rate controller

    // set earth frame targets for rate controller
	set_roll_rate_target(g.pi_stabilize_roll.get_p(angle_error) + target_rate, EARTH_FRAME);
}

// Pitch with rate input and stabilized in the earth frame
static void
get_pitch_rate_stabilized_ef(int32_t stick_angle)
{
    int32_t angle_error = 0;

    // convert the input to the desired pitch rate
    int32_t target_rate = stick_angle * g.acro_p - (pitch_axis * ACRO_PITCH_STABILISE)/100;

    // convert the input to the desired pitch rate
    pitch_axis += target_rate * G_Dt;
    pitch_axis = wrap_180(pitch_axis);

    // ensure that we don't reach gimbal lock
    if (pitch_axis > 4500 || pitch_axis < -4500) {
        pitch_axis	= constrain(pitch_axis, -4500, 4500);
        angle_error = wrap_180(pitch_axis - ahrs.pitch_sensor);
    } else {
        // angle error with maximum of +- max_angle_overshoot
        angle_error = wrap_180(pitch_axis - ahrs.pitch_sensor);
        angle_error	= constrain(angle_error, -MAX_PITCH_OVERSHOOT, MAX_PITCH_OVERSHOOT);
    }

    if (motors.armed() == false || ((g.rc_3.control_in == 0) && !failsafe)) {
        angle_error = 0;
    }

    // update pitch_axis to be within max_angle_overshoot of our current heading
    pitch_axis = wrap_180(angle_error + ahrs.pitch_sensor);

    // set earth frame targets for rate controller
	set_pitch_rate_target(g.pi_stabilize_pitch.get_p(angle_error) + target_rate, EARTH_FRAME);
}

// Yaw with rate input and stabilized in the earth frame
static void
get_yaw_rate_stabilized_ef(int32_t stick_angle)
{

    int32_t angle_error = 0;

    // convert the input to the desired yaw rate
    int32_t target_rate = stick_angle * g.acro_p;

    // convert the input to the desired yaw rate
    nav_yaw += target_rate * G_Dt;
    nav_yaw = wrap_360(nav_yaw);

    // calculate difference between desired heading and current heading
    angle_error = wrap_180(nav_yaw - ahrs.yaw_sensor);

    // limit the maximum overshoot
    angle_error	= constrain(angle_error, -MAX_YAW_OVERSHOOT, MAX_YAW_OVERSHOOT);

    if (motors.armed() == false || ((g.rc_3.control_in == 0) && !failsafe)) {
    	angle_error = 0;
    }

    // update nav_yaw to be within max_angle_overshoot of our current heading
    nav_yaw = wrap_360(angle_error + ahrs.yaw_sensor);

    // set earth frame targets for rate controller
	set_yaw_rate_target(g.pi_stabilize_yaw.get_p(angle_error)+target_rate, EARTH_FRAME);
}

// set_roll_rate_target - to be called by upper controllers to set roll rate targets in the earth frame
void set_roll_rate_target( int32_t desired_rate, uint8_t earth_or_body_frame ) {
    rate_targets_frame = earth_or_body_frame;
    if( earth_or_body_frame == BODY_FRAME ) {
        roll_rate_target_bf = desired_rate;
    }else{
        roll_rate_target_ef = desired_rate;
    }
}

// set_pitch_rate_target - to be called by upper controllers to set pitch rate targets in the earth frame
void set_pitch_rate_target( int32_t desired_rate, uint8_t earth_or_body_frame ) {
    rate_targets_frame = earth_or_body_frame;
    if( earth_or_body_frame == BODY_FRAME ) {
        pitch_rate_target_bf = desired_rate;
    }else{
        pitch_rate_target_ef = desired_rate;
    }
}

// set_yaw_rate_target - to be called by upper controllers to set yaw rate targets in the earth frame
void set_yaw_rate_target( int32_t desired_rate, uint8_t earth_or_body_frame ) {
    rate_targets_frame = earth_or_body_frame;
    if( earth_or_body_frame == BODY_FRAME ) {
        yaw_rate_target_bf = desired_rate;
    }else{
        yaw_rate_target_ef = desired_rate;
    }
}

// update_rate_contoller_targets - converts earth frame rates to body frame rates for rate controllers
void
update_rate_contoller_targets()
{
    if( rate_targets_frame == EARTH_FRAME ) {
        // convert earth frame rates to body frame rates
        roll_rate_target_bf = roll_rate_target_ef - sin_pitch * yaw_rate_target_ef;
        pitch_rate_target_bf = cos_roll_x * pitch_rate_target_ef + sin_roll * cos_pitch_x * yaw_rate_target_ef;
        yaw_rate_target_bf = cos_pitch_x * cos_roll_x * yaw_rate_target_ef - sin_roll * pitch_rate_target_ef;
    }
}

// run roll, pitch and yaw rate controllers and send output to motors
// targets for these controllers comes from stabilize controllers
void
run_rate_controllers()
{
#if FRAME_CONFIG == HELI_FRAME          // helicopters only use rate controllers for yaw and only when not using an external gyro
    if(!motors.ext_gyro_enabled) {
        g.rc_4.servo_out = get_rate_yaw(yaw_rate_target_bf);
    }
#else
    // call rate controllers
    g.rc_1.servo_out = get_rate_roll(roll_rate_target_bf);
    g.rc_2.servo_out = get_rate_pitch(pitch_rate_target_bf);
    g.rc_4.servo_out = get_rate_yaw(yaw_rate_target_bf);
#endif
}

static int16_t
get_rate_roll(int32_t target_rate)
{
    static int32_t last_rate = 0;                                       // previous iterations rate
    int32_t p,i,d;                                                                      // used to capture pid values for logging
    int32_t current_rate;                                                       // this iteration's rate
    int32_t rate_error;                                                                 // simply target_rate - current_rate
    int32_t rate_d;                                                                     // roll's acceleration
    int32_t output;                                                                     // output from pid controller
    int32_t rate_d_dampener;                                                    // value to dampen output based on acceleration

    // get current rate
    current_rate    = (omega.x * DEGX100);

    // calculate and filter the acceleration
    rate_d                  = roll_rate_d_filter.apply(current_rate - last_rate);

    // store rate for next iteration
    last_rate               = current_rate;

    // call pid controller
    rate_error      = target_rate - current_rate;
    p                       = g.pid_rate_roll.get_p(rate_error);
    // freeze I term if we've breached roll-pitch limits
    if( motors.reached_limit(AP_MOTOR_ROLLPITCH_LIMIT) ) {
        i                       = g.pid_rate_roll.get_integrator();
    }else{
        i                       = g.pid_rate_roll.get_i(rate_error, G_Dt);
    }
    d                       = g.pid_rate_roll.get_d(rate_error, G_Dt);
    output          = p + i + d;

    // Dampening output with D term
    rate_d_dampener = rate_d * roll_scale_d;
    rate_d_dampener = constrain(rate_d_dampener, -400, 400);
    output -= rate_d_dampener;

    // constrain output
    output = constrain(output, -5000, 5000);

#if LOGGING_ENABLED == ENABLED
    static int8_t log_counter = 0;                                      // used to slow down logging of PID values to dataflash
    // log output if PID logging is on and we are tuning the rate P, I or D gains
    if( g.log_bitmask & MASK_LOG_PID && (g.radio_tuning == CH6_RATE_KP || g.radio_tuning == CH6_RATE_KI || g.radio_tuning == CH6_RATE_KD) ) {
        log_counter++;
        if( log_counter >= 10 ) {               // (update rate / desired output rate) = (100hz / 10hz) = 10
            log_counter = 0;
            Log_Write_PID(CH6_RATE_KP, rate_error, p, i, d-rate_d_dampener, output, tuning_value);
        }
    }
#endif

    // output control
    return output;
}

static int16_t
get_rate_pitch(int32_t target_rate)
{
    static int32_t last_rate = 0;                                       // previous iterations rate
    int32_t p,i,d;                                                                      // used to capture pid values for logging
    int32_t current_rate;                                                       // this iteration's rate
    int32_t rate_error;                                                                 // simply target_rate - current_rate
    int32_t rate_d;                                                                     // roll's acceleration
    int32_t output;                                                                     // output from pid controller
    int32_t rate_d_dampener;                                                    // value to dampen output based on acceleration

    // get current rate
    current_rate    = (omega.y * DEGX100);

    // calculate and filter the acceleration
    rate_d                  = pitch_rate_d_filter.apply(current_rate - last_rate);

    // store rate for next iteration
    last_rate               = current_rate;

    // call pid controller
    rate_error      = target_rate - current_rate;
    p                       = g.pid_rate_pitch.get_p(rate_error);
    // freeze I term if we've breached roll-pitch limits
    if( motors.reached_limit(AP_MOTOR_ROLLPITCH_LIMIT) ) {
        i                       = g.pid_rate_pitch.get_integrator();
    }else{
        i                       = g.pid_rate_pitch.get_i(rate_error, G_Dt);
    }
    d                       = g.pid_rate_pitch.get_d(rate_error, G_Dt);
    output          = p + i + d;

    // Dampening output with D term
    rate_d_dampener = rate_d * pitch_scale_d;
    rate_d_dampener = constrain(rate_d_dampener, -400, 400);
    output -= rate_d_dampener;

    // constrain output
    output = constrain(output, -5000, 5000);

#if LOGGING_ENABLED == ENABLED
    static int8_t log_counter = 0;                                      // used to slow down logging of PID values to dataflash
    // log output if PID logging is on and we are tuning the rate P, I or D gains
    if( g.log_bitmask & MASK_LOG_PID && (g.radio_tuning == CH6_RATE_KP || g.radio_tuning == CH6_RATE_KI || g.radio_tuning == CH6_RATE_KD) ) {
        log_counter++;
        if( log_counter >= 10 ) {               // (update rate / desired output rate) = (100hz / 10hz) = 10
            log_counter = 0;
            Log_Write_PID(CH6_RATE_KP+100, rate_error, p, i, d-rate_d_dampener, output, tuning_value);
        }
    }
#endif

    // output control
    return output;
}

static int16_t
get_rate_yaw(int32_t target_rate)
{
    int32_t p,i,d;                                                                      // used to capture pid values for logging
    int32_t rate_error;
    int32_t output;

    // rate control
    rate_error              = target_rate - (omega.z * DEGX100);

    // separately calculate p, i, d values for logging
    p = g.pid_rate_yaw.get_p(rate_error);
    // freeze I term if we've breached yaw limits
    if( motors.reached_limit(AP_MOTOR_YAW_LIMIT) ) {
        i = g.pid_rate_yaw.get_integrator();
    }else{
        i = g.pid_rate_yaw.get_i(rate_error, G_Dt);
    }
    d = g.pid_rate_yaw.get_d(rate_error, G_Dt);

    output  = p+i+d;
    output = constrain(output, -4500, 4500);

#if LOGGING_ENABLED == ENABLED
    static int8_t log_counter = 0;                                      // used to slow down logging of PID values to dataflash
    // log output if PID loggins is on and we are tuning the yaw
    if( g.log_bitmask & MASK_LOG_PID && (g.radio_tuning == CH6_YAW_KP || g.radio_tuning == CH6_YAW_RATE_KP) ) {
        log_counter++;
        if( log_counter >= 10 ) {               // (update rate / desired output rate) = (100hz / 10hz) = 10
            log_counter = 0;
            Log_Write_PID(CH6_YAW_RATE_KP, rate_error, p, i, d, output, tuning_value);
        }
    }
#endif

#if FRAME_CONFIG == HELI_FRAME || FRAME_CONFIG == TRI_FRAME
    // constrain output
    return output;
#else
    // output control:
    int16_t yaw_limit = 2200 + abs(g.rc_4.control_in);

    // smoother Yaw control:
    return constrain(output, -yaw_limit, yaw_limit);
#endif

}

static int16_t
get_throttle_rate(int16_t z_target_speed)
{
    int32_t p,i,d;      // used to capture pid values for logging
    int16_t z_rate_error, output;

    // calculate rate error
#if INERTIAL_NAV == ENABLED
    z_rate_error    = z_target_speed - accels_velocity.z;                       // calc the speed error
#else
    z_rate_error    = z_target_speed - climb_rate;              // calc the speed error
#endif

    int32_t tmp     = (z_target_speed * z_target_speed * (int32_t)g.throttle_cruise) / 200000;

    if(z_target_speed < 0) tmp = -tmp;

    output                  = constrain(tmp, -3200, 3200);

    // separately calculate p, i, d values for logging
    p = g.pid_throttle.get_p(z_rate_error);
    // freeze I term if we've breached throttle limits
    if( motors.reached_limit(AP_MOTOR_THROTTLE_LIMIT) ) {
        i = g.pid_throttle.get_integrator();
    }else{
        i = g.pid_throttle.get_i(z_rate_error, .02);
    }
    d = g.pid_throttle.get_d(z_rate_error, .02);

    //
    // limit the rate
    output +=  constrain(p+i+d, -80, 120);

#if LOGGING_ENABLED == ENABLED
    static int8_t log_counter = 0;                                      // used to slow down logging of PID values to dataflash
    // log output if PID loggins is on and we are tuning the yaw
    if( g.log_bitmask & MASK_LOG_PID && g.radio_tuning == CH6_THROTTLE_KP ) {
        log_counter++;
        if( log_counter >= 10 ) {               // (update rate / desired output rate) = (50hz / 10hz) = 5hz
            log_counter = 0;
            Log_Write_PID(CH6_THROTTLE_KP, z_rate_error, p, i, d, output, tuning_value);
        }
    }
#endif

    return output;
}

// Keeps old data out of our calculation / logs
static void reset_nav_params(void)
{
    nav_throttle                    = 0;

    // always start Circle mode at same angle
    circle_angle                    = 0;

    // We must be heading to a new WP, so XTrack must be 0
    crosstrack_error                = 0;

    // Will be set by new command
    target_bearing                  = 0;

    // Will be set by new command
    wp_distance                     = 0;

    // Will be set by new command, used by loiter
    long_error                              = 0;
    lat_error                               = 0;

    // We want to by default pass WPs
    slow_wp = false;

    // make sure we stick to Nav yaw on takeoff
    auto_yaw = nav_yaw;

    // revert to smaller radius set in params
    waypoint_radius = g.waypoint_radius;
}

/*
 *  reset all I integrators
 */
static void reset_I_all(void)
{
    reset_rate_I();
    reset_stability_I();
    reset_wind_I();
    reset_throttle_I();
    reset_optflow_I();

    // This is the only place we reset Yaw
    g.pi_stabilize_yaw.reset_I();
}

static void reset_rate_I()
{
    g.pid_rate_roll.reset_I();
    g.pid_rate_pitch.reset_I();
    g.pid_rate_yaw.reset_I();
}

static void reset_optflow_I(void)
{
    g.pid_optflow_roll.reset_I();
    g.pid_optflow_pitch.reset_I();
    of_roll = 0;
    of_pitch = 0;
}

static void reset_wind_I(void)
{
    // Wind Compensation
    // this i is not currently being used, but we reset it anyway
    // because someone may modify it and not realize it, causing a bug
    g.pi_loiter_lat.reset_I();
    g.pi_loiter_lon.reset_I();

    g.pid_loiter_rate_lat.reset_I();
    g.pid_loiter_rate_lon.reset_I();

    g.pid_nav_lat.reset_I();
    g.pid_nav_lon.reset_I();
}

static void reset_throttle_I(void)
{
    // For Altitude Hold
    g.pi_alt_hold.reset_I();
    g.pid_throttle.reset_I();
}

static void reset_stability_I(void)
{
    // Used to balance a quad
    // This only needs to be reset during Auto-leveling in flight
    g.pi_stabilize_roll.reset_I();
    g.pi_stabilize_pitch.reset_I();
}


/*************************************************************
 *  throttle control
 ****************************************************************/

static int16_t get_angle_boost(int16_t value)
{
    float temp = cos_pitch_x * cos_roll_x;
    temp = constrain(temp, .75, 1.0);
    return ((float)(value + 80) / temp) - (value + 80);
}

#if FRAME_CONFIG == HELI_FRAME
// heli_angle_boost - adds a boost depending on roll/pitch values
// equivalent of quad's angle_boost function
// throttle value should be 0 ~ 1000
static int16_t heli_get_angle_boost(int16_t throttle)
{
    float angle_boost_factor = cos_pitch_x * cos_roll_x;
    angle_boost_factor = 1.0 - constrain(angle_boost_factor, .5, 1.0);
    int16_t throttle_above_mid = max(throttle - motors.throttle_mid,0);
    return throttle + throttle_above_mid*angle_boost_factor;

}
#endif // HELI_FRAME

#define NUM_G_SAMPLES 40

#if ACCEL_ALT_HOLD == 2
// z -14.4306 = going up
// z -6.4306 = going down
static int16_t get_z_damping()
{
    int16_t output;

    Z_integrator    += get_world_Z_accel() - Z_offset;
    output                  = Z_integrator * 3;
    Z_integrator    = Z_integrator * .8;
    output = constrain(output, -100, 100);
    return output;
}

float get_world_Z_accel()
{
    accels_rot = ahrs.get_dcm_matrix() * imu.get_accel();
    //Serial.printf("z %1.4f\n", accels_rot.z);
    return accels_rot.z;
}

static void init_z_damper()
{
    Z_offset = 0;
    for (int16_t i = 0; i < NUM_G_SAMPLES; i++) {
        delay(5);
        read_AHRS();
        Z_offset += get_world_Z_accel();
    }
    Z_offset /= (float)NUM_G_SAMPLES;
}




// Accelerometer Z dampening by Aurelio R. Ramos
// ---------------------------------------------
#elif ACCEL_ALT_HOLD == 1

// contains G and any other DC offset
static float estimatedAccelOffset = 0;

// state
static float synVelo = 0;
static float synPos = 0;
static float synPosFiltered = 0;
static float posError = 0;
static float prevSensedPos = 0;

// tuning for dead reckoning
static const float dt_50hz = 0.02;
static float synPosP = 10 * dt_50hz;
static float synPosI = 15 * dt_50hz;
static float synVeloP = 1.5 * dt_50hz;
static float maxVeloCorrection = 5 * dt_50hz;
static float maxSensedVelo = 1;
static float synPosFilter = 0.5;


// Z damping term.
static float fullDampP = 0.100;

float get_world_Z_accel()
{
    accels_rot = ahrs.get_dcm_matrix() * imu.get_accel();
    return accels_rot.z;
}

static void init_z_damper()
{
    estimatedAccelOffset = 0;
    for (int16_t i = 0; i < NUM_G_SAMPLES; i++) {
        delay(5);
        read_AHRS();
        estimatedAccelOffset += get_world_Z_accel();
    }
    estimatedAccelOffset /= (float)NUM_G_SAMPLES;
}

float dead_reckon_Z(float sensedPos, float sensedAccel)
{
    // the following algorithm synthesizes position and velocity from
    // a noisy altitude and accelerometer data.

    // synthesize uncorrected velocity by integrating acceleration
    synVelo += (sensedAccel - estimatedAccelOffset) * dt_50hz;

    // synthesize uncorrected position by integrating uncorrected velocity
    synPos += synVelo * dt_50hz;

    // filter synPos, the better this filter matches the filtering and dead time
    // of the sensed position, the less the position estimate will lag.
    synPosFiltered = synPosFiltered * (1 - synPosFilter) + synPos * synPosFilter;

    // calculate error against sensor position
    posError = sensedPos - synPosFiltered;

    // correct altitude
    synPos += synPosP * posError;

    // correct integrated velocity by posError
    synVelo = synVelo + constrain(posError, -maxVeloCorrection, maxVeloCorrection) * synPosI;

    // correct integrated velocity by the sensed position delta in a small proportion
    // (i.e., the low frequency of the delta)
    float sensedVelo = (sensedPos - prevSensedPos) / dt_50hz;
    synVelo += constrain(sensedVelo - synVelo, -maxSensedVelo, maxSensedVelo) * synVeloP;

    prevSensedPos = sensedPos;
    return synVelo;
}

static int16_t get_z_damping()
{
    float sensedAccel = get_world_Z_accel();
    float sensedPos = current_loc.alt / 100.0;

    float synVelo = dead_reckon_Z(sensedPos, sensedAccel);
    return constrain(fullDampP * synVelo * (-1), -300, 300);
}

#else

static int16_t get_z_damping()
{
    return 0;
}

static void init_z_damper()
{
}
#endif

// calculate modified roll/pitch depending upon optical flow calculated position
static int32_t
get_of_roll(int32_t input_roll)
{
#ifdef OPTFLOW_ENABLED
    static float tot_x_cm = 0;      // total distance from target
    static uint32_t last_of_roll_update = 0;
    int32_t new_roll = 0;
    int32_t p,i,d;

    // check if new optflow data available
    if( optflow.last_update != last_of_roll_update) {
        last_of_roll_update = optflow.last_update;

        // add new distance moved
        tot_x_cm += optflow.x_cm;

        // only stop roll if caller isn't modifying roll
        if( input_roll == 0 && current_loc.alt < 1500) {
            p = g.pid_optflow_roll.get_p(-tot_x_cm);
            i = g.pid_optflow_roll.get_i(-tot_x_cm,1.0);              // we could use the last update time to calculate the time change
            d = g.pid_optflow_roll.get_d(-tot_x_cm,1.0);
            new_roll = p+i+d;
        }else{
            g.pid_optflow_roll.reset_I();
            tot_x_cm = 0;
            p = 0;              // for logging
            i = 0;
            d = 0;
        }
        // limit amount of change and maximum angle
        of_roll = constrain(new_roll, (of_roll-20), (of_roll+20));

 #if LOGGING_ENABLED == ENABLED
        static int8_t log_counter = 0;                                  // used to slow down logging of PID values to dataflash
        // log output if PID logging is on and we are tuning the rate P, I or D gains
        if( g.log_bitmask & MASK_LOG_PID && (g.radio_tuning == CH6_OPTFLOW_KP || g.radio_tuning == CH6_OPTFLOW_KI || g.radio_tuning == CH6_OPTFLOW_KD) ) {
            log_counter++;
            if( log_counter >= 5 ) {                    // (update rate / desired output rate) = (100hz / 10hz) = 10
                log_counter = 0;
                Log_Write_PID(CH6_OPTFLOW_KP, tot_x_cm, p, i, d, of_roll, tuning_value);
            }
        }
 #endif // LOGGING_ENABLED == ENABLED
    }

    // limit max angle
    of_roll = constrain(of_roll, -1000, 1000);

    return input_roll+of_roll;
#else
    return input_roll;
#endif
}

static int32_t
get_of_pitch(int32_t input_pitch)
{
#ifdef OPTFLOW_ENABLED
    static float tot_y_cm = 0;  // total distance from target
    static uint32_t last_of_pitch_update = 0;
    int32_t new_pitch = 0;
    int32_t p,i,d;

    // check if new optflow data available
    if( optflow.last_update != last_of_pitch_update ) {
        last_of_pitch_update = optflow.last_update;

        // add new distance moved
        tot_y_cm += optflow.y_cm;

        // only stop roll if caller isn't modifying pitch
        if( input_pitch == 0 && current_loc.alt < 1500 ) {
            p = g.pid_optflow_pitch.get_p(tot_y_cm);
            i = g.pid_optflow_pitch.get_i(tot_y_cm, 1.0);              // we could use the last update time to calculate the time change
            d = g.pid_optflow_pitch.get_d(tot_y_cm, 1.0);
            new_pitch = p + i + d;
        }else{
            tot_y_cm = 0;
            g.pid_optflow_pitch.reset_I();
            p = 0;              // for logging
            i = 0;
            d = 0;
        }

        // limit amount of change
        of_pitch = constrain(new_pitch, (of_pitch-20), (of_pitch+20));

 #if LOGGING_ENABLED == ENABLED
        static int8_t log_counter = 0;                                  // used to slow down logging of PID values to dataflash
        // log output if PID logging is on and we are tuning the rate P, I or D gains
        if( g.log_bitmask & MASK_LOG_PID && (g.radio_tuning == CH6_OPTFLOW_KP || g.radio_tuning == CH6_OPTFLOW_KI || g.radio_tuning == CH6_OPTFLOW_KD) ) {
            log_counter++;
            if( log_counter >= 5 ) {                    // (update rate / desired output rate) = (100hz / 10hz) = 10
                log_counter = 0;
                Log_Write_PID(CH6_OPTFLOW_KP+100, tot_y_cm, p, i, d, of_pitch, tuning_value);
            }
        }
 #endif // LOGGING_ENABLED == ENABLED
    }

    // limit max angle
    of_pitch = constrain(of_pitch, -1000, 1000);

    return input_pitch+of_pitch;
#else
    return input_pitch;
#endif
}
set(CMAKE_TOOLCHAIN_FILE ../cmake/ArduinoToolchain.cmake) # Arduino Toolchain

cmake_minimum_required(VERSION 2.8)

project(ArduCopter C CXX)

set(PROJECT_VERSION_MAJOR "2")
set(PROJECT_VERSION_MINOR "6")
set(PROJECT_VERSION_PATCH "0")

set(PROJECT_DESCRIPTION "ArduPilotMega based Rotor-craft Autopilot.")

# macro path
list(APPEND CMAKE_MODULE_PATH "${CMAKE_SOURCE_DIR}/../cmake/modules")
include(CMakeParseArguments)
include(APMOption)

# options
include(options.cmake)
include_directories(${CMAKE_BINARY_DIR})
add_definitions(-DUSE_CMAKE_APM_CONFIG)
apm_option_generate_config(FILE "APM_Config_cmake.h" BUILD_FLAGS APM_BUILD_FLAGS)
add_definitions(${APM_BUILD_FLAGS})
message(STATUS "build flags: ${APM_BUILD_FLAGS}")
#configure_file(APM_Config2.h.cmake APM_Config2.h)

# disallow in-source build
include(MacroEnsureOutOfSourceBuild)
macro_ensure_out_of_source_build("${PROJECT_NAME} requires an out of source build.
Please create a separate build directory and run 'cmake /path/to/${PROJECT_NAME} [options]' there.")

# built variables
set(PROJECT_VERSION "${PROJECT_VERSION_MAJOR}.${PROJECT_VERSION_MINOR}.${PROJECT_VERSION_PATCH}")
set(FIRMWARE_NAME "${PROJECT_NAME}-${CONFIG_APM_HARDWARE}-${APM_PROCESSOR}-${HIL_MODE}")

# modify flags from default toolchain flags
set(APM_OPT_FLAGS "-Wformat -Wall -Wshadow -Wpointer-arith -Wcast-align -Wwrite-strings -Wformat=2")
set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${APM_OPT_FLAGS}")
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${APM_OPT_FLAGS} -Wno-reorder")
set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} ${APM_OPT_FLAGS} -Wl,--relax")

# build apm project
set(ARDUINO_EXTRA_LIBRARIES_PATH ${CMAKE_SOURCE_DIR}/../libraries)
set(${FIRMWARE_NAME}_SKETCH ${CMAKE_SOURCE_DIR}/../${PROJECT_NAME})
set(${FIRMWARE_NAME}_BOARD ${APM_PROCESSOR})
set(${FIRMWARE_NAME}_PORT ${APM_PROGRAMMING_PORT})
generate_arduino_firmware(${FIRMWARE_NAME})
install(FILES ${CMAKE_BINARY_DIR}/${FIRMWARE_NAME}.hex DESTINATION "/")

# cpack
include(APMCPackConfig)
ArduPilotMega 2.0 Commands

Command Structure in bytes
0 0x00	byte	Command ID
1 0x01	byte	Parameter 1
2 0x02	long	Parameter 2
3 0x03	..
4 0x04	..
5 0x05	..
6 0x06	long	Parameter 3
7 0x07	..
8 0x08	..
9 0x09	..
10 0x0A	long	Parameter 4
11 0x0B	..
11 0x0C	..
11 0x0D	..


***********************************
Commands below MAV_CMD_NAV_LAST are commands that have a end criteria, eg "reached waypoint" or "reached altitude"
***********************************
Command ID	Name								Parameter 1			Altitude			Latitude			Longitude
0x10 / 16	MAV_CMD_NAV_WAYPOINT				delay (seconds)		altitude			lat					lon
0x11 / 17	MAV_CMD_NAV_LOITER_UNLIM 			(forever)			altitude			lat					lon

0x14 / 20	MAV_CMD_NAV_RETURN_TO_LAUNCH		-					-					-					-
0x15 / 21	MAV_CMD_NAV_LAND					-					-					-					-
0x16 / 22	MAV_CMD_NAV_TAKEOFF					-					altitude			-					-
0x19 / 22	MAV_CMD_NAV_LOITER_TIME				-					altitude			-					-

			NOTE:  for command 0x16 the value takeoff pitch specifies the minimum pitch for the case with airspeed sensor and the target pitch for the case without.


***********************************
May Commands - these commands are optional to finish
Command ID		Name								Parameter 1			Parameter 2			Parameter 3			Parameter 4
0x70 / 112		MAV_CMD_CONDITION_DELAY				-					-					time (seconds) -
0x71 / 113		MAV_CMD_CONDITION_CHANGE_ALT 		rate (cm/sec)		alt (finish)		-					-
													Note: rate must be > 10 cm/sec due to integer math

//	MAV_CMD_NAV_LAND_OPTIONS			(NOT CURRENTLY IN MAVLINK PROTOCOL OR IMPLEMENTED IN APM)

0x72 / 114		MAV_CMD_CONDITION_DISTANCE			-					-					distance (meters)	-
0x71 / 115		MAV_CMD_CONDITION_YAW				angle				speed				direction (-1,1)	rel (1), abs (0)

***********************************
Unexecuted commands > MAV_CMD_NAV_LAST are dropped when ready for the next command < MAV_CMD_NAV_LAST so plan/queue commands accordingly!
For example if you had a string of CMD_MAV_CONDITION commands following a 0x10 command that had not finished when the waypoint was
reached, the unexecuted CMD_MAV_CONDITION and CMD_MAV_DO commands would be skipped and the next command < MAV_CMD_NAV_LAST would be loaded
***********************************
Now Commands - these commands are executed once until no more new now commands are available

Command ID		Name						Parameter 1			Parameter 2			Parameter 3			Parameter 4
0xB1 / 177		MAV_CMD_DO_JUMP				index				-					repeat count		-
				Note:  The repeat count must be greater than 1 for the command to execute.  Use a repeat count of 1 if you intend a single use.

0XB2 / 178		MAV_CMD_DO_CHANGE_SPEED 	Speed type			Speed (m/s)			Throttle (Percent)	-
								(0=Airspeed, 1=Ground Speed)	(-1 indicates no change)(-1 indicates no change)

0xB3 / 179		MAV_CMD_DO_SET_HOME			Use current 		altitude			lat					lon
								(1=use current location, 0=use specified location)

0xB4 / 180		MAV_CMD_DO_SET_PARAMETER	Param number		Param value			(NOT CURRENTLY IMPLEMENTED IN APM)
0xB5 / 181		MAV_CMD_DO_SET_RELAY		Relay number		On/off  (1/0)		-					-
0xB6 / 182		MAV_CMD_DO_REPEAT_RELAY		Relay number		Cycle count			Cycle time (sec)	-
				Note:  Max cycle time = 60 sec, A repeat relay or repeat servo command will cancel any current repeating event

0xB7 / 183		MAV_CMD_DO_SET_SERVO		Servo number (5-8)	On/off  (1/0)		-					-
0xB6 / 184		MAV_CMD_DO_REPEAT_SERVO		Servo number (5-8)	Cycle count			Cycle time (sec)	-
				Note:  Max cycle time = 60 sec, A repeat relay or repeat servo command will cancel any current repeating event

// need to add command
0xB7 / 201		MAV_CMD_DO_SET_ROI			Yaw_Mode			altitude			lat					lon
/// -*- tab-width: 4; Mode: C++; c-basic-offset: 4; indent-tabs-mode: nil -*-

/********************************************************************************/
// Command Event Handlers
/********************************************************************************/
static void process_nav_command()
{
    switch(command_nav_queue.id) {

    case MAV_CMD_NAV_TAKEOFF:                   // 22
        do_takeoff();
        break;

    case MAV_CMD_NAV_WAYPOINT:                  // 16  Navigate to Waypoint
        do_nav_wp();
        break;

    case MAV_CMD_NAV_LAND:              // 21 LAND to Waypoint
        yaw_mode                = YAW_HOLD;
        do_land();
        break;

    case MAV_CMD_NAV_LOITER_UNLIM:              // 17 Loiter indefinitely
        do_loiter_unlimited();
        break;

    case MAV_CMD_NAV_LOITER_TURNS:              //18 Loiter N Times
        do_loiter_turns();
        break;

    case MAV_CMD_NAV_LOITER_TIME:              // 19
        do_loiter_time();
        break;

    case MAV_CMD_NAV_RETURN_TO_LAUNCH:             //20
        do_RTL();
        break;

    // point the copter and camera at a region of interest (ROI)
    case MAV_CMD_NAV_ROI:             // 80
        do_nav_roi();
        break;

    default:
        break;
    }

}

static void process_cond_command()
{
    switch(command_cond_queue.id) {

    case MAV_CMD_CONDITION_DELAY:             // 112
        do_wait_delay();
        break;

    case MAV_CMD_CONDITION_DISTANCE:             // 114
        do_within_distance();
        break;

    case MAV_CMD_CONDITION_CHANGE_ALT:             // 113
        do_change_alt();
        break;

    case MAV_CMD_CONDITION_YAW:             // 115
        do_yaw();
        break;

    default:
        break;
    }
}

static void process_now_command()
{
    switch(command_cond_queue.id) {

    case MAV_CMD_DO_JUMP:              // 177
        do_jump();
        break;

    case MAV_CMD_DO_CHANGE_SPEED:             // 178
        do_change_speed();
        break;

    case MAV_CMD_DO_SET_HOME:             // 179
        do_set_home();
        break;

    case MAV_CMD_DO_SET_SERVO:             // 183
        do_set_servo();
        break;

    case MAV_CMD_DO_SET_RELAY:             // 181
        do_set_relay();
        break;

    case MAV_CMD_DO_REPEAT_SERVO:             // 184
        do_repeat_servo();
        break;

    case MAV_CMD_DO_REPEAT_RELAY:             // 182
        do_repeat_relay();
        break;

#if CAMERA == ENABLED
    case MAV_CMD_DO_CONTROL_VIDEO:                      // Control on-board camera capturing. |Camera ID (-1 for all)| Transmission: 0: disabled, 1: enabled compressed, 2: enabled raw| Transmission mode: 0: video stream, >0: single images every n seconds (decimal)| Recording: 0: disabled, 1: enabled compressed, 2: enabled raw| Empty| Empty| Empty|
        break;

    case MAV_CMD_DO_DIGICAM_CONFIGURE:                  // Mission command to configure an on-board camera controller system. |Modes: P, TV, AV, M, Etc| Shutter speed: Divisor number for one second| Aperture: F stop number| ISO number e.g. 80, 100, 200, Etc| Exposure type enumerator| Command Identity| Main engine cut-off time before camera trigger in seconds/10 (0 means no cut-off)|
        break;

    case MAV_CMD_DO_DIGICAM_CONTROL:                    // Mission command to control an on-board camera controller system. |Session control e.g. show/hide lens| Zoom's absolute position| Zooming step value to offset zoom from the current position| Focus Locking, Unlocking or Re-locking| Shooting Command| Command Identity| Empty|
        break;
#endif

#if MOUNT == ENABLED
    case MAV_CMD_DO_MOUNT_CONFIGURE:                    // Mission command to configure a camera mount |Mount operation mode (see MAV_CONFIGURE_MOUNT_MODE enum)| stabilize roll? (1 = yes, 0 = no)| stabilize pitch? (1 = yes, 0 = no)| stabilize yaw? (1 = yes, 0 = no)| Empty| Empty| Empty|
        camera_mount.configure_cmd();
        break;

    case MAV_CMD_DO_MOUNT_CONTROL:                      // Mission command to control a camera mount |pitch(deg*100) or lat, depending on mount mode.| roll(deg*100) or lon depending on mount mode| yaw(deg*100) or alt (in cm) depending on mount mode| Empty| Empty| Empty| Empty|
        camera_mount.control_cmd();
        break;
#endif

    default:
        // do nothing with unrecognized MAVLink messages
        break;
    }
}

/********************************************************************************/
// Verify command Handlers
/********************************************************************************/

static bool verify_must()
{
    switch(command_nav_queue.id) {

    case MAV_CMD_NAV_TAKEOFF:
        return verify_takeoff();
        break;

    case MAV_CMD_NAV_WAYPOINT:
        return verify_nav_wp();
        break;

    case MAV_CMD_NAV_LAND:
        if(g.sonar_enabled == true) {
            return verify_land_sonar();
        }else{
            return verify_land_baro();
        }
        break;

    case MAV_CMD_NAV_LOITER_UNLIM:
        return verify_loiter_unlimited();
        break;

    case MAV_CMD_NAV_LOITER_TURNS:
        return verify_loiter_turns();
        break;

    case MAV_CMD_NAV_LOITER_TIME:
        return verify_loiter_time();
        break;

    case MAV_CMD_NAV_RETURN_TO_LAUNCH:
        return verify_RTL();
        break;

    case MAV_CMD_NAV_ROI:             // 80
        return verify_nav_roi();
        break;

    default:
        //gcs_send_text_P(SEVERITY_HIGH,PSTR("<verify_must: default> No current Must commands"));
        return false;
        break;
    }
}

static bool verify_may()
{
    switch(command_cond_queue.id) {

    case MAV_CMD_CONDITION_DELAY:
        return verify_wait_delay();
        break;

    case MAV_CMD_CONDITION_DISTANCE:
        return verify_within_distance();
        break;

    case MAV_CMD_CONDITION_CHANGE_ALT:
        return verify_change_alt();
        break;

    case MAV_CMD_CONDITION_YAW:
        return verify_yaw();
        break;

    default:
        //gcs_send_text_P(SEVERITY_HIGH,PSTR("<verify_must: default> No current May commands"));
        return false;
        break;
    }
}

/********************************************************************************/
//
/********************************************************************************/

static void do_RTL(void)
{
    // TODO: Altitude option from mission planner
    Location temp   = home;
    temp.alt                = get_RTL_alt();

    //so we know where we are navigating from
    // --------------------------------------
    next_WP                 = current_loc;

    // Loads WP from Memory
    // --------------------
    set_next_WP(&temp);


    // We want to come home and stop on a dime
    slow_wp = true;

    // output control mode to the ground station
    // -----------------------------------------
    gcs_send_message(MSG_HEARTBEAT);
}

/********************************************************************************/
//	Nav (Must) commands
/********************************************************************************/

static void do_takeoff()
{
    wp_control = LOITER_MODE;

    // Start with current location
    Location temp = current_loc;

    // alt is always relative
    temp.alt = command_nav_queue.alt;

    // prevent flips
    reset_I_all();

    // Set our waypoint
    set_next_WP(&temp);
}

static void do_nav_wp()
{
    wp_control = WP_MODE;
    slow_wp = false;

    set_next_WP(&command_nav_queue);

    // this is our bitmask to verify we have met all conditions to move on
    wp_verify_byte  = 0;

    // this will be used to remember the time in millis after we reach or pass the WP.
    loiter_time     = 0;

    // this is the delay, stored in seconds and expanded to millis
    loiter_time_max = command_nav_queue.p1 * 1000;

    if((next_WP.options & WP_OPTION_ALT_REQUIRED) == false) {
        wp_verify_byte |= NAV_ALTITUDE;
    }
}

static void do_land()
{
    wp_control = LOITER_MODE;

    // just to make sure
    land_complete           = false;

    // landing boost lowers the main throttle to mimmick
    // the effect of a user's hand
    landing_boost           = 0;

    // A counter that goes up if our climb rate stalls out.
    ground_detector         = 0;

    // hold at our current location
    set_next_WP(&current_loc);

    // Set a new target altitude
    set_new_altitude(0);
}

static void do_loiter_unlimited()
{
    wp_control = LOITER_MODE;

    //Serial.println("dloi ");
    if(command_nav_queue.lat == 0) {
        set_next_WP(&current_loc);
        wp_control = LOITER_MODE;
    }else{
        set_next_WP(&command_nav_queue);
        wp_control = WP_MODE;
    }
}

static void do_loiter_turns()
{
    wp_control = CIRCLE_MODE;

    if(command_nav_queue.lat == 0) {
        // allow user to specify just the altitude
        if(command_nav_queue.alt > 0) {
            current_loc.alt = command_nav_queue.alt;
        }
        set_next_WP(&current_loc);
    }else{
        set_next_WP(&command_nav_queue);
    }

    circle_WP = next_WP;

    loiter_total = command_nav_queue.p1 * 360;
    loiter_sum       = 0;
    old_target_bearing = target_bearing;

    circle_angle = target_bearing + 18000;
    circle_angle = wrap_360(circle_angle);
    circle_angle *= RADX100;
}

static void do_loiter_time()
{
    if(command_nav_queue.lat == 0) {
        wp_control              = LOITER_MODE;
        loiter_time     = millis();
        set_next_WP(&current_loc);
    }else{
        wp_control              = WP_MODE;
        set_next_WP(&command_nav_queue);
    }

    loiter_time_max = command_nav_queue.p1 * 1000;     // units are (seconds)
}

/********************************************************************************/
//	Verify Nav (Must) commands
/********************************************************************************/

static bool verify_takeoff()
{
    // wait until we are ready!
    if(g.rc_3.control_in == 0) {
        return false;
    }
    // are we above our target altitude?
    return (current_loc.alt > next_WP.alt);
}

// called at 10hz
static bool verify_land_sonar()
{
    if(current_loc.alt > 300) {
        wp_control = LOITER_MODE;
        ground_detector = 0;
    }else{
        // begin to pull down on the throttle
        landing_boost++;
        landing_boost = min(landing_boost, 40);
    }

    if(current_loc.alt < 200 ) {
        wp_control      = NO_NAV_MODE;
    }

    if(current_loc.alt < 150 ) {
        // if we are low or don't seem to be decending much, increment ground detector
        if(current_loc.alt < 80 || abs(climb_rate) < 20) {
            landing_boost++;              // reduce the throttle at twice the normal rate

            if(ground_detector < 30) {
                ground_detector++;
            }else if (ground_detector == 30) {
                land_complete = true;
                if(g.rc_3.control_in == 0) {
                    ground_detector++;
                    init_disarm_motors();
                }
                return true;
            }
        }
    }
    return false;
}

static bool verify_land_baro()
{
    if(current_loc.alt > 300) {
        wp_control = LOITER_MODE;
        ground_detector = 0;
    }else{
        // begin to pull down on the throttle
        landing_boost++;
        landing_boost = min(landing_boost, 40);
    }

    if(current_loc.alt < 100 ) {
        wp_control      = NO_NAV_MODE;
    }

    if(current_loc.alt < 200 ) {
        if(abs(climb_rate) < 40) {
            landing_boost++;

            if(ground_detector < 30) {
                ground_detector++;
            }else if (ground_detector == 30) {
                land_complete = true;
                if(g.rc_3.control_in == 0) {
                    ground_detector++;
                    init_disarm_motors();
                }
                return true;
            }
        }
    }
    return false;
}

static bool verify_nav_wp()
{
    // Altitude checking
    if(next_WP.options & WP_OPTION_ALT_REQUIRED) {
        // we desire a certain minimum altitude
        if(alt_change_flag == REACHED_ALT) {

            // we have reached that altitude
            wp_verify_byte |= NAV_ALTITUDE;
        }
    }

    // Did we pass the WP?	// Distance checking
    if((wp_distance <= (waypoint_radius * 100)) || check_missed_wp()) {

        // if we have a distance calc error, wp_distance may be less than 0
        if(wp_distance > 0) {
            wp_verify_byte |= NAV_LOCATION;

            if(loiter_time == 0) {
                loiter_time = millis();
            }
        }
    }

    // Hold at Waypoint checking, we cant move on until this is OK
    if(wp_verify_byte & NAV_LOCATION) {
        // we have reached our goal

        // loiter at the WP
        wp_control      = LOITER_MODE;

        if ((millis() - loiter_time) > loiter_time_max) {
            wp_verify_byte |= NAV_DELAY;
            //gcs_send_text_P(SEVERITY_LOW,PSTR("verify_must: LOITER time complete"));
            //Serial.println("vlt done");
        }
    }

    if(wp_verify_byte >= 7) {
        //if(wp_verify_byte & NAV_LOCATION){
        gcs_send_text_fmt(PSTR("Reached Command #%i"),command_nav_index);
        wp_verify_byte = 0;
        copter_leds_nav_blink = 15;             // Cause the CopterLEDs to blink three times to indicate waypoint reached
        return true;
    }else{
        return false;
    }
}

static bool verify_loiter_unlimited()
{
    if(wp_control == WP_MODE &&  wp_distance <= (g.waypoint_radius * 100)) {
        // switch to position hold
        wp_control      = LOITER_MODE;
    }
    return false;
}

static bool verify_loiter_time()
{
    if(wp_control == LOITER_MODE) {
        if ((millis() - loiter_time) > loiter_time_max) {
            return true;
        }
    }
    if(wp_control == WP_MODE &&  wp_distance <= (g.waypoint_radius * 100)) {
        // reset our loiter time
        loiter_time = millis();
        // switch to position hold
        wp_control      = LOITER_MODE;
    }
    return false;
}

static bool verify_loiter_turns()
{
    //Serial.printf("loiter_sum: %d \n", loiter_sum);
    // have we rotated around the center enough times?
    // -----------------------------------------------
    if(abs(loiter_sum) > loiter_total) {
        loiter_total    = 0;
        loiter_sum              = 0;
        //gcs_send_text_P(SEVERITY_LOW,PSTR("verify_must: LOITER orbits complete"));
        // clear the command queue;
        return true;
    }
    return false;
}

static bool verify_RTL()
{
    wp_control      = WP_MODE;

    // Did we pass the WP?	// Distance checking
    if((wp_distance <= (g.waypoint_radius * 100)) || check_missed_wp()) {
        wp_control      = LOITER_MODE;

        //gcs_send_text_P(SEVERITY_LOW,PSTR("Reached home"));
        return true;
    }else{
        return false;
    }
}

/********************************************************************************/
//	Condition (May) commands
/********************************************************************************/

static void do_wait_delay()
{
    //Serial.print("dwd ");
    condition_start = millis();
    condition_value = command_cond_queue.lat * 1000;     // convert to milliseconds
    //Serial.println(condition_value,DEC);
}

static void do_change_alt()
{
    Location temp   = next_WP;
    condition_start = current_loc.alt;
    //condition_value	= command_cond_queue.alt;
    temp.alt                = command_cond_queue.alt;
    set_next_WP(&temp);
}

static void do_within_distance()
{
    condition_value  = command_cond_queue.lat * 100;
}

static void do_yaw()
{
    //Serial.println("dyaw ");
    yaw_tracking = MAV_ROI_NONE;

    // target angle in degrees
    command_yaw_start               = nav_yaw;     // current position
    command_yaw_start_time  = millis();

    command_yaw_dir                 = command_cond_queue.p1;                            // 1 = clockwise,	 0 = counterclockwise
    command_yaw_speed               = command_cond_queue.lat * 100;             // ms * 100
    command_yaw_relative    = command_cond_queue.lng;                           // 1 = Relative,	 0 = Absolute

    // if unspecified turn at 30° per second
    if(command_yaw_speed == 0)
        command_yaw_speed = 3000;

    // ensure direction is valid, if invalid default to counter clockwise
    if(command_yaw_dir > 1)
        command_yaw_dir = 0;            // 0 = counter clockwise, 1 = clockwise

    if(command_yaw_relative == 1) {
        // relative
        command_yaw_delta       = command_cond_queue.alt * 100;
        if(command_yaw_dir == 0) {              // 0 = counter clockwise, 1 = clockwise
            command_yaw_end = command_yaw_start - command_yaw_delta;
        }else{
            command_yaw_end = command_yaw_start + command_yaw_delta;
        }
        command_yaw_end = wrap_360(command_yaw_end);
    }else{
        // absolute
        command_yaw_end         = command_cond_queue.alt * 100;

        // calculate the delta travel in deg * 100
        if(command_yaw_dir == 0) {              // 0 = counter clockwise, 1 = clockwise
            if(command_yaw_start > command_yaw_end) {
                command_yaw_delta = command_yaw_start - command_yaw_end;
            }else{
                command_yaw_delta = 36000 + (command_yaw_start - command_yaw_end);
            }
        }else{
            if(command_yaw_start >= command_yaw_end) {
                command_yaw_delta = 36000 - (command_yaw_start - command_yaw_end);
            }else{
                command_yaw_delta = command_yaw_end - command_yaw_start;
            }
        }
        command_yaw_delta = wrap_360(command_yaw_delta);
    }

    // rate to turn deg per second - default is ten
    command_yaw_time        = (command_yaw_delta / command_yaw_speed) * 1000;
}


/********************************************************************************/
// Verify Condition (May) commands
/********************************************************************************/

static bool verify_wait_delay()
{
    //Serial.print("vwd");
    if ((unsigned)(millis() - condition_start) > (unsigned)condition_value) {
        //Serial.println("y");
        condition_value = 0;
        return true;
    }
    //Serial.println("n");
    return false;
}

static bool verify_change_alt()
{
    //Serial.printf("change_alt, ca:%d, na:%d\n", (int)current_loc.alt, (int)next_WP.alt);
    if ((int32_t)condition_start < next_WP.alt) {
        // we are going higer
        if(current_loc.alt > next_WP.alt) {
            return true;
        }
    }else{
        // we are going lower
        if(current_loc.alt < next_WP.alt) {
            return true;
        }
    }
    return false;
}

static bool verify_within_distance()
{
    //Serial.printf("cond dist :%d\n", (int)condition_value);
    if (wp_distance < condition_value) {
        condition_value = 0;
        return true;
    }
    return false;
}

static bool verify_yaw()
{
    //Serial.printf("vyaw %d\n", (int)(nav_yaw/100));

    if((millis() - command_yaw_start_time) > command_yaw_time) {
        // time out
        // make sure we hold at the final desired yaw angle
        nav_yaw         = command_yaw_end;
        auto_yaw        = nav_yaw;

        // TO-DO: there's still a problem with Condition_yaw, it will do it two times(probably more) sometimes, if it hasn't reached the next waypoint yet.
        // it should only do it one time so there should be code here to prevent another Condition_Yaw.

        //Serial.println("Y");
        return true;

    }else{
        // else we need to be at a certain place
        // power is a ratio of the time : .5 = half done
        float power = (float)(millis() - command_yaw_start_time) / (float)command_yaw_time;

        if(command_yaw_dir == 0) {              // 0 = counter clockwise, 1 = clockwise
            nav_yaw         = command_yaw_start - ((float)command_yaw_delta * power );
        }else{
            nav_yaw         = command_yaw_start + ((float)command_yaw_delta * power );
        }
        nav_yaw         = wrap_360(nav_yaw);
        auto_yaw        = nav_yaw;
        //Serial.printf("ny %ld\n",nav_yaw);
        return false;
    }
}

// verify_nav_roi - verifies that actions required by MAV_CMD_NAV_ROI have completed
//              we assume the camera command has been successfully implemented by the do_nav_roi command
//              so all we need to check is whether we needed to yaw the copter (due to the mount type) and
//              whether that yaw has completed
//	TO-DO: add support for other features of MAV_NAV_ROI including pointing at a given waypoint
static bool verify_nav_roi()
{
#if MOUNT == ENABLED
    // check if mount type requires us to rotate the quad
    if( camera_mount.get_mount_type() != AP_Mount::k_pan_tilt && camera_mount.get_mount_type() != AP_Mount::k_pan_tilt_roll ) {
        // ensure yaw has gotten to within 2 degrees of the target
        if( labs(wrap_180(ahrs.yaw_sensor-auto_yaw)) <= 200 ) {
            nav_yaw = auto_yaw;                 // ensure target yaw for YAW_HOLD is our desired yaw
            return true;
        }else{
            return false;
        }
    }else{
        // if no rotation required, assume the camera instruction was implemented immediately
        return true;
    }
#else
    // if we have no camera mount simply check we've reached the desired yaw
    // ensure yaw has gotten to within 2 degrees of the target
    if( abs(wrap_180(ahrs.yaw_sensor-auto_yaw)) <= 200 ) {
        nav_yaw = auto_yaw;             // ensure target yaw for YAW_HOLD is our desired yaw
        return true;
    }else{
        return false;
    }
#endif
}

/********************************************************************************/
//	Do (Now) commands
/********************************************************************************/

static void do_change_speed()
{
    g.waypoint_speed_max = command_cond_queue.p1 * 100;
}

static void do_target_yaw()
{
    yaw_tracking = command_cond_queue.p1;

    if(yaw_tracking == MAV_ROI_LOCATION) {
        target_WP = command_cond_queue;
    }
}

static void do_loiter_at_location()
{
    next_WP = current_loc;
}

static void do_jump()
{
    // Used to track the state of the jump command in Mission scripting
    // -10 is a value that means the register is unused
    // when in use, it contains the current remaining jumps
    static int8_t jump = -10;                                                                   // used to track loops in jump command

    //Serial.printf("do Jump: %d\n", jump);

    if(jump == -10) {
        //Serial.printf("Fresh Jump\n");
        // we use a locally stored index for jump
        jump = command_cond_queue.lat;
    }
    //Serial.printf("Jumps left: %d\n",jump);

    if(jump > 0) {
        //Serial.printf("Do Jump to %d\n",command_cond_queue.p1);
        jump--;
        change_command(command_cond_queue.p1);

    } else if (jump == 0) {
        //Serial.printf("Did last jump\n");
        // we're done, move along
        jump = -11;

    } else if (jump == -1) {
        //Serial.printf("jumpForever\n");
        // repeat forever
        change_command(command_cond_queue.p1);
    }
}

static void do_set_home()
{
    if(command_cond_queue.p1 == 1) {
        init_home();
    } else {
        home.id         = MAV_CMD_NAV_WAYPOINT;
        home.lng        = command_cond_queue.lng;                                       // Lon * 10**7
        home.lat        = command_cond_queue.lat;                                       // Lat * 10**7
        home.alt        = 0;
        home_is_set = true;
    }
}

static void do_set_servo()
{
    APM_RC.OutputCh(command_cond_queue.p1 - 1, command_cond_queue.alt);
}

static void do_set_relay()
{
    if (command_cond_queue.p1 == 1) {
        relay.on();
    } else if (command_cond_queue.p1 == 0) {
        relay.off();
    }else{
        relay.toggle();
    }
}

static void do_repeat_servo()
{
    event_id = command_cond_queue.p1 - 1;

    if(command_cond_queue.p1 >= CH_5 + 1 && command_cond_queue.p1 <= CH_8 + 1) {

        event_timer             = 0;
        event_value             = command_cond_queue.alt;
        event_repeat    = command_cond_queue.lat * 2;
        event_delay             = command_cond_queue.lng * 500.0;         // /2 (half cycle time) * 1000 (convert to milliseconds)

        switch(command_cond_queue.p1) {
        case CH_5:
            event_undo_value = g.rc_5.radio_trim;
            break;
        case CH_6:
            event_undo_value = g.rc_6.radio_trim;
            break;
        case CH_7:
            event_undo_value = g.rc_7.radio_trim;
            break;
        case CH_8:
            event_undo_value = g.rc_8.radio_trim;
            break;
        }
        update_events();
    }
}

static void do_repeat_relay()
{
    event_id                = RELAY_TOGGLE;
    event_timer             = 0;
    event_delay             = command_cond_queue.lat * 500.0;     // /2 (half cycle time) * 1000 (convert to milliseconds)
    event_repeat    = command_cond_queue.alt * 2;
    update_events();
}

// do_nav_roi - starts actions required by MAV_CMD_NAV_ROI
//              this involves either moving the camera to point at the ROI (region of interest)
//              and possibly rotating the copter to point at the ROI if our mount type does not support a yaw feature
//				Note: the ROI should already be in the command_nav_queue global variable
//	TO-DO: add support for other features of MAV_NAV_ROI including pointing at a given waypoint
static void do_nav_roi()
{
#if MOUNT == ENABLED

    // check if mount type requires us to rotate the quad
    if( camera_mount.get_mount_type() != AP_Mount::k_pan_tilt && camera_mount.get_mount_type() != AP_Mount::k_pan_tilt_roll ) {
        yaw_tracking = MAV_ROI_LOCATION;
        target_WP = command_nav_queue;
        auto_yaw = get_bearing_cd(&current_loc, &target_WP);
    }
    // send the command to the camera mount
    camera_mount.set_roi_cmd(&command_nav_queue);

    // TO-DO: expand handling of the do_nav_roi to support all modes of the MAVLink.  Currently we only handle mode 4 (see below)
    //		0: do nothing
    //		1: point at next waypoint
    //		2: point at a waypoint taken from WP# parameter (2nd parameter?)
    //		3: point at a location given by alt, lon, lat parameters
    //		4: point at a target given a target id (can't be implmented)
#else
    // if we have no camera mount simply rotate the quad
    yaw_tracking = MAV_ROI_LOCATION;
    target_WP = command_nav_queue;
    auto_yaw = get_bearing_cd(&current_loc, &target_WP);
#endif
}
// -*- tab-width: 4; Mode: C++; c-basic-offset: 4; indent-tabs-mode: nil -*-

static void init_commands()
{
    g.command_index             = NO_COMMAND;
    command_nav_index               = NO_COMMAND;
    command_cond_index              = NO_COMMAND;
    prev_nav_index                  = NO_COMMAND;
    command_cond_queue.id   = NO_COMMAND;
    command_nav_queue.id    = NO_COMMAND;

    fast_corner                     = false;

    // default Yaw tracking
    yaw_tracking                    = MAV_ROI_WPNEXT;
}

// Getters
// -------
static struct Location get_cmd_with_index(int i)
{
    struct Location temp;

    // Find out proper location in memory by using the start_byte position + the index
    // --------------------------------------------------------------------------------
    if (i >= g.command_total) {
        // we do not have a valid command to load
        // return a WP with a "Blank" id
        temp.id = CMD_BLANK;

        // no reason to carry on
        return temp;

    }else{
        // we can load a command, we don't process it yet
        // read WP position
        int32_t mem = (WP_START_BYTE) + (i * WP_SIZE);

        temp.id = eeprom_read_byte((uint8_t*)mem);

        mem++;
        temp.options = eeprom_read_byte((uint8_t*)mem);

        mem++;
        temp.p1 = eeprom_read_byte((uint8_t*)mem);

        mem++;
        temp.alt = eeprom_read_dword((uint32_t*)mem);           // alt is stored in CM! Alt is stored relative!

        mem += 4;
        temp.lat = eeprom_read_dword((uint32_t*)mem);         // lat is stored in decimal * 10,000,000

        mem += 4;
        temp.lng = eeprom_read_dword((uint32_t*)mem);         // lon is stored in decimal * 10,000,000
    }

    // Add on home altitude if we are a nav command (or other command with altitude) and stored alt is relative
    //if((temp.id < MAV_CMD_NAV_LAST || temp.id == MAV_CMD_CONDITION_CHANGE_ALT) && temp.options & MASK_OPTIONS_RELATIVE_ALT){
    //temp.alt += home.alt;
    //}

    if(temp.options & WP_OPTION_RELATIVE) {
        // If were relative, just offset from home
        temp.lat        +=      home.lat;
        temp.lng        +=      home.lng;
    }

    return temp;
}

// Setters
// -------
static void set_cmd_with_index(struct Location temp, int i)
{

    i = constrain(i, 0, g.command_total.get());
    //Serial.printf("set_command: %d with id: %d\n", i, temp.id);

    // store home as 0 altitude!!!
    // Home is always a MAV_CMD_NAV_WAYPOINT (16)
    if (i == 0) {
        temp.alt = 0;
        temp.id = MAV_CMD_NAV_WAYPOINT;
    }

    uint32_t mem = WP_START_BYTE + (i * WP_SIZE);

    eeprom_write_byte((uint8_t *)   mem, temp.id);

    mem++;
    eeprom_write_byte((uint8_t *)   mem, temp.options);

    mem++;
    eeprom_write_byte((uint8_t *)   mem, temp.p1);

    mem++;
    eeprom_write_dword((uint32_t *) mem, temp.alt);     // Alt is stored in CM!

    mem += 4;
    eeprom_write_dword((uint32_t *) mem, temp.lat);     // Lat is stored in decimal degrees * 10^7

    mem += 4;
    eeprom_write_dword((uint32_t *) mem, temp.lng);     // Long is stored in decimal degrees * 10^7

    // Make sure our WP_total
    if(g.command_total < (i+1))
        g.command_total.set_and_save(i+1);
}

static int32_t get_RTL_alt()
{
    if(g.RTL_altitude <= 0) {
        return current_loc.alt;
    }else if (g.RTL_altitude < current_loc.alt) {
        return current_loc.alt;
    }else{
        return g.RTL_altitude;
    }
}


//********************************************************************************
// This function sets the waypoint and modes for Return to Launch
// It's not currently used
//********************************************************************************

/*
 *  This function sets the next waypoint command
 *  It precalculates all the necessary stuff.
 */

static void set_next_WP(struct Location *wp)
{
    //SendDebug("MSG <set_next_wp> wp_index: ");
    //SendDebugln(g.command_index, DEC);

    // copy the current WP into the OldWP slot
    // ---------------------------------------
    if (next_WP.lat == 0 || command_nav_index <= 1) {
        prev_WP = current_loc;
    }else{
        if (get_distance_cm(&filtered_loc, &next_WP) < 500)
            prev_WP = next_WP;
        else
            prev_WP = current_loc;
    }

    //Serial.printf("set_next_WP #%d, ", command_nav_index);
    //print_wp(&prev_WP, command_nav_index -1);

    // Load the next_WP slot
    // ---------------------
    next_WP = *wp;

    // used to control and limit the rate of climb
    // -------------------------------------------
    // We don't set next WP below 1m
    next_WP.alt = max(next_WP.alt, 100);

    // Save new altitude so we can track it for climb_rate
    set_new_altitude(next_WP.alt);

    // this is used to offset the shrinking longitude as we go towards the poles
    float rads                      = (fabs((float)next_WP.lat)/t7) * 0.0174532925;
    scaleLongDown           = cos(rads);
    scaleLongUp             = 1.0f/cos(rads);

    // this is handy for the groundstation
    // -----------------------------------
    wp_distance             = get_distance_cm(&filtered_loc, &next_WP);
    target_bearing          = get_bearing_cd(&prev_WP, &next_WP);

    // calc the location error:
    calc_location_error(&next_WP);

    // to check if we have missed the WP
    // ---------------------------------
    original_target_bearing = target_bearing;

    // reset speed governer
    // --------------------
    waypoint_speed_gov = g_gps->ground_speed;
}


// run this at setup on the ground
// -------------------------------
static void init_home()
{
    home_is_set = true;
    home.id         = MAV_CMD_NAV_WAYPOINT;
    home.lng        = g_gps->longitude;                                 // Lon * 10**7
    home.lat        = g_gps->latitude;                                  // Lat * 10**7
    home.alt        = 0;                                                        // Home is always 0

    // to point yaw towards home until we set it with Mavlink
    target_WP       = home;

    // Save Home to EEPROM
    // -------------------
    // no need to save this to EPROM
    set_cmd_with_index(home, 0);
    //print_wp(&home, 0);

    if (g.log_bitmask & MASK_LOG_CMD)
        Log_Write_Cmd(0, &home);

    // Save prev loc this makes the calcs look better before commands are loaded
    prev_WP = home;

    // Load home for a default guided_WP
    // -------------
    guided_WP = home;
    guided_WP.alt += g.RTL_altitude;
}



/// -*- tab-width: 4; Mode: C++; c-basic-offset: 4; indent-tabs-mode: nil -*-

// For changing active command mid-mission
//----------------------------------------
static void change_command(uint8_t cmd_index)
{
    //Serial.printf("change_command: %d\n",cmd_index );
    // limit range
    cmd_index = min(g.command_total - 1, cmd_index);

    // load command
    struct Location temp = get_cmd_with_index(cmd_index);

    //Serial.printf("loading cmd: %d with id:%d\n", cmd_index, temp.id);

    // verify it's a nav command
    if(temp.id > MAV_CMD_NAV_LAST) {
        //gcs_send_text_P(SEVERITY_LOW,PSTR("error: non-Nav cmd"));

    }else{
        // clear out command queue
        init_commands();

        // copy command to the queue
        command_nav_queue               = temp;
        command_nav_index               = cmd_index;
        execute_nav_command();
    }
}

// called by 10 Hz loop
// --------------------
static void update_commands()
{
    //Serial.printf("update_commands: %d\n",increment );
    // A: if we do not have any commands there is nothing to do
    // B: We have completed the mission, don't redo the mission
    // XXX debug
    //uint8_t tmp = g.command_index.get();
    //Serial.printf("command_index %u \n", tmp);

    if(g.command_total <= 1 || g.command_index >= 255)
        return;

    if(command_nav_queue.id == NO_COMMAND) {
        // Our queue is empty
        // fill command queue with a new command if available, or exit mission
        // -------------------------------------------------------------------

        // find next nav command
        int16_t tmp_index;

        if(command_nav_index < g.command_total) {

            // what is the next index for a nav command?
            tmp_index = find_next_nav_index(command_nav_index + 1);

            if(tmp_index == -1) {
                exit_mission();
                return;
            }else{
                command_nav_index = tmp_index;
                command_nav_queue = get_cmd_with_index(command_nav_index);
                execute_nav_command();
            }

            // try to load the next nav for better speed control
            // find_next_nav_index takes the next guess to start the search
            tmp_index = find_next_nav_index(command_nav_index + 1);

            // Fast corner management
            // ----------------------
            if(tmp_index == -1) {
                // there are no more commands left
            }else{
                // we have at least one more cmd left
                Location tmp_loc = get_cmd_with_index(tmp_index);

                if(tmp_loc.lat == 0) {
                    fast_corner = false;
                }else{
                    int32_t temp = get_bearing_cd(&next_WP, &tmp_loc) - original_target_bearing;
                    temp = wrap_180(temp);
                    fast_corner = labs(temp) < 6000;
                }
            }
        }else{
            // we are out of commands
            exit_mission();
            return;
        }
    }

    if(command_cond_queue.id == NO_COMMAND) {
        // Our queue is empty
        // fill command queue with a new command if available, or do nothing
        // -------------------------------------------------------------------

        // no nav commands completed yet
        if(prev_nav_index == NO_COMMAND)
            return;

        if(command_cond_index >= command_nav_index) {
            // don't process the fututre
            return;

        }else if(command_cond_index == NO_COMMAND) {
            // start from scratch
            // look at command after the most recent completed nav
            command_cond_index = prev_nav_index + 1;

        }else{
            // we've completed 1 cond, look at next command for another
            command_cond_index++;
        }

        if(command_cond_index < (g.command_total -2)) {
            // we're OK to load a new command (last command must be a nav command)
            command_cond_queue = get_cmd_with_index(command_cond_index);

            if(command_cond_queue.id > MAV_CMD_CONDITION_LAST) {
                // this is a do now command
                process_now_command();

                // clear command queue
                command_cond_queue.id = NO_COMMAND;

            }else if(command_cond_queue.id > MAV_CMD_NAV_LAST) {
                // this is a conditional command
                process_cond_command();

            }else{
                // this is a nav command, don't process
                // clear the command conditional queue and index
                prev_nav_index                  = NO_COMMAND;
                command_cond_index              = NO_COMMAND;
                command_cond_queue.id   = NO_COMMAND;
            }

        }
    }
}

static void execute_nav_command(void)
{
    // This is what we report to MAVLINK
    g.command_index = command_nav_index;

    // Save CMD to Log
    if(g.log_bitmask & MASK_LOG_CMD)
        Log_Write_Cmd(g.command_index, &command_nav_queue);

    // clear navigation prameters
    reset_nav_params();

    // Act on the new command
    process_nav_command();

    // clear May indexes to force loading of more commands
    // existing May commands are tossed.
    command_cond_index      = NO_COMMAND;
}

// called with GPS navigation update - not constantly
static void verify_commands(void)
{
    if(verify_must()) {
        //Serial.printf("verified must cmd %d\n" , command_nav_index);
        command_nav_queue.id    = NO_COMMAND;

        // store our most recent executed nav command
        prev_nav_index                  = command_nav_index;

        // Wipe existing conditionals
        command_cond_index              = NO_COMMAND;
        command_cond_queue.id   = NO_COMMAND;

    }else{
        //Serial.printf("verified must false %d\n" , command_nav_index);
    }

    if(verify_may()) {
        //Serial.printf("verified may cmd %d\n" , command_cond_index);
        command_cond_queue.id = NO_COMMAND;
    }
}

// Finds the next navgation command in EEPROM
static int16_t find_next_nav_index(int16_t search_index)
{
    Location tmp;
    while(search_index < g.command_total) {
        tmp = get_cmd_with_index(search_index);
        if(tmp.id <= MAV_CMD_NAV_LAST) {
            return search_index;
        }else{
            search_index++;
        }
    }
    return -1;
}

static void exit_mission()
{
    // we are out of commands
    g.command_index = 255;

    // if we are on the ground, enter stabilize, else Land
    if(land_complete == true) {
        // we will disarm the motors after landing.
    }else{
        // If the approach altitude is valid (above 1m), do approach, else land
        if(g.rtl_approach_alt == 0) {
            set_mode(LAND);
        }else{
            set_mode(LOITER);
            set_new_altitude(g.rtl_approach_alt);
        }
    }

}


#ifndef __ARDUCOPTER_CONFIG_MOTORS_H__
#define __ARDUCOPTER_CONFIG_MOTORS_H__

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
//
//  DO NOT EDIT this file to adjust your configuration.  Create your own
//  APM_Config.h and use APM_Config.h.example as a reference.
//
// WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
///
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//

#include "config.h"     // Parent Config File
#include "APM_Config.h" // User Overrides

#endif // __ARDUCOPTER_CONFIG_MOTORS_H__
// -*- tab-width: 4; Mode: C++; c-basic-offset: 4; indent-tabs-mode: nil -*-
//
#ifndef __ARDUCOPTER_CONFIG_H__
#define __ARDUCOPTER_CONFIG_H__
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
//
//  DO NOT EDIT this file to adjust your configuration.  Create your own
//  APM_Config.h and use APM_Config.h.example as a reference.
//
// WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
///
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//
// Default and automatic configuration details.
//
// Notes for maintainers:
//
// - Try to keep this file organised in the same order as APM_Config.h.example
//

#include "defines.h"

///
/// DO NOT EDIT THIS INCLUDE - if you want to make a local change, make that
/// change in your local copy of APM_Config.h.
///
#ifdef USE_CMAKE_APM_CONFIG
 #include "APM_Config_cmake.h"  // <== Prefer cmake config if it exists
#else
 #include "APM_Config.h" // <== THIS INCLUDE, DO NOT EDIT IT. EVER.
#endif


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
// HARDWARE CONFIGURATION AND CONNECTIONS
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// APM HARDWARE
//

#ifndef CONFIG_APM_HARDWARE
 # define CONFIG_APM_HARDWARE APM_HARDWARE_APM1
#endif

//////////////////////////////////////////////////////////////////////////////
// APM2 HARDWARE DEFAULTS
//

#if CONFIG_APM_HARDWARE == APM_HARDWARE_APM2
 # define CONFIG_IMU_TYPE   CONFIG_IMU_MPU6000
 # define CONFIG_PUSHBUTTON DISABLED
 # define CONFIG_RELAY      DISABLED
 # define MAG_ORIENTATION   AP_COMPASS_APM2_SHIELD
 # define CONFIG_SONAR_SOURCE SONAR_SOURCE_ANALOG_PIN
 # define MAGNETOMETER ENABLED
 # ifdef APM2_BETA_HARDWARE
  #  define CONFIG_BARO     AP_BARO_BMP085
 # else // APM2 Production Hardware (default)
  #  define CONFIG_BARO     AP_BARO_MS5611
 # endif
#endif

//////////////////////////////////////////////////////////////////////////////
// FRAME_CONFIG
//
#ifndef FRAME_CONFIG
 # define FRAME_CONFIG   QUAD_FRAME
#endif
#ifndef FRAME_ORIENTATION
 # define FRAME_ORIENTATION      X_FRAME
#endif
#ifndef TOY_EDF
 # define TOY_EDF        DISABLED
#endif
#ifndef TOY_MIXER
 # define TOY_MIXER      TOY_LINEAR_MIXER
#endif



//////////////////////////////////////////////////////////////////////////////
// IMU Selection
//
#ifndef CONFIG_IMU_TYPE
 # define CONFIG_IMU_TYPE CONFIG_IMU_OILPAN
#endif

#if CONFIG_IMU_TYPE == CONFIG_IMU_OILPAN
 # define NUM_IMU_SAMPLES_FOR_200HZ 5
 # define NUM_IMU_SAMPLES_FOR_100HZ 10
 # define NUM_IMU_SAMPLES_FOR_50HZ  20
#endif

#if CONFIG_IMU_TYPE == CONFIG_IMU_MPU6000
 # define NUM_IMU_SAMPLES_FOR_200HZ 1
 # define NUM_IMU_SAMPLES_FOR_100HZ 2
 # define NUM_IMU_SAMPLES_FOR_50HZ  4
#endif

//////////////////////////////////////////////////////////////////////////////
// ADC Enable - used to eliminate for systems which don't have ADC.
//
#ifndef CONFIG_ADC
 # if CONFIG_IMU_TYPE == CONFIG_IMU_OILPAN
  #   define CONFIG_ADC ENABLED
 # else
  #   define CONFIG_ADC DISABLED
 # endif
#endif

//////////////////////////////////////////////////////////////////////////////
// PWM control
// default RC speed in Hz
#ifndef RC_FAST_SPEED
 # if FRAME_CONFIG == HELI_FRAME
  #   define RC_FAST_SPEED 125
 # else
  #   define RC_FAST_SPEED 490
 # endif
#endif

////////////////////////////////////////////////////////
// LED and IO Pins
//
#if CONFIG_APM_HARDWARE == APM_HARDWARE_APM1
 # define A_LED_PIN        37
 # define B_LED_PIN        36
 # define C_LED_PIN        35
 # define LED_ON           HIGH
 # define LED_OFF          LOW
 # define SLIDE_SWITCH_PIN 40
 # define PUSHBUTTON_PIN   41
 # define USB_MUX_PIN      -1
 # define CLI_SLIDER_ENABLED DISABLED
 # define OPTFLOW_CS_PIN   34
 # define BATTERY_VOLT_PIN      0      // Battery voltage on A0
 # define BATTERY_CURR_PIN      1      // Battery current on A1
#elif CONFIG_APM_HARDWARE == APM_HARDWARE_APM2
 # define A_LED_PIN        27
 # define B_LED_PIN        26
 # define C_LED_PIN        25
 # define LED_ON           LOW
 # define LED_OFF          HIGH
 # define SLIDE_SWITCH_PIN (-1)
 # define PUSHBUTTON_PIN   (-1)
 # define CLI_SLIDER_ENABLED DISABLED
 # define USB_MUX_PIN      23
 # define OPTFLOW_CS_PIN   A3
 # define BATTERY_VOLT_PIN      1      // Battery voltage on A1
 # define BATTERY_CURR_PIN      2      // Battery current on A2
#endif

////////////////////////////////////////////////////////////////////////////////
// CopterLEDs
//

#ifndef COPTER_LEDS
 #define COPTER_LEDS ENABLED
#endif

#define COPTER_LED_ON           HIGH
#define COPTER_LED_OFF          LOW

#if CONFIG_APM_HARDWARE == APM_HARDWARE_APM2
 #define COPTER_LED_1 AN4       // Motor or Aux LED
 #define COPTER_LED_2 AN5       // Motor LED or Beeper
 #define COPTER_LED_3 AN6       // Motor or GPS LED
 #define COPTER_LED_4 AN7       // Motor LED
 #define COPTER_LED_5 AN8       // Motor LED
 #define COPTER_LED_6 AN9       // Motor LED
 #define COPTER_LED_7 AN10      // Motor LED
 #define COPTER_LED_8 AN11      // Motor LED
#elif CONFIG_APM_HARDWARE == APM_HARDWARE_APM1
 #define COPTER_LED_1 AN8       // Motor or Aux LED
 #define COPTER_LED_2 AN9       // Motor LED
 #define COPTER_LED_3 AN10      // Motor or GPS LED
 #define COPTER_LED_4 AN11      // Motor LED
 #define COPTER_LED_5 AN12      // Motor LED
 #define COPTER_LED_6 AN13      // Motor LED
 #define COPTER_LED_7 AN14      // Motor LED
 #define COPTER_LED_8 AN15      // Motor LED
#endif


//////////////////////////////////////////////////////////////////////////////
// Pushbutton & Relay
//

#ifndef CONFIG_PUSHBUTTON
 # define CONFIG_PUSHBUTTON ENABLED
#endif

#ifndef CONFIG_RELAY
 # define CONFIG_RELAY ENABLED
#endif

//////////////////////////////////////////////////////////////////////////////
// Barometer
//

#ifndef CONFIG_BARO
 # define CONFIG_BARO AP_BARO_BMP085
#endif

//////////////////////////////////////////////////////////////////////////////
// Sonar
//

#ifndef CONFIG_SONAR_SOURCE
 # define CONFIG_SONAR_SOURCE SONAR_SOURCE_ADC
#endif

#if CONFIG_SONAR_SOURCE == SONAR_SOURCE_ADC && CONFIG_ADC == DISABLED
 # warning Cannot use ADC for CONFIG_SONAR_SOURCE, becaude CONFIG_ADC is DISABLED
 # warning Defaulting CONFIG_SONAR_SOURCE to ANALOG_PIN
 # undef CONFIG_SONAR_SOURCE
 # define CONFIG_SONAR_SOURCE SONAR_SOURCE_ANALOG_PIN
#endif

#if CONFIG_SONAR_SOURCE == SONAR_SOURCE_ADC
 # ifndef CONFIG_SONAR_SOURCE_ADC_CHANNEL
  #  define CONFIG_SONAR_SOURCE_ADC_CHANNEL 7
 # endif
#elif CONFIG_SONAR_SOURCE == SONAR_SOURCE_ANALOG_PIN
 # ifndef CONFIG_SONAR_SOURCE_ANALOG_PIN
  #  define CONFIG_SONAR_SOURCE_ANALOG_PIN A0
 # endif
#else
 # warning Invalid value for CONFIG_SONAR_SOURCE, disabling sonar
 # undef SONAR_ENABLED
 # define SONAR_ENABLED DISABLED
#endif

#ifndef CONFIG_SONAR
 # define CONFIG_SONAR ENABLED
#endif

//////////////////////////////////////////////////////////////////////////////
// Channel Config (custom MOT channel mappings)
//

#ifndef CONFIG_CHANNELS
 # define CONFIG_CHANNELS CHANNEL_CONFIG_DEFAULT
#endif

//////////////////////////////////////////////////////////////////////////////
// Acrobatics
//

#ifndef CH7_OPTION
 # define CH7_OPTION             CH7_SAVE_WP
#endif


//////////////////////////////////////////////////////////////////////////////
// HIL_MODE                                 OPTIONAL

#ifndef HIL_MODE
 #define HIL_MODE        HIL_MODE_DISABLED
#endif

#if HIL_MODE != HIL_MODE_DISABLED       // we are in HIL mode

 # undef GPS_PROTOCOL
 # define GPS_PROTOCOL GPS_PROTOCOL_NONE

 #undef CONFIG_SONAR
 #define CONFIG_SONAR DISABLED
#endif


//////////////////////////////////////////////////////////////////////////////
// GPS_PROTOCOL
//
#ifndef GPS_PROTOCOL
 # define GPS_PROTOCOL           GPS_PROTOCOL_AUTO
#endif


#ifndef MAV_SYSTEM_ID
 # define MAV_SYSTEM_ID          1
#endif


//////////////////////////////////////////////////////////////////////////////
// Serial port speeds.
//
#ifndef SERIAL0_BAUD
 # define SERIAL0_BAUD                   115200
#endif
#ifndef SERIAL3_BAUD
 # define SERIAL3_BAUD                    57600
#endif


//////////////////////////////////////////////////////////////////////////////
// Battery monitoring
//
#ifndef BATTERY_EVENT
 # define BATTERY_EVENT                  DISABLED
#endif
#ifndef LOW_VOLTAGE
 # define LOW_VOLTAGE                    9.6
#endif
#ifndef VOLT_DIV_RATIO
 # define VOLT_DIV_RATIO                 3.56
#endif

#ifndef CURR_AMP_PER_VOLT
 # define CURR_AMP_PER_VOLT              27.32
#endif
#ifndef CURR_AMPS_OFFSET
 # define CURR_AMPS_OFFSET               0.0
#endif
#ifndef HIGH_DISCHARGE
 # define HIGH_DISCHARGE                 1760
#endif





//////////////////////////////////////////////////////////////////////////////
// INPUT_VOLTAGE
//
#ifndef INPUT_VOLTAGE
 # define INPUT_VOLTAGE                  5.0
#endif


//////////////////////////////////////////////////////////////////////////////
//  MAGNETOMETER
#ifndef MAGNETOMETER
 # define MAGNETOMETER                   ENABLED
#endif
#ifndef MAG_ORIENTATION
 # define MAG_ORIENTATION                AP_COMPASS_COMPONENTS_DOWN_PINS_FORWARD
#endif


//////////////////////////////////////////////////////////////////////////////
//  OPTICAL_FLOW
#if defined( __AVR_ATmega2560__ )       // determines if optical flow code is included
 #define OPTFLOW_ENABLED
#endif
#ifndef OPTFLOW                                 // sets global enabled/disabled flag for optflow (as seen in CLI)
 # define OPTFLOW                                DISABLED
#endif
#ifndef OPTFLOW_ORIENTATION
 # define OPTFLOW_ORIENTATION    AP_OPTICALFLOW_ADNS3080_PINS_FORWARD
#endif
#ifndef OPTFLOW_RESOLUTION
 # define OPTFLOW_RESOLUTION     ADNS3080_RESOLUTION_1600
#endif
#ifndef OPTFLOW_FOV
 # define OPTFLOW_FOV                    AP_OPTICALFLOW_ADNS3080_08_FOV
#endif
// optical flow based loiter PI values
#ifndef OPTFLOW_ROLL_P
 #define OPTFLOW_ROLL_P 2.5
#endif
#ifndef OPTFLOW_ROLL_I
 #define OPTFLOW_ROLL_I 0.5
#endif
#ifndef OPTFLOW_ROLL_D
 #define OPTFLOW_ROLL_D 0.12
#endif
#ifndef OPTFLOW_PITCH_P
 #define OPTFLOW_PITCH_P 2.5
#endif
#ifndef OPTFLOW_PITCH_I
 #define OPTFLOW_PITCH_I 0.5
#endif
#ifndef OPTFLOW_PITCH_D
 #define OPTFLOW_PITCH_D 0.12
#endif
#ifndef OPTFLOW_IMAX
 #define OPTFLOW_IMAX 1
#endif


//////////////////////////////////////////////////////////////////////////////
// RADIO CONFIGURATION
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// FLIGHT_MODE
//

#if !defined(FLIGHT_MODE_1)
 # define FLIGHT_MODE_1                  STABILIZE
#endif
#if !defined(FLIGHT_MODE_2)
 # define FLIGHT_MODE_2                  STABILIZE
#endif
#if !defined(FLIGHT_MODE_3)
 # define FLIGHT_MODE_3                  STABILIZE
#endif
#if !defined(FLIGHT_MODE_4)
 # define FLIGHT_MODE_4                  STABILIZE
#endif
#if !defined(FLIGHT_MODE_5)
 # define FLIGHT_MODE_5                  STABILIZE
#endif
#if !defined(FLIGHT_MODE_6)
 # define FLIGHT_MODE_6                  STABILIZE
#endif


//////////////////////////////////////////////////////////////////////////////
// THROTTLE_FAILSAFE
// THROTTLE_FS_VALUE
// THROTTLE_FAILSAFE_ACTION
//
#ifndef THROTTLE_FAILSAFE
 # define THROTTLE_FAILSAFE                      DISABLED
#endif
#ifndef THROTTE_FS_VALUE
 # define THROTTLE_FS_VALUE                      975
#endif
#ifndef THROTTLE_FAILSAFE_ACTION
 # define THROTTLE_FAILSAFE_ACTION       2
#endif
#ifndef MINIMUM_THROTTLE
 # define MINIMUM_THROTTLE       130
#endif
#ifndef MAXIMUM_THROTTLE
 # define MAXIMUM_THROTTLE       1000
#endif

#ifndef AUTO_LAND_TIME
 # define AUTO_LAND_TIME 5
#endif



//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
// STARTUP BEHAVIOUR
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// GROUND_START_DELAY
//
#ifndef GROUND_START_DELAY
 # define GROUND_START_DELAY             3
#endif

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
// FLIGHT AND NAVIGATION CONTROL
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Y6 Support

#ifndef TOP_BOTTOM_RATIO
 # define TOP_BOTTOM_RATIO       1.00
#endif


//////////////////////////////////////////////////////////////////////////////
// CAMERA TRIGGER AND CONTROL
//
#ifndef CAMERA
 # if defined( __AVR_ATmega1280__ )
  #  define CAMERA        DISABLED
 # else
  #  define CAMERA        ENABLED
 # endif
#endif

//////////////////////////////////////////////////////////////////////////////
// MOUNT (ANTENNA OR CAMERA)
//
#ifndef MOUNT
 # if defined( __AVR_ATmega1280__ )
  #  define MOUNT         DISABLED
 # else
  #  define MOUNT         ENABLED
 # endif
#endif

#ifndef MOUNT2
 # define MOUNT2         DISABLED
#endif

#if defined( __AVR_ATmega1280__ ) && (MOUNT == ENABLED || MOUNT2 == ENABLED)
 # warning "You choose to enable MOUNT on a small ATmega1280, CLI, CAMERA and AP_LIMITS will be disabled to free some space for it"

// The small ATmega1280 chip does not have enough memory for mount support
// so disable CLI, this will allow mount support and other improvements to fit.
// This should almost have no side effects, because the APM planner can now do a complete board setup.
 # define CLI_ENABLED DISABLED

// The small ATmega1280 chip does not have enough memory for mount support
// so disable AUTO GPS support, this will allow mount support and other improvements to fit.
// This should almost have no side effects, because the most users use MTK anyways.
// If the user defined a GPS protocol, than we will NOT overwrite it
 # if GPS_PROTOCOL == GPS_PROTOCOL_AUTO
  #  undef GPS_PROTOCOL
  #  define GPS_PROTOCOL GPS_PROTOCOL_MTK
 # endif

// To save some more space
 # undef CAMERA
 # define CAMERA         DISABLED
 # define AP_LIMITS      DISABLED

#endif


//////////////////////////////////////////////////////////////////////////////
// Attitude Control
//

// definitions for earth frame and body frame
// used to specify frame to rate controllers
#define EARTH_FRAME     0
#define BODY_FRAME      1

// Alt Hold Mode
#ifndef ALT_HOLD_YAW
 # define ALT_HOLD_YAW           YAW_HOLD
#endif

#ifndef ALT_HOLD_RP
 # define ALT_HOLD_RP            ROLL_PITCH_STABLE
#endif

#ifndef ALT_HOLD_THR
 # define ALT_HOLD_THR           THROTTLE_HOLD
#endif

// AUTO Mode
#ifndef AUTO_YAW
 # define AUTO_YAW                       YAW_AUTO
#endif

#ifndef AUTO_RP
 # define AUTO_RP                        ROLL_PITCH_AUTO
#endif

#ifndef AUTO_THR
 # define AUTO_THR                       THROTTLE_AUTO
#endif

// CIRCLE Mode
#ifndef CIRCLE_YAW
 # define CIRCLE_YAW             YAW_AUTO
#endif

#ifndef CIRCLE_RP
 # define CIRCLE_RP                      ROLL_PITCH_AUTO
#endif

#ifndef CIRCLE_THR
 # define CIRCLE_THR                     THROTTLE_HOLD
#endif

// LOITER Mode
#ifndef LOITER_YAW
 # define LOITER_YAW             YAW_HOLD
#endif

#ifndef LOITER_RP
 # define LOITER_RP                      ROLL_PITCH_AUTO
#endif

#ifndef LOITER_THR
 # define LOITER_THR                     THROTTLE_HOLD
#endif


// RTL Mode
#ifndef RTL_YAW
 #if FRAME_CONFIG == HELI_FRAME
  # define RTL_YAW                    	  YAW_LOOK_AT_HOME
 #else
  # define RTL_YAW                        YAW_HOLD
 #endif
#endif

#ifndef RTL_RP
 # define RTL_RP                         ROLL_PITCH_AUTO
#endif

#ifndef RTL_THR
 # define RTL_THR                        THROTTLE_HOLD
#endif

#ifndef SUPER_SIMPLE
 # define SUPER_SIMPLE           DISABLED
#endif

#ifndef SUPER_SIMPLE_RADIUS
 # define SUPER_SIMPLE_RADIUS    1000
#endif

// RTL Mode
#ifndef RTL_APPROACH_ALT
 # define RTL_APPROACH_ALT       200 // cm!!!
#endif

#ifndef RTL_HOLD_ALT
 # define RTL_HOLD_ALT 1500             // height to return to Home in CM, 0 = Maintain current altitude
#endif


// LOITER Mode
#ifndef OF_LOITER_YAW
 # define OF_LOITER_YAW          YAW_HOLD
#endif

#ifndef OF_LOITER_RP
 # define OF_LOITER_RP                   ROLL_PITCH_STABLE_OF
#endif

#ifndef OF_LOITER_THR
 # define OF_LOITER_THR                  THROTTLE_HOLD
#endif

//////////////////////////////////////////////////////////////////////////////
// Attitude Control
//

// Extra motor values that are changed from time to time by jani @ jDrones as software
// and charachteristics changes.
#ifdef MOTORS_JD880
 # define STABILIZE_ROLL_P               3.7
 # define STABILIZE_ROLL_I               0.0
 # define STABILIZE_ROLL_IMAX    8.0            // degrees
 # define STABILIZE_PITCH_P              3.7
 # define STABILIZE_PITCH_I              0.0
 # define STABILIZE_PITCH_IMAX   8.0            // degrees
#endif

#ifdef MOTORS_JD850
 # define STABILIZE_ROLL_P               4.2
 # define STABILIZE_ROLL_I               0.0
 # define STABILIZE_ROLL_IMAX    8.0            // degrees
 # define STABILIZE_PITCH_P              4.2
 # define STABILIZE_PITCH_I              0.0
 # define STABILIZE_PITCH_IMAX   8.0            // degrees
#endif


#ifndef ACRO_P
 # define ACRO_P                 4.5
#endif


#ifndef AXIS_LOCK_ENABLED
 # define AXIS_LOCK_ENABLED      ENABLED
#endif

#ifndef AXIS_LOCK_P
 # define AXIS_LOCK_P            .02
#endif


// Good for smaller payload motors.
#ifndef STABILIZE_ROLL_P
 # define STABILIZE_ROLL_P               4.5
#endif
#ifndef STABILIZE_ROLL_I
 # define STABILIZE_ROLL_I               0.0
#endif
#ifndef STABILIZE_ROLL_IMAX
 # define STABILIZE_ROLL_IMAX    8.0            // degrees
#endif

#ifndef STABILIZE_PITCH_P
 # define STABILIZE_PITCH_P              4.5
#endif
#ifndef STABILIZE_PITCH_I
 # define STABILIZE_PITCH_I              0.0
#endif
#ifndef STABILIZE_PITCH_IMAX
 # define STABILIZE_PITCH_IMAX   8.0            // degrees
#endif

#ifndef  STABILIZE_YAW_P
 # define STABILIZE_YAW_P                4.5            // increase for more aggressive Yaw Hold, decrease if it's bouncy
#endif
#ifndef  STABILIZE_YAW_I
 # define STABILIZE_YAW_I                0.0
#endif
#ifndef  STABILIZE_YAW_IMAX
 # define STABILIZE_YAW_IMAX             8.0            // degrees * 100
#endif


//////////////////////////////////////////////////////////////////////////////
// Stabilize Rate Control
//
#ifndef RATE_ROLL_P
 # define RATE_ROLL_P        0.175
#endif
#ifndef RATE_ROLL_I
 # define RATE_ROLL_I        0.010
#endif
#ifndef RATE_ROLL_D
 # define RATE_ROLL_D        0.004
#endif
#ifndef RATE_ROLL_IMAX
 # define RATE_ROLL_IMAX         5.0                    // degrees
#endif

#ifndef RATE_PITCH_P
 # define RATE_PITCH_P       0.175
#endif
#ifndef RATE_PITCH_I
 # define RATE_PITCH_I       0.010
#endif
#ifndef RATE_PITCH_D
 # define RATE_PITCH_D       0.004
#endif
#ifndef RATE_PITCH_IMAX
 # define RATE_PITCH_IMAX        5.0                    // degrees
#endif

#ifndef RATE_YAW_P
 # define RATE_YAW_P              .25
#endif
#ifndef RATE_YAW_I
 # define RATE_YAW_I              0.015
#endif
#ifndef RATE_YAW_D
 # define RATE_YAW_D              0.000
#endif
#ifndef RATE_YAW_IMAX
 # define RATE_YAW_IMAX            8.0          // degrees
#endif


#ifndef STABILIZE_D
 # define STABILIZE_D            0.00
#endif

#ifndef STABILIZE_D_SCHEDULE
 # define STABILIZE_D_SCHEDULE           0.5
#endif


//////////////////////////////////////////////////////////////////////////////
// Rate controlled stabilized variables
//

#ifndef MAX_ROLL_OVERSHOOT
 #define MAX_ROLL_OVERSHOOT	3000
#endif

#ifndef MAX_PITCH_OVERSHOOT
 #define MAX_PITCH_OVERSHOOT	3000
#endif

#ifndef MAX_YAW_OVERSHOOT
 #define MAX_YAW_OVERSHOOT	1000
#endif

#ifndef ACRO_ROLL_STABILISE
 #define ACRO_ROLL_STABILISE	100
#endif

#ifndef ACRO_PITCH_STABILISE
 #define ACRO_PITCH_STABILISE	0
#endif

//////////////////////////////////////////////////////////////////////////////
// Loiter control gains
//
#ifndef LOITER_P
 # define LOITER_P                       .20
#endif
#ifndef LOITER_I
 # define LOITER_I                       0.0
#endif
#ifndef LOITER_IMAX
 # define LOITER_IMAX            30             // degrees
#endif

//////////////////////////////////////////////////////////////////////////////
// Loiter Navigation control gains
//
#ifndef LOITER_RATE_P
 # define LOITER_RATE_P          5.0            //
#endif
#ifndef LOITER_RATE_I
 # define LOITER_RATE_I          0.04           // Wind control
#endif
#ifndef LOITER_RATE_D
 # define LOITER_RATE_D          0.40           // try 2 or 3 for LOITER_RATE 1
#endif
#ifndef LOITER_RATE_IMAX
 # define LOITER_RATE_IMAX       30                     // degrees
#endif

//////////////////////////////////////////////////////////////////////////////
// WP Navigation control gains
//
#ifndef NAV_P
 # define NAV_P                          2.4                    //
#endif
#ifndef NAV_I
 # define NAV_I                          0.17           // Wind control
#endif
#ifndef NAV_D
 # define NAV_D                          0.00           // .95
#endif
#ifndef NAV_IMAX
 # define NAV_IMAX                       18                     // degrees
#endif

#ifndef AUTO_SLEW_RATE
 # define AUTO_SLEW_RATE         30                     // degrees
#endif


#ifndef WAYPOINT_SPEED_MAX
 # define WAYPOINT_SPEED_MAX             500                    // 6m/s error = 13mph
#endif

#ifndef WAYPOINT_SPEED_MIN
 # define WAYPOINT_SPEED_MIN             150                    // 1m/s
#endif

#ifndef TILT_COMPENSATION
 # if FRAME_CONFIG == HELI_FRAME
  #   define TILT_COMPENSATION 5
 # else
  #   define TILT_COMPENSATION 54
 # endif 
#endif



//////////////////////////////////////////////////////////////////////////////
// Throttle control gains
//
#ifndef AUTO_THROTTLE_HOLD
 # define AUTO_THROTTLE_HOLD 1
#endif

#ifndef THROTTLE_CRUISE
 # define THROTTLE_CRUISE        450            //
#endif

#ifndef ALT_HOLD_P
 # define ALT_HOLD_P                     0.3            // .5
#endif
#ifndef ALT_HOLD_I
 # define ALT_HOLD_I                     0.04
#endif
#ifndef ALT_HOLD_IMAX
 # define ALT_HOLD_IMAX          300
#endif

// RATE control
#ifndef THROTTLE_P
 # define THROTTLE_P                     0.3    // .25
#endif
#ifndef THROTTLE_I
 # define THROTTLE_I                     0.03
#endif
#ifndef THROTTLE_D
 # define THROTTLE_D                     0.0
#endif
#ifndef THROTTLE_IMAX
 # define THROTTLE_IMAX          300
#endif


//////////////////////////////////////////////////////////////////////////////
// Crosstrack compensation
//
#ifndef CROSSTRACK_GAIN
 # define CROSSTRACK_GAIN                .2
#endif


//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
// DEBUGGING
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// DEBUG_LEVEL
//
#ifndef DEBUG_LEVEL
 # define DEBUG_LEVEL SEVERITY_LOW
#endif

//////////////////////////////////////////////////////////////////////////////
// Dataflash logging control
//
// Logging must be disabled for 1280 build.
#if defined( __AVR_ATmega1280__ )
 # if LOGGING_ENABLED == ENABLED
// If logging was enabled in APM_Config or command line, warn the user.
  #  warning "Logging is not supported on ATmega1280"
  #  undef LOGGING_ENABLED
 # endif
 # ifndef LOGGING_ENABLED
  #  define LOGGING_ENABLED    DISABLED
 # endif
#elif !defined(LOGGING_ENABLED)
// Logging is enabled by default for all other builds.
 # define LOGGING_ENABLED                ENABLED
#endif


#ifndef LOG_ATTITUDE_FAST
 # define LOG_ATTITUDE_FAST              DISABLED
#endif
#ifndef LOG_ATTITUDE_MED
 # define LOG_ATTITUDE_MED               ENABLED
#endif
#ifndef LOG_GPS
 # define LOG_GPS                                ENABLED
#endif
#ifndef LOG_PM
 # define LOG_PM                                 ENABLED
#endif
#ifndef LOG_CTUN
 # define LOG_CTUN                               ENABLED
#endif
#ifndef LOG_NTUN
 # define LOG_NTUN                               ENABLED
#endif
#ifndef LOG_MODE
 # define LOG_MODE                               ENABLED
#endif
#ifndef LOG_RAW
 # define LOG_RAW                                DISABLED
#endif
#ifndef LOG_CMD
 # define LOG_CMD                                ENABLED
#endif
// current
#ifndef LOG_CUR
 # define LOG_CUR                                DISABLED
#endif
// quad motor PWMs
#ifndef LOG_MOTORS
 # define LOG_MOTORS                             DISABLED
#endif
// optical flow
#ifndef LOG_OPTFLOW
 # define LOG_OPTFLOW                    DISABLED
#endif
#ifndef LOG_PID
 # define LOG_PID                                DISABLED
#endif

// calculate the default log_bitmask
#define LOGBIT(_s)     (LOG_ ## _s ? MASK_LOG_ ## _s : 0)

#define DEFAULT_LOG_BITMASK \
    LOGBIT(ATTITUDE_FAST)   | \
    LOGBIT(ATTITUDE_MED)    | \
    LOGBIT(GPS)                             | \
    LOGBIT(PM)                              | \
    LOGBIT(CTUN)                    | \
    LOGBIT(NTUN)                    | \
    LOGBIT(MODE)                    | \
    LOGBIT(RAW)                             | \
    LOGBIT(CMD)                             | \
    LOGBIT(CUR)                             | \
    LOGBIT(MOTORS)                  | \
    LOGBIT(OPTFLOW)                 | \
    LOGBIT(PID)

// if we are using fast, Disable Medium
//#if LOG_ATTITUDE_FAST == ENABLED
//	#undef LOG_ATTITUDE_MED
//	#define LOG_ATTITUDE_MED        DISABLED
//#endif

//////////////////////////////////////////////////////////////////////////////
// Navigation defaults
//
#ifndef WP_RADIUS_DEFAULT
 # define WP_RADIUS_DEFAULT      2
#endif

#ifndef LOITER_RADIUS
 # define LOITER_RADIUS 10              // meters for circle mode
#endif

#ifndef USE_CURRENT_ALT
 # define USE_CURRENT_ALT FALSE
#endif

//////////////////////////////////////////////////////////////////////////////
// RC override
//
#ifndef ALLOW_RC_OVERRIDE
 # define ALLOW_RC_OVERRIDE DISABLED
#endif

//////////////////////////////////////////////////////////////////////////////
// AP_Limits Defaults
//


// Enable/disable AP_Limits
#ifndef AP_LIMITS
 #define AP_LIMITS ENABLED
#endif

// Use PIN for displaying LIMITS status. 0 is disabled.
#ifndef LIMITS_TRIGGERED_PIN
 #define LIMITS_TRIGGERED_PIN 0
#endif

// PWM of "on" state for LIM_CHANNEL
#ifndef LIMITS_ENABLE_PWM
 #define LIMITS_ENABLE_PWM 1800
#endif

#ifndef LIM_ENABLED
 #define LIM_ENABLED 0
#endif

#ifndef LIM_ALT_ON
 #define LIM_ALT_ON 0
#endif

#ifndef LIM_FNC_ON
 #define LIM_FNC_ON 0
#endif

#ifndef LIM_GPSLCK_ON
 #define LIM_GPSLCK_ON 0
#endif



//////////////////////////////////////////////////////////////////////////////
// Developer Items
//

// use this to completely disable the CLI
#ifndef CLI_ENABLED
// Sorry the chip is just too small to let this fit
 # if defined( __AVR_ATmega1280__ )
  #  define CLI_ENABLED           DISABLED
 # else
  #  define CLI_ENABLED           ENABLED
 # endif
#endif

// use this to disable the CLI slider switch
#ifndef CLI_SLIDER_ENABLED
 # define CLI_SLIDER_ENABLED DISABLED
#endif

// experimental mpu6000 DMP code
#ifndef DMP_ENABLED
 # define DMP_ENABLED DISABLED
#endif

// experimental mpu6000 DMP code
#ifndef SECONDARY_DMP_ENABLED
 # define SECONDARY_DMP_ENABLED DISABLED
#endif

#ifndef ALTERNATIVE_YAW_MODE
 # define ALTERNATIVE_YAW_MODE DISABLED
#endif

// Inertia based contollers.  disabled by default, work in progress
#define ACCEL_ALT_HOLD 0
#define INERTIAL_NAV DISABLED

#endif // __ARDUCOPTER_CONFIG_H__
/// -*- tab-width: 4; Mode: C++; c-basic-offset: 4; indent-tabs-mode: nil -*-

static void read_control_switch()
{
    static bool switch_debouncer = false;

    byte switchPosition = readSwitch();

    if (oldSwitchPosition != switchPosition) {
        if(switch_debouncer) {
            oldSwitchPosition       = switchPosition;
            switch_debouncer        = false;

            set_mode(flight_modes[switchPosition]);

            if(g.ch7_option != CH7_SIMPLE_MODE) {
                // set Simple mode using stored paramters from Mission planner
                // rather than by the control switch
                do_simple = (g.simple_modes & (1 << switchPosition));
            }
        }else{
            switch_debouncer        = true;
        }
    }
}

static byte readSwitch(void){
    int16_t pulsewidth = g.rc_5.radio_in;                       // default for Arducopter

    if (pulsewidth > 1230 && pulsewidth <= 1360) return 1;
    if (pulsewidth > 1360 && pulsewidth <= 1490) return 2;
    if (pulsewidth > 1490 && pulsewidth <= 1620) return 3;
    if (pulsewidth > 1620 && pulsewidth <= 1749) return 4;              // Software Manual
    if (pulsewidth >= 1750) return 5;                                                           // Hardware Manual
    return 0;
}

static void reset_control_switch()
{
    oldSwitchPosition = -1;
    read_control_switch();
}

// read at 10 hz
// set this to your trainer switch
static void read_trim_switch()
{
    int8_t option;

    if(g.ch7_option == CH7_MULTI_MODE) {
        if (g.rc_6.radio_in < CH_6_PWM_TRIGGER_LOW) {
            option = CH7_FLIP;
        }else if (g.rc_6.radio_in > CH_6_PWM_TRIGGER_HIGH) {
            option = CH7_SAVE_WP;
        }else{
            option = CH7_RTL;
        }
    }else{
        option = g.ch7_option;
    }

    if(option == CH7_SIMPLE_MODE) {
        do_simple = (g.rc_7.radio_in > CH_7_PWM_TRIGGER);

    }else if (option == CH7_FLIP) {
        if (CH7_flag == false && g.rc_7.radio_in > CH_7_PWM_TRIGGER) {
            CH7_flag = true;

            // don't flip if we accidentally engaged flip, but didn't notice and tried to takeoff
            if(g.rc_3.control_in != 0 && takeoff_complete) {
                init_flip();
            }
        }
        if (CH7_flag == true && g.rc_7.control_in < 800) {
            CH7_flag = false;
        }

    }else if (option == CH7_RTL) {
        if (CH7_flag == false && g.rc_7.radio_in > CH_7_PWM_TRIGGER) {
            CH7_flag = true;
            set_mode(RTL);
        }

        if (CH7_flag == true && g.rc_7.control_in < 800) {
            CH7_flag = false;
            if (control_mode == RTL || control_mode == LOITER) {
                reset_control_switch();
            }
        }

    }else if (option == CH7_SAVE_WP) {
        if (g.rc_7.radio_in > CH_7_PWM_TRIGGER) {        // switch is engaged
            CH7_flag = true;

        }else{         // switch is disengaged
            if(CH7_flag) {
                CH7_flag = false;

                if(control_mode == AUTO) {
                    // reset the mission
                    CH7_wp_index = 0;
                    g.command_total.set_and_save(1);
                    set_mode(RTL);
                    return;
                }

                if(CH7_wp_index == 0) {
                    // this is our first WP, let's save WP 1 as a takeoff
                    // increment index to WP index of 1 (home is stored at 0)
                    CH7_wp_index = 1;

                    Location temp   = home;
                    // set our location ID to 16, MAV_CMD_NAV_WAYPOINT
                    temp.id = MAV_CMD_NAV_TAKEOFF;
                    temp.alt = current_loc.alt;

                    // save command:
                    // we use the current altitude to be the target for takeoff.
                    // only altitude will matter to the AP mission script for takeoff.
                    // If we are above the altitude, we will skip the command.
                    set_cmd_with_index(temp, CH7_wp_index);
                }

                // increment index
                CH7_wp_index++;

                // set the next_WP (home is stored at 0)
                // max out at 100 since I think we need to stay under the EEPROM limit
                CH7_wp_index = constrain(CH7_wp_index, 1, 100);

                if(g.rc_3.control_in > 0) {
                    // set our location ID to 16, MAV_CMD_NAV_WAYPOINT
                    current_loc.id = MAV_CMD_NAV_WAYPOINT;
                }else{
                    // set our location ID to 21, MAV_CMD_NAV_LAND
                    current_loc.id = MAV_CMD_NAV_LAND;
                }

                // save command
                set_cmd_with_index(current_loc, CH7_wp_index);

                copter_leds_nav_blink = 10;                     // Cause the CopterLEDs to blink twice to indicate saved waypoint

                // 0 = home
                // 1 = takeoff
                // 2 = WP 2
                // 3 = command total
            }
        }
    }else if (option == CH7_AUTO_TRIM) {
        if (g.rc_7.radio_in > CH_7_PWM_TRIGGER) {
            auto_level_counter = 10;
        }
    }
}

static void auto_trim()
{
    if(auto_level_counter > 0) {
        //g.rc_1.dead_zone = 60;		// 60 = .6 degrees
        //g.rc_2.dead_zone = 60;

        auto_level_counter--;

        if( motors.armed() ) {
            // set high AHRS gains to force accelerometers to impact attitude estimate
            ahrs.set_fast_gains(true);
#if SECONDARY_DMP_ENABLED == ENABLED
            ahrs2.set_fast_gains(true);
#endif
        }

        trim_accel();
        led_mode = AUTO_TRIM_LEDS;
        do_simple = false;

        if(auto_level_counter == 1) {
            //g.rc_1.dead_zone = 0;		// 60 = .6 degrees
            //g.rc_2.dead_zone = 0;
            led_mode = NORMAL_LEDS;
            clear_leds();
            imu.save();

            reset_control_switch();

            // go back to normal AHRS gains
            if( motors.armed() ) {
                ahrs.set_fast_gains(false);
#if SECONDARY_DMP_ENABLED == ENABLED
                ahrs2.set_fast_gains(false);
#endif
            }

            //Serial.println("Done");
            auto_level_counter = 0;
        }
    }
}


/*
 *  How this works:
 *  Level Example:
 *  A_off: -14.00, -20.59, -30.80
 *
 *  Right roll Example:
 *  A_off: -6.73, 89.05, -46.02
 *
 *  Left Roll Example:
 *  A_off: -18.11, -160.31, -56.42
 *
 *  Pitch Forward:
 *  A_off: -127.00, -22.16, -50.09
 *
 *  Pitch Back:
 *  A_off: 201.95, -24.00, -88.56
 */

static void trim_accel()
{
    reset_stability_I();

    float trim_roll  = (float)g.rc_1.control_in / 30000.0;
    float trim_pitch = (float)g.rc_2.control_in / 30000.0;

    trim_roll       = constrain(trim_roll, -1.5, 1.5);
    trim_pitch      = constrain(trim_pitch, -1.5, 1.5);

    if(g.rc_1.control_in > 200) {    // Roll Right
        imu.ay(imu.ay() - trim_roll);
    }else if (g.rc_1.control_in < -200) {
        imu.ay(imu.ay() - trim_roll);
    }

    if(g.rc_2.control_in > 200) {    // Pitch Back
        imu.ax(imu.ax() + trim_pitch);
    }else if (g.rc_2.control_in < -200) {
        imu.ax(imu.ax() + trim_pitch);
    }

    /*
     *  Serial.printf_P(PSTR("r:%1.2f  %1.2f \t| p:%1.2f  %1.2f\n"),
     *                                               trim_roll,
     *                                               (float)imu.ay(),
     *                                               trim_pitch,
     *                                               (float)imu.ax());
     *  //*/
}

// -*- tab-width: 4; Mode: C++; c-basic-offset: 4; indent-tabs-mode: nil -*-

#ifndef _DEFINES_H
#define _DEFINES_H

// Just so that it's completely clear...
#define ENABLED                 1
#define DISABLED                0

// this avoids a very common config error
#define ENABLE ENABLED
#define DISABLE DISABLED

// Flight modes
// ------------
#define YAW_HOLD                        0
#define YAW_ACRO                        1
#define YAW_AUTO                        2
#define YAW_LOOK_AT_HOME    		    3
#define YAW_TOY                         4       // THOR This is the Yaw mode


#define ROLL_PITCH_STABLE       0
#define ROLL_PITCH_ACRO         1
#define ROLL_PITCH_AUTO         2
#define ROLL_PITCH_STABLE_OF    3
#define ROLL_PITCH_TOY          4       // THOR This is the Roll and Pitch
                                        // mode

#define THROTTLE_MANUAL         0
#define THROTTLE_HOLD           1
#define THROTTLE_AUTO           2


// active altitude sensor
// ----------------------
#define SONAR 0
#define BARO 1

#define SONAR_SOURCE_ADC 1
#define SONAR_SOURCE_ANALOG_PIN 2

// CH 7 control
#define CH7_DO_NOTHING 0
#define CH7_SET_HOVER 1
#define CH7_FLIP 2
#define CH7_SIMPLE_MODE 3
#define CH7_RTL 4
#define CH7_AUTO_TRIM 5
#define CH7_ADC_FILTER 6
#define CH7_SAVE_WP 7
#define CH7_MULTI_MODE 8


// Frame types
#define QUAD_FRAME 0
#define TRI_FRAME 1
#define HEXA_FRAME 2
#define Y6_FRAME 3
#define OCTA_FRAME 4
#define HELI_FRAME 5
#define OCTA_QUAD_FRAME 6

#define PLUS_FRAME 0
#define X_FRAME 1
#define V_FRAME 2

// LED output
#define NORMAL_LEDS 0
#define AUTO_TRIM_LEDS 1


#define CH_7_PWM_TRIGGER 1800
#define CH_6_PWM_TRIGGER_HIGH 1800
#define CH_6_PWM_TRIGGER 1500
#define CH_6_PWM_TRIGGER_LOW 1200

// Internal defines, don't edit and expect things to work
// -------------------------------------------------------

#define TRUE 1
#define FALSE 0
#define ToRad(x) (x*0.01745329252)      // *pi/180
#define ToDeg(x) (x*57.2957795131)      // *180/pi

#define DEBUG 0
#define LOITER_RANGE 60 // for calculating power outside of loiter radius

#define T6 1000000
#define T7 10000000

// GPS type codes - use the names, not the numbers
#define GPS_PROTOCOL_NONE       -1
#define GPS_PROTOCOL_NMEA       0
#define GPS_PROTOCOL_SIRF       1
#define GPS_PROTOCOL_UBLOX      2
#define GPS_PROTOCOL_IMU        3
#define GPS_PROTOCOL_MTK        4
#define GPS_PROTOCOL_HIL        5
#define GPS_PROTOCOL_MTK16      6
#define GPS_PROTOCOL_AUTO       7

#define CH_ROLL CH_1
#define CH_PITCH CH_2
#define CH_THROTTLE CH_3
#define CH_RUDDER CH_4
#define CH_YAW CH_4

#define RC_CHANNEL_ANGLE 0
#define RC_CHANNEL_RANGE 1
#define RC_CHANNEL_ANGLE_RAW 2

// HIL enumerations
#define HIL_MODE_DISABLED                       0
#define HIL_MODE_ATTITUDE                       1
#define HIL_MODE_SENSORS                        2

#define ASCENDING                       1
#define DESCENDING                      -1
#define REACHED_ALT                     0

// Auto Pilot modes
// ----------------
#define STABILIZE 0                     // hold level position
#define ACRO 1                          // rate control
#define ALT_HOLD 2                      // AUTO control
#define AUTO 3                          // AUTO control
#define GUIDED 4                        // AUTO control
#define LOITER 5                        // Hold a single location
#define RTL 6                           // AUTO control
#define CIRCLE 7                        // AUTO control
#define POSITION 8                      // AUTO control
#define LAND 9                          // AUTO control
#define OF_LOITER 10            // Hold a single location using optical flow
                                // sensor
#define TOY_A 11                                // THOR Enum for Toy mode
#define TOY_M 12                                // THOR Enum for Toy mode
#define NUM_MODES 13

#define SIMPLE_1 1
#define SIMPLE_2 2
#define SIMPLE_3 4
#define SIMPLE_4 8
#define SIMPLE_5 16
#define SIMPLE_6 32

// CH_6 Tuning
// -----------
#define CH6_NONE 0
// Attitude
#define CH6_STABILIZE_KP 1
#define CH6_STABILIZE_KI 2
#define CH6_STABILIZE_KD 29             // duplicate with CH6_DAMP
#define CH6_YAW_KP 3
#define CH6_YAW_KI 24
// Rate
#define CH6_ACRO_KP 25
#define CH6_RATE_KP 4
#define CH6_RATE_KI 5
#define CH6_RATE_KD 21
#define CH6_YAW_RATE_KP 6
#define CH6_YAW_RATE_KD 26
// Altitude rate controller
#define CH6_THROTTLE_KP 7
// Extras
#define CH6_TOP_BOTTOM_RATIO 8
#define CH6_RELAY 9
// Navigation
#define CH6_TRAVERSE_SPEED 10   // maximum speed to next way point
#define CH6_NAV_KP 11
#define CH6_LOITER_KP 12
#define CH6_LOITER_KI 27

// Trad Heli specific
#define CH6_HELI_EXTERNAL_GYRO 13

// altitude controller
#define CH6_THR_HOLD_KP 14
#define CH6_Z_GAIN 15
#define CH6_DAMP 16             // duplicate with CH6_YAW_RATE_KD

// optical flow controller
#define CH6_OPTFLOW_KP 17
#define CH6_OPTFLOW_KI 18
#define CH6_OPTFLOW_KD 19

#define CH6_NAV_I 20
#define CH6_LOITER_RATE_KP 22
#define CH6_LOITER_RATE_KI 28
#define CH6_LOITER_RATE_KD 23

#define CH6_AHRS_YAW_KP 30
#define CH6_AHRS_KP             31


// nav byte mask
// -------------
#define NAV_LOCATION 1
#define NAV_ALTITUDE 2
#define NAV_DELAY    4


// Commands - Note that APM now uses a subset of the MAVLink protocol
// commands.  See enum MAV_CMD in the GCS_Mavlink library
#define CMD_BLANK 0 // there is no command stored in the mem location
                    // requested
#define NO_COMMAND 0


#define LOITER_MODE 1
#define WP_MODE 2
#define CIRCLE_MODE 3
#define NO_NAV_MODE 4
#define TOY_MODE 5                      // THOR This mode defines the Virtual
                                        // WP following mode

// TOY mixing options
#define TOY_LOOKUP_TABLE 0
#define TOY_LINEAR_MIXER 1
#define TOY_EXTERNAL_MIXER 2


// Waypoint options
#define MASK_OPTIONS_RELATIVE_ALT               1
#define WP_OPTION_ALT_CHANGE                    2
#define WP_OPTION_YAW                                   4
#define WP_OPTION_ALT_REQUIRED                  8
#define WP_OPTION_RELATIVE                              16
//#define WP_OPTION_					32
//#define WP_OPTION_					64
#define WP_OPTION_NEXT_CMD                              128

//repeating events
#define NO_REPEAT 0
#define CH_5_TOGGLE 1
#define CH_6_TOGGLE 2
#define CH_7_TOGGLE 3
#define CH_8_TOGGLE 4
#define RELAY_TOGGLE 5
#define STOP_REPEAT 10

//  GCS Message ID's
/// NOTE: to ensure we never block on sending MAVLink messages
/// please keep each MSG_ to a single MAVLink message. If need be
/// create new MSG_ IDs for additional messages on the same
/// stream
enum ap_message {
    MSG_HEARTBEAT,
    MSG_ATTITUDE,
    MSG_LOCATION,
    MSG_EXTENDED_STATUS1,
    MSG_EXTENDED_STATUS2,
    MSG_NAV_CONTROLLER_OUTPUT,
    MSG_CURRENT_WAYPOINT,
    MSG_VFR_HUD,
    MSG_RADIO_OUT,
    MSG_RADIO_IN,
    MSG_RAW_IMU1,
    MSG_RAW_IMU2,
    MSG_RAW_IMU3,
    MSG_GPS_STATUS,
    MSG_GPS_RAW,
    MSG_SERVO_OUT,
    MSG_NEXT_WAYPOINT,
    MSG_NEXT_PARAM,
    MSG_STATUSTEXT,
    MSG_LIMITS_STATUS,
    MSG_AHRS,
    MSG_SIMSTATE,
    MSG_HWSTATUS,
    MSG_RETRY_DEFERRED // this must be last
};

enum gcs_severity {
    SEVERITY_LOW=1,
    SEVERITY_MEDIUM,
    SEVERITY_HIGH,
    SEVERITY_CRITICAL
};

//  Logging parameters
#define TYPE_AIRSTART_MSG               0x00
#define TYPE_GROUNDSTART_MSG            0x01
#define LOG_ATTITUDE_MSG                0x01
#define LOG_GPS_MSG                     0x02
#define LOG_MODE_MSG                    0x03
#define LOG_CONTROL_TUNING_MSG          0x04
#define LOG_NAV_TUNING_MSG              0x05
#define LOG_PERFORMANCE_MSG             0x06
#define LOG_RAW_MSG                     0x07
#define LOG_CMD_MSG                     0x08
#define LOG_CURRENT_MSG                 0x09
#define LOG_STARTUP_MSG                 0x0A
#define LOG_MOTORS_MSG                  0x0B
#define LOG_OPTFLOW_MSG                 0x0C
#define LOG_DATA_MSG                    0x0D
#define LOG_PID_MSG                     0x0E
#define LOG_ITERM_MSG                   0x0F
#define LOG_DMP_MSG                     0x10
#define LOG_INDEX_MSG                   0xF0
#define MAX_NUM_LOGS                    50

#define MASK_LOG_ATTITUDE_FAST  (1<<0)
#define MASK_LOG_ATTITUDE_MED   (1<<1)
#define MASK_LOG_GPS                    (1<<2)
#define MASK_LOG_PM                     (1<<3)
#define MASK_LOG_CTUN                   (1<<4)
#define MASK_LOG_NTUN                   (1<<5)
#define MASK_LOG_MODE                   (1<<6)
#define MASK_LOG_RAW                    (1<<7)
#define MASK_LOG_CMD                    (1<<8)
#define MASK_LOG_CUR                    (1<<9)
#define MASK_LOG_MOTORS                 (1<<10)
#define MASK_LOG_OPTFLOW                (1<<11)
#define MASK_LOG_PID                    (1<<12)
#define MASK_LOG_ITERM                  (1<<13)


// Waypoint Modes
// ----------------
#define ABS_WP 0
#define REL_WP 1

// Command Queues
// ---------------
#define COMMAND_MUST 0
#define COMMAND_MAY 1
#define COMMAND_NOW 2

// Events
// ------
#define EVENT_WILL_REACH_WAYPOINT 1
#define EVENT_SET_NEW_WAYPOINT_INDEX 2
#define EVENT_LOADED_WAYPOINT 3
#define EVENT_LOOP 4

// Climb rate calculations
#define ALTITUDE_HISTORY_LENGTH 8       //Number of (time,altitude) points to
                                        // regress a climb rate from

#define BATTERY_VOLTAGE(x) (x*(g.input_voltage/1024.0))*g.volt_div_ratio
#define CURRENT_AMPS(x) ((x*(g.input_voltage/1024.0))-CURR_AMPS_OFFSET)*g.curr_amp_per_volt

//#define BARO_FILTER_SIZE 8

/* ************************************************************** */
/* Expansion PIN's that people can use for various things. */

// AN0 - 7 are located at edge of IMU PCB "above" pressure sensor and
// Expansion port
// AN0 - 5 are also located next to voltage dividers and sliding SW2 switch
// AN0 - 3 has 10kOhm resistor in serial, include 3.9kOhm to make it as
// voltage divider
// AN4 - 5 are direct GPIO pins from atmega1280 and they are the latest pins
// next to SW2 switch
// Look more ArduCopter Wiki for voltage dividers and other ports
#define AN0  54  // resistor, vdiv use, divider 1 closest to relay
#define AN1  55  // resistor, vdiv use, divider 2
#define AN2  56  // resistor, vdiv use, divider 3
#define AN3  57  // resistor, vdiv use, divider 4 closest to SW2
#define AN4  58  // direct GPIO pin, default as analog input, next to SW2
                 // switch
#define AN5  59  // direct GPIO pin, default as analog input, next to SW2
                 // switch
#define AN6  60  // direct GPIO pin, default as analog input, close to
                 // Pressure sensor, Expansion Ports
#define AN7  61  // direct GPIO pin, default as analog input, close to
                 // Pressure sensor, Expansion Ports

// AN8 - 15 are located at edge of IMU PCB "above" pressure sensor and
// Expansion port
// AN8 - 15 PINs are not connected anywhere, they are located as last 8 pins
// on edge of the board above Expansion Ports
// even pins (8,10,12,14) are at edge of board, Odd pins (9,11,13,15) are on
// inner row
#define AN8  62  // NC
#define AN9  63  // NC
#define AN10  64 // NC
#define AN11  65 // NC
#define AN12  66 // NC
#define AN13  67 // NC
#define AN14  68 // NC
#define AN15  69 // NC

#define RELAY_PIN 47

#define PIEZO_PIN AN5           //Last pin on the back ADC connector



// sonar
//#define SonarToCm(x) (x*1.26)   // Sonar raw value to centimeters

// RADIANS
#define RADX100 0.000174532925
#define DEGX100 5729.57795


// EEPROM addresses
#define EEPROM_MAX_ADDR         4096
// parameters get the first 1536 bytes of EEPROM, remainder is for waypoints
#define WP_START_BYTE 0x600 // where in memory home WP is stored + all other
                            // WP
#define WP_SIZE 15

#define ONBOARD_PARAM_NAME_LENGTH 15

// fence points are stored at the end of the EEPROM
#define MAX_FENCEPOINTS 6
#define FENCE_WP_SIZE sizeof(Vector2l)
#define FENCE_START_BYTE (EEPROM_MAX_ADDR-(MAX_FENCEPOINTS*FENCE_WP_SIZE))

#define MAX_WAYPOINTS  ((FENCE_START_BYTE - WP_START_BYTE) / WP_SIZE) - 1 // -
                                                                          // 1
                                                                          // to
                                                                          // be
                                                                          // safe

// mark a function as not to be inlined
#define NOINLINE __attribute__((noinline))

// IMU selection
#define CONFIG_IMU_OILPAN 1
#define CONFIG_IMU_MPU6000 2

// APM Hardware selection
#define APM_HARDWARE_APM1 1
#define APM_HARDWARE_APM2 2

#define AP_BARO_BMP085    1
#define AP_BARO_MS5611    2

#define LOGGING_SIMPLE    1
#define LOGGING_VERBOSE   2

// Channel Config selection

#define CHANNEL_CONFIG_DEFAULT 1
#define CHANNEL_CONFIG_CUSTOM  2

#endif // _DEFINES_H
// -*- tab-width: 4; Mode: C++; c-basic-offset: 4; indent-tabs-mode: nil -*-

/*
 *       This event will be called when the failsafe changes
 *       boolean failsafe reflects the current state
 */
static void failsafe_on_event()
{
    // This is how to handle a failsafe.
    switch(control_mode)
    {
    case AUTO:
        if (g.throttle_fs_action == 1) {
            // do_rtl sets the altitude to the current altitude by default
            set_mode(RTL);
            // We add an additional 10m to the current altitude
            //next_WP.alt += 1000;
            set_new_altitude(next_WP.alt + 1000);
        }
        //if (g.throttle_fs_action == 2)
        //  Stay in AUTO and ignore failsafe
        break;

    default:
        if(home_is_set == true) {
            // same as above ^
            // do_rtl sets the altitude to the current altitude by default
            set_mode(RTL);
            // We add an additional 10m to the current altitude
            //next_WP.alt += 1000;
            set_new_altitude(next_WP.alt + 1000);
        }else{
            // We have no GPS so we must land
            set_mode(LAND);
        }
        break;
    }
}

static void failsafe_off_event()
{
    // If we are in AUTO, no need to do anything
    if(control_mode == AUTO)
        return;

    if (g.throttle_fs_action == 2) {
        // We're back in radio contact
        // return to AP
        // ---------------------------

        // re-read the switch so we can return to our preferred mode
        // --------------------------------------------------------
        reset_control_switch();


    }else if (g.throttle_fs_action == 1) {
        // We're back in radio contact
        // return to Home
        // we should already be in RTL and throttle set to cruise
        // ------------------------------------------------------
        set_mode(RTL);
    }
}

static void low_battery_event(void)
{
    static uint32_t last_low_battery_message;
    uint32_t tnow = millis();
    if (((uint32_t)(tnow - last_low_battery_message)) > 5000) {
        // only send this message at 5s intervals at most or we may
        // flood the link
        gcs_send_text_P(SEVERITY_LOW,PSTR("Low Battery!"));
        last_low_battery_message = tnow;
    }

    low_batt = true;

    // if we are in Auto mode, come home
    if(control_mode >= AUTO)
        set_mode(RTL);
}


static void update_events()     // Used for MAV_CMD_DO_REPEAT_SERVO and MAV_CMD_DO_REPEAT_RELAY
{
    if(event_repeat == 0 || (millis() - event_timer) < event_delay)
        return;

    if (event_repeat > 0) {
        event_repeat--;
    }

    if(event_repeat != 0) {             // event_repeat = -1 means repeat forever
        event_timer = millis();

        if (event_id >= CH_5 && event_id <= CH_8) {
            if(event_repeat%2) {
                APM_RC.OutputCh(event_id, event_value);                 // send to Servos
            } else {
                APM_RC.OutputCh(event_id, event_undo_value);
            }
        }

        if  (event_id == RELAY_TOGGLE) {
            relay.toggle();
        }
    }
}

// -*- tab-width: 4; Mode: C++; c-basic-offset: 4; indent-tabs-mode: nil -*-
//
//  failsafe support
//  Andrew Tridgell, December 2011
//
//  our failsafe strategy is to detect main loop lockup and disarm the motors
//

static bool failsafe_enabled = true;
static uint16_t failsafe_last_mainLoop_count;
static uint32_t failsafe_last_timestamp;
static bool in_failsafe;

//
// failsafe_enable - enable failsafe
//
void failsafe_enable()
{
    failsafe_enabled = true;
    failsafe_last_timestamp = micros();
}

//
// failsafe_disable - used when we know we are going to delay the mainloop significantly
//
void failsafe_disable()
{
    failsafe_enabled = false;
}
 
//
//  failsafe_check - this function is called from the core timer interrupt at 1kHz.
//
void failsafe_check(uint32_t tnow)
{
    if (mainLoop_count != failsafe_last_mainLoop_count) {
        // the main loop is running, all is OK
        failsafe_last_mainLoop_count = mainLoop_count;
        failsafe_last_timestamp = tnow;
        in_failsafe = false;
        return;
    }

    if (failsafe_enabled && tnow - failsafe_last_timestamp > 2000000) {
        // motors are running but we have gone 2 second since the 
        // main loop ran. That means we're in trouble and should
        // disarm the motors.
        in_failsafe = true;
    }

    if (in_failsafe && tnow - failsafe_last_timestamp > 1000000) {
        // disarm motors every second
        failsafe_last_timestamp = tnow;
        if( motors.armed() ) {
            motors.armed(false);
            motors.output();
        }
    }
}// 2010 Jose Julio
// 2011 Adapted and updated for AC2 by Jason Short
//
// Automatic Acrobatic Procedure (AAP) v1 : Roll flip
// State machine aproach:
//    Some states are fixed commands (for a fixed time)
//    Some states are fixed commands (until some IMU condition)
//    Some states include controls inside
uint8_t flip_timer;
uint8_t flip_state;

#define AAP_THR_INC 170
#define AAP_THR_DEC 120
#define AAP_ROLL_OUT 2000

static int8_t flip_dir;

void init_flip()
{
    if(do_flip == false) {
        do_flip = true;
        flip_state = 0;
        flip_dir = (ahrs.roll_sensor >= 0) ? 1 : -1;
    }
}

void roll_flip()
{
    // Pitch
    //g.rc_2.servo_out = get_stabilize_pitch(g.rc_2.control_in);
    get_stabilize_pitch(g.rc_2.control_in);

    int32_t roll = ahrs.roll_sensor * flip_dir;

    // Roll State machine
    switch (flip_state) {
    case 0:
        if (roll < 4500) {
            // Roll control
            g.rc_1.servo_out = AAP_ROLL_OUT * flip_dir;
            g.rc_3.servo_out = g.rc_3.control_in + AAP_THR_INC;
        }else{
            flip_state++;
        }
        break;

    case 1:
        if((roll >= 4500) || (roll < -9000)) {
            g.rc_1.servo_out = get_rate_roll(40000 * flip_dir);
            g.rc_3.servo_out = g.rc_3.control_in - AAP_THR_DEC;
        }else{
            flip_state++;
            flip_timer = 0;
        }
        break;

    case 2:
        if (flip_timer < 100) {
            //g.rc_1.servo_out = get_stabilize_roll(g.rc_1.control_in);
            get_stabilize_roll(g.rc_1.control_in);
            g.rc_3.servo_out = g.rc_3.control_in + AAP_THR_INC;
            flip_timer++;
        }else{
            do_flip = false;
            flip_state = 0;
        }
        break;
    }
}
// -*- tab-width: 4; Mode: C++; c-basic-offset: 4; indent-tabs-mode: nil -*-

/// @file	GCS.h
/// @brief	Interface definition for the various Ground Control System
// protocols.

#ifndef __GCS_H
#define __GCS_H

#include <FastSerial.h>
#include <AP_Common.h>
#include <GPS.h>
#include <Stream.h>
#include <stdint.h>

///
/// @class	GCS
/// @brief	Class describing the interface between the APM code
///			proper and the GCS implementation.
///
/// GCS' are currently implemented inside the sketch and as such have
/// access to all global state.  The sketch should not, however, call GCS
/// internal functions - all calls to the GCS should be routed through
/// this interface (or functions explicitly exposed by a subclass).
///
class GCS_Class
{
public:

    /// Startup initialisation.
    ///
    /// This routine performs any one-off initialisation required before
    /// GCS messages are exchanged.
    ///
    /// @note The stream is expected to be set up and configured for the
    ///       correct bitrate before ::init is called.
    ///
    /// @note The stream is currently BetterStream so that we can use the _P
    ///	      methods; this may change if Arduino adds them to Print.
    ///
    /// @param	port		The stream over which messages are exchanged.
    ///
    void        init(FastSerial *port) {
        _port = port;
        initialised = true;
        last_gps_satellites = 255;
    }

    /// Update GCS state.
    ///
    /// This may involve checking for received bytes on the stream,
    /// or sending additional periodic messages.
    void        update(void) {
    }

    /// Send a message with a single numeric parameter.
    ///
    /// This may be a standalone message, or the GCS driver may
    /// have its own way of locating additional parameters to send.
    ///
    /// @param	id			ID of the message to send.
    /// @param	param		Explicit message parameter.
    ///
    void        send_message(enum ap_message id) {
    }

    /// Send a text message.
    ///
    /// @param	severity	A value describing the importance of the message.
    /// @param	str			The text to be sent.
    ///
    void        send_text(gcs_severity severity, const char *str) {
    }

    /// Send a text message with a PSTR()
    ///
    /// @param	severity	A value describing the importance of the message.
    /// @param	str			The text to be sent.
    ///
    void        send_text(gcs_severity severity, const prog_char_t *str) {
    }

    // send streams which match frequency range
    void            data_stream_send(void);

    // set to true if this GCS link is active
    bool            initialised;

    // used to prevent wasting bandwidth with GPS_STATUS messages
    uint8_t         last_gps_satellites;

protected:
    /// The stream we are communicating over
    FastSerial *      _port;
};

//
// GCS class definitions.
//
// These are here so that we can declare the GCS object early in the sketch
// and then reference it statically rather than via a pointer.
//

///
/// @class	GCS_MAVLINK
/// @brief	The mavlink protocol for qgroundcontrol
///
class GCS_MAVLINK : public GCS_Class
{
public:
    GCS_MAVLINK();
    void        update(void);
    void        init(FastSerial *port);
    void        send_message(enum ap_message id);
    void        send_text(gcs_severity severity, const char *str);
    void        send_text(gcs_severity severity, const prog_char_t *str);
    void        data_stream_send(void);
    void        queued_param_send();
    void        queued_waypoint_send();

    static const struct AP_Param::GroupInfo        var_info[];

    // NOTE! The streams enum below and the
    // set of AP_Int16 stream rates _must_ be
    // kept in the same order
    enum streams {STREAM_RAW_SENSORS,
                  STREAM_EXTENDED_STATUS,
                  STREAM_RC_CHANNELS,
                  STREAM_RAW_CONTROLLER,
                  STREAM_POSITION,
                  STREAM_EXTRA1,
                  STREAM_EXTRA2,
                  STREAM_EXTRA3,
                  STREAM_PARAMS,
                  NUM_STREAMS};

    // see if we should send a stream now. Called at 50Hz
    bool        stream_trigger(enum streams stream_num);

private:
    void        handleMessage(mavlink_message_t * msg);

    /// Perform queued sending operations
    ///
    AP_Param *                  _queued_parameter;      ///< next parameter to
                                                        // be sent in queue
    enum ap_var_type            _queued_parameter_type; ///< type of the next
                                                        // parameter
    AP_Param::ParamToken        _queued_parameter_token; ///AP_Param token for
                                                         // next() call
    uint16_t                    _queued_parameter_index; ///< next queued
                                                         // parameter's index
    uint16_t                    _queued_parameter_count; ///< saved count of
                                                         // parameters for
                                                         // queued send

    /// Count the number of reportable parameters.
    ///
    /// Not all parameters can be reported via MAVlink.  We count the number
    // that are
    /// so that we can report to a GCS the number of parameters it should
    // expect when it
    /// requests the full set.
    ///
    /// @return         The number of reportable parameters.
    ///
    uint16_t                    _count_parameters(); ///< count reportable
                                                     // parameters

    uint16_t                    _parameter_count;   ///< cache of reportable
                                                    // parameters

    mavlink_channel_t           chan;
    uint16_t                    packet_drops;

#if CLI_ENABLED == ENABLED
    // this allows us to detect the user wanting the CLI to start
    uint8_t        crlf_count;
#endif

    // waypoints
    uint16_t        waypoint_request_i; // request index
    uint16_t        waypoint_dest_sysid; // where to send requests
    uint16_t        waypoint_dest_compid; // "
    bool            waypoint_sending; // currently in send process
    bool            waypoint_receiving; // currently receiving
    uint16_t        waypoint_count;
    uint32_t        waypoint_timelast_send; // milliseconds
    uint32_t        waypoint_timelast_receive; // milliseconds
    uint32_t        waypoint_timelast_request; // milliseconds
    uint16_t        waypoint_send_timeout; // milliseconds
    uint16_t        waypoint_receive_timeout; // milliseconds

    // data stream rates. The code assumes that
    // streamRateRawSensors is the first
    AP_Int16        streamRateRawSensors;
    AP_Int16        streamRateExtendedStatus;
    AP_Int16        streamRateRCChannels;
    AP_Int16        streamRateRawController;
    AP_Int16        streamRatePosition;
    AP_Int16        streamRateExtra1;
    AP_Int16        streamRateExtra2;
    AP_Int16        streamRateExtra3;
    AP_Int16        streamRateParams;

    // number of 50Hz ticks until we next send this stream
    uint8_t         stream_ticks[NUM_STREAMS];

    // number of extra ticks to add to slow things down for the radio
    uint8_t         stream_slowdown;
};

#endif // __GCS_H
// -*- tab-width: 4; Mode: C++; c-basic-offset: 4; indent-tabs-mode: nil -*-

// use this to prevent recursion during sensor init
static bool in_mavlink_delay;


// this costs us 51 bytes, but means that low priority
// messages don't block the CPU
static mavlink_statustext_t pending_status;

// true when we have received at least 1 MAVLink packet
static bool mavlink_active;


// check if a message will fit in the payload space available
#define CHECK_PAYLOAD_SIZE(id) if (payload_space < MAVLINK_MSG_ID_ ## id ## _LEN) return false

// prototype this for use inside the GCS class
static void gcs_send_text_fmt(const prog_char_t *fmt, ...);

/*
 *  !!NOTE!!
 *
 *  the use of NOINLINE separate functions for each message type avoids
 *  a compiler bug in gcc that would cause it to use far more stack
 *  space than is needed. Without the NOINLINE we use the sum of the
 *  stack needed for each message type. Please be careful to follow the
 *  pattern below when adding any new messages
 */

static NOINLINE void send_heartbeat(mavlink_channel_t chan)
{
    uint8_t base_mode = MAV_MODE_FLAG_CUSTOM_MODE_ENABLED;
    uint8_t system_status = MAV_STATE_ACTIVE;
    uint32_t custom_mode = control_mode;

    // work out the base_mode. This value is not very useful
    // for APM, but we calculate it as best we can so a generic
    // MAVLink enabled ground station can work out something about
    // what the MAV is up to. The actual bit values are highly
    // ambiguous for most of the APM flight modes. In practice, you
    // only get useful information from the custom_mode, which maps to
    // the APM flight mode and has a well defined meaning in the
    // ArduPlane documentation
    base_mode = MAV_MODE_FLAG_STABILIZE_ENABLED;
    switch (control_mode) {
    case AUTO:
    case RTL:
    case LOITER:
    case GUIDED:
    case CIRCLE:
        base_mode |= MAV_MODE_FLAG_GUIDED_ENABLED;
        // note that MAV_MODE_FLAG_AUTO_ENABLED does not match what
        // APM does in any mode, as that is defined as "system finds its own goal
        // positions", which APM does not currently do
        break;
    }

    // all modes except INITIALISING have some form of manual
    // override if stick mixing is enabled
    base_mode |= MAV_MODE_FLAG_MANUAL_INPUT_ENABLED;

#if HIL_MODE != HIL_MODE_DISABLED
    base_mode |= MAV_MODE_FLAG_HIL_ENABLED;
#endif

    // we are armed if we are not initialising
    if (motors.armed()) {
        base_mode |= MAV_MODE_FLAG_SAFETY_ARMED;
    }

    // indicate we have set a custom mode
    base_mode |= MAV_MODE_FLAG_CUSTOM_MODE_ENABLED;

    mavlink_msg_heartbeat_send(
        chan,
        MAV_TYPE_QUADROTOR,
        MAV_AUTOPILOT_ARDUPILOTMEGA,
        base_mode,
        custom_mode,
        system_status);
}

static NOINLINE void send_attitude(mavlink_channel_t chan)
{
    mavlink_msg_attitude_send(
        chan,
        millis(),
        ahrs.roll,
        ahrs.pitch,
        ahrs.yaw,
        omega.x,
        omega.y,
        omega.z);
}

#if AP_LIMITS == ENABLED
static NOINLINE void send_limits_status(mavlink_channel_t chan)
{
    limits_send_mavlink_status(chan);
}
#endif


static NOINLINE void send_extended_status1(mavlink_channel_t chan, uint16_t packet_drops)
{
    uint32_t control_sensors_present = 0;
    uint32_t control_sensors_enabled;
    uint32_t control_sensors_health;

    // first what sensors/controllers we have
    control_sensors_present |= (1<<0); // 3D gyro present
    control_sensors_present |= (1<<1); // 3D accelerometer present
    if (g.compass_enabled) {
        control_sensors_present |= (1<<2); // compass present
    }
    control_sensors_present |= (1<<3); // absolute pressure sensor present
    if (g_gps != NULL && g_gps->status() == GPS::GPS_OK) {
        control_sensors_present |= (1<<5); // GPS present
    }
    control_sensors_present |= (1<<10); // 3D angular rate control
    control_sensors_present |= (1<<11); // attitude stabilisation
    control_sensors_present |= (1<<12); // yaw position
    control_sensors_present |= (1<<13); // altitude control
    control_sensors_present |= (1<<14); // X/Y position control
    control_sensors_present |= (1<<15); // motor control

    // now what sensors/controllers are enabled

    // first the sensors
    control_sensors_enabled = control_sensors_present & 0x1FF;

    // now the controllers
    control_sensors_enabled = control_sensors_present & 0x1FF;

    control_sensors_enabled |= (1<<10); // 3D angular rate control
    control_sensors_enabled |= (1<<11); // attitude stabilisation
    control_sensors_enabled |= (1<<13); // altitude control
    control_sensors_enabled |= (1<<15); // motor control

    switch (control_mode) {
    case AUTO:
    case RTL:
    case LOITER:
    case GUIDED:
    case CIRCLE:
    case POSITION:
        control_sensors_enabled |= (1<<12); // yaw position
        control_sensors_enabled |= (1<<14); // X/Y position control
        break;
    }

    // at the moment all sensors/controllers are assumed healthy
    control_sensors_health = control_sensors_present;

    uint16_t battery_current = -1;
    uint8_t battery_remaining = -1;

    if (current_total1 != 0 && g.pack_capacity != 0) {
        battery_remaining = (100.0 * (g.pack_capacity - current_total1) / g.pack_capacity);
    }
    if (current_total1 != 0) {
        battery_current = current_amps1 * 100;
    }

    if (g.battery_monitoring == 3) {
        /*setting a out-of-range value.
         *  It informs to external devices that
         *  it cannot be calculated properly just by voltage*/
        battery_remaining = 150;
    }

    mavlink_msg_sys_status_send(
        chan,
        control_sensors_present,
        control_sensors_enabled,
        control_sensors_health,
        0, // CPU Load not supported in AC yet
        battery_voltage1 * 1000, // mV
        battery_current,        // in 10mA units
        battery_remaining,      // in %
        0, // comm drops %,
        0, // comm drops in pkts,
        0, 0, 0, 0);

}

static void NOINLINE send_meminfo(mavlink_channel_t chan)
{
    extern unsigned __brkval;
    mavlink_msg_meminfo_send(chan, __brkval, memcheck_available_memory());
}

static void NOINLINE send_location(mavlink_channel_t chan)
{
    Matrix3f rot = ahrs.get_dcm_matrix(); // neglecting angle of attack for now
    mavlink_msg_global_position_int_send(
        chan,
        millis(),
        current_loc.lat,                // in 1E7 degrees
        current_loc.lng,                // in 1E7 degrees
        g_gps->altitude * 10,             // millimeters above sea level
        (current_loc.alt - home.alt) * 10,           // millimeters above ground
        g_gps->ground_speed * rot.a.x,  // X speed cm/s
        g_gps->ground_speed * rot.b.x,  // Y speed cm/s
        g_gps->ground_speed * rot.c.x,
        g_gps->ground_course);          // course in 1/100 degree
}

static void NOINLINE send_nav_controller_output(mavlink_channel_t chan)
{
    mavlink_msg_nav_controller_output_send(
        chan,
        nav_roll / 1.0e2,
        nav_pitch / 1.0e2,
        target_bearing / 1.0e2,
        target_bearing / 1.0e2,
        wp_distance / 1.0e2,
        altitude_error / 1.0e2,
        0,
        crosstrack_error);      // was 0
}

static void NOINLINE send_ahrs(mavlink_channel_t chan)
{
    Vector3f omega_I = ahrs.get_gyro_drift();
    mavlink_msg_ahrs_send(
        chan,
        omega_I.x,
        omega_I.y,
        omega_I.z,
        1,
        0,
        ahrs.get_error_rp(),
        ahrs.get_error_yaw());
}

#ifdef DESKTOP_BUILD
// report simulator state
static void NOINLINE send_simstate(mavlink_channel_t chan)
{
    sitl.simstate_send(chan);
}
#endif

#ifndef DESKTOP_BUILD
static void NOINLINE send_hwstatus(mavlink_channel_t chan)
{
    mavlink_msg_hwstatus_send(
        chan,
        board_voltage(),
        I2c.lockup_count());
}
#endif


static void NOINLINE send_gps_raw(mavlink_channel_t chan)
{
    uint8_t fix = g_gps->status();
    if (fix == GPS::GPS_OK) {
        fix = 3;
    }

    mavlink_msg_gps_raw_int_send(
        chan,
        g_gps->last_fix_time*(uint64_t)1000,
        fix,
        g_gps->latitude,      // in 1E7 degrees
        g_gps->longitude,     // in 1E7 degrees
        g_gps->altitude * 10, // in mm
        g_gps->hdop,
        65535,
        g_gps->ground_speed,  // cm/s
        g_gps->ground_course, // 1/100 degrees,
        g_gps->num_sats);

}

static void NOINLINE send_servo_out(mavlink_channel_t chan)
{
    const uint8_t rssi = 1;
    // normalized values scaled to -10000 to 10000
    // This is used for HIL.  Do not change without discussing with HIL maintainers

#if FRAME_CONFIG == HELI_FRAME

    mavlink_msg_rc_channels_scaled_send(
        chan,
        millis(),
        0, // port 0
        g.rc_1.servo_out,
        g.rc_2.servo_out,
        g.rc_3.radio_out,
        g.rc_4.servo_out,
        0,
        0,
        0,
        0,
        rssi);
#else
 #if X_PLANE == ENABLED
    /* update by JLN for X-Plane HIL */
    if(motors.armed() && motors.auto_armed()) {
        mavlink_msg_rc_channels_scaled_send(
            chan,
            millis(),
            0,         // port 0
            g.rc_1.servo_out,
            g.rc_2.servo_out,
            10000 * g.rc_3.norm_output(),
            g.rc_4.servo_out,
            10000 * g.rc_1.norm_output(),
            10000 * g.rc_2.norm_output(),
            10000 * g.rc_3.norm_output(),
            10000 * g.rc_4.norm_output(),
            rssi);
    }else{
        mavlink_msg_rc_channels_scaled_send(
            chan,
            millis(),
            0,         // port 0
            0,
            0,
            -10000,
            0,
            10000 * g.rc_1.norm_output(),
            10000 * g.rc_2.norm_output(),
            10000 * g.rc_3.norm_output(),
            10000 * g.rc_4.norm_output(),
            rssi);
    }

 #else
    mavlink_msg_rc_channels_scaled_send(
        chan,
        millis(),
        0,         // port 0
        g.rc_1.servo_out,
        g.rc_2.servo_out,
        g.rc_3.radio_out,
        g.rc_4.servo_out,
        10000 * g.rc_1.norm_output(),
        10000 * g.rc_2.norm_output(),
        10000 * g.rc_3.norm_output(),
        10000 * g.rc_4.norm_output(),
        rssi);
 #endif
#endif
}

static void NOINLINE send_radio_in(mavlink_channel_t chan)
{
    const uint8_t rssi = 1;
    mavlink_msg_rc_channels_raw_send(
        chan,
        millis(),
        0, // port
        g.rc_1.radio_in,
        g.rc_2.radio_in,
        g.rc_3.radio_in,
        g.rc_4.radio_in,
        g.rc_5.radio_in,
        g.rc_6.radio_in,
        g.rc_7.radio_in,
        g.rc_8.radio_in,
        rssi);
}

static void NOINLINE send_radio_out(mavlink_channel_t chan)
{
    mavlink_msg_servo_output_raw_send(
        chan,
        micros(),
        0, // port
        motors.motor_out[AP_MOTORS_MOT_1],
        motors.motor_out[AP_MOTORS_MOT_2],
        motors.motor_out[AP_MOTORS_MOT_3],
        motors.motor_out[AP_MOTORS_MOT_4],
        motors.motor_out[AP_MOTORS_MOT_5],
        motors.motor_out[AP_MOTORS_MOT_6],
        motors.motor_out[AP_MOTORS_MOT_7],
        motors.motor_out[AP_MOTORS_MOT_8]);
}

static void NOINLINE send_vfr_hud(mavlink_channel_t chan)
{
    mavlink_msg_vfr_hud_send(
        chan,
        (float)g_gps->ground_speed / 100.0,
        (float)g_gps->ground_speed / 100.0,
        (ahrs.yaw_sensor / 100) % 360,
        g.rc_3.servo_out/10,
        current_loc.alt / 100.0,
        climb_rate / 100.0);
}

static void NOINLINE send_raw_imu1(mavlink_channel_t chan)
{
    Vector3f accel = imu.get_accel();
    Vector3f gyro = imu.get_gyro();
    mavlink_msg_raw_imu_send(
        chan,
        micros(),
        accel.x * 1000.0 / gravity,
        accel.y * 1000.0 / gravity,
        accel.z * 1000.0 / gravity,
        gyro.x * 1000.0,
        gyro.y * 1000.0,
        gyro.z * 1000.0,
        compass.mag_x,
        compass.mag_y,
        compass.mag_z);
}

static void NOINLINE send_raw_imu2(mavlink_channel_t chan)
{
    mavlink_msg_scaled_pressure_send(
        chan,
        millis(),
        (float)barometer.get_pressure()/100.0,
        (float)(barometer.get_pressure() - barometer.get_ground_pressure())/100.0,
        (int)(barometer.get_temperature()*10));
}

static void NOINLINE send_raw_imu3(mavlink_channel_t chan)
{
    Vector3f mag_offsets = compass.get_offsets();

    mavlink_msg_sensor_offsets_send(chan,
                                    mag_offsets.x,
                                    mag_offsets.y,
                                    mag_offsets.z,
                                    compass.get_declination(),
                                    barometer.get_raw_pressure(),
                                    barometer.get_raw_temp(),
                                    imu.gx(), imu.gy(), imu.gz(),
                                    imu.ax(), imu.ay(), imu.az());
}

static void NOINLINE send_gps_status(mavlink_channel_t chan)
{
    mavlink_msg_gps_status_send(
        chan,
        g_gps->num_sats,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL);
}

static void NOINLINE send_current_waypoint(mavlink_channel_t chan)
{
    mavlink_msg_mission_current_send(
        chan,
        (uint16_t)g.command_index);
}

static void NOINLINE send_statustext(mavlink_channel_t chan)
{
    mavlink_msg_statustext_send(
        chan,
        pending_status.severity,
        pending_status.text);
}

// are we still delaying telemetry to try to avoid Xbee bricking?
static bool telemetry_delayed(mavlink_channel_t chan)
{
    uint32_t tnow = millis() >> 10;
    if (tnow > (uint8_t)g.telem_delay) {
        return false;
    }
#if USB_MUX_PIN > 0
    if (chan == MAVLINK_COMM_0 && usb_connected) {
        // this is an APM2 with USB telemetry
        return false;
    }
    // we're either on the 2nd UART, or no USB cable is connected
    // we need to delay telemetry
    return true;
#else
    if (chan == MAVLINK_COMM_0) {
        // we're on the USB port
        return false;
    }
    // don't send telemetry yet
    return true;
#endif
}


// try to send a message, return false if it won't fit in the serial tx buffer
static bool mavlink_try_send_message(mavlink_channel_t chan, enum ap_message id, uint16_t packet_drops)
{
    int16_t payload_space = comm_get_txspace(chan) - MAVLINK_NUM_NON_PAYLOAD_BYTES;

    if (telemetry_delayed(chan)) {
        return false;
    }

    switch(id) {
    case MSG_HEARTBEAT:
        CHECK_PAYLOAD_SIZE(HEARTBEAT);
        send_heartbeat(chan);
        return true;

    case MSG_EXTENDED_STATUS1:
        CHECK_PAYLOAD_SIZE(SYS_STATUS);
        send_extended_status1(chan, packet_drops);
        break;

    case MSG_EXTENDED_STATUS2:
        CHECK_PAYLOAD_SIZE(MEMINFO);
        send_meminfo(chan);
        break;

    case MSG_ATTITUDE:
        CHECK_PAYLOAD_SIZE(ATTITUDE);
        send_attitude(chan);
        break;

    case MSG_LOCATION:
        CHECK_PAYLOAD_SIZE(GLOBAL_POSITION_INT);
        send_location(chan);
        break;

    case MSG_NAV_CONTROLLER_OUTPUT:
        CHECK_PAYLOAD_SIZE(NAV_CONTROLLER_OUTPUT);
        send_nav_controller_output(chan);
        break;

    case MSG_GPS_RAW:
        CHECK_PAYLOAD_SIZE(GPS_RAW_INT);
        send_gps_raw(chan);
        break;

    case MSG_SERVO_OUT:
        CHECK_PAYLOAD_SIZE(RC_CHANNELS_SCALED);
        send_servo_out(chan);
        break;

    case MSG_RADIO_IN:
        CHECK_PAYLOAD_SIZE(RC_CHANNELS_RAW);
        send_radio_in(chan);
        break;

    case MSG_RADIO_OUT:
        CHECK_PAYLOAD_SIZE(SERVO_OUTPUT_RAW);
        send_radio_out(chan);
        break;

    case MSG_VFR_HUD:
        CHECK_PAYLOAD_SIZE(VFR_HUD);
        send_vfr_hud(chan);
        break;

    case MSG_RAW_IMU1:
        CHECK_PAYLOAD_SIZE(RAW_IMU);
        send_raw_imu1(chan);
        break;

    case MSG_RAW_IMU2:
        CHECK_PAYLOAD_SIZE(SCALED_PRESSURE);
        send_raw_imu2(chan);
        break;

    case MSG_RAW_IMU3:
        CHECK_PAYLOAD_SIZE(SENSOR_OFFSETS);
        send_raw_imu3(chan);
        break;

    case MSG_GPS_STATUS:
        CHECK_PAYLOAD_SIZE(GPS_STATUS);
        send_gps_status(chan);
        break;

    case MSG_CURRENT_WAYPOINT:
        CHECK_PAYLOAD_SIZE(MISSION_CURRENT);
        send_current_waypoint(chan);
        break;

    case MSG_NEXT_PARAM:
        CHECK_PAYLOAD_SIZE(PARAM_VALUE);
        if (chan == MAVLINK_COMM_0) {
            gcs0.queued_param_send();
        } else if (gcs3.initialised) {
            gcs3.queued_param_send();
        }
        break;

    case MSG_NEXT_WAYPOINT:
        CHECK_PAYLOAD_SIZE(MISSION_REQUEST);
        if (chan == MAVLINK_COMM_0) {
            gcs0.queued_waypoint_send();
        } else {
            gcs3.queued_waypoint_send();
        }
        break;

    case MSG_STATUSTEXT:
        CHECK_PAYLOAD_SIZE(STATUSTEXT);
        send_statustext(chan);
        break;

#if AP_LIMITS == ENABLED

    case MSG_LIMITS_STATUS:
        CHECK_PAYLOAD_SIZE(LIMITS_STATUS);
        send_limits_status(chan);
        break;

#endif

    case MSG_AHRS:
        CHECK_PAYLOAD_SIZE(AHRS);
        send_ahrs(chan);
        break;

    case MSG_SIMSTATE:
#ifdef DESKTOP_BUILD
        CHECK_PAYLOAD_SIZE(SIMSTATE);
        send_simstate(chan);
#endif
        break;

    case MSG_HWSTATUS:
#ifndef DESKTOP_BUILD
        CHECK_PAYLOAD_SIZE(HWSTATUS);
        send_hwstatus(chan);
#endif
        break;

    case MSG_RETRY_DEFERRED:
        break; // just here to prevent a warning
    }
    return true;
}


#define MAX_DEFERRED_MESSAGES MSG_RETRY_DEFERRED
static struct mavlink_queue {
    enum ap_message deferred_messages[MAX_DEFERRED_MESSAGES];
    uint8_t next_deferred_message;
    uint8_t num_deferred_messages;
} mavlink_queue[2];

// send a message using mavlink
static void mavlink_send_message(mavlink_channel_t chan, enum ap_message id, uint16_t packet_drops)
{
    uint8_t i, nextid;
    struct mavlink_queue *q = &mavlink_queue[(uint8_t)chan];

    // see if we can send the deferred messages, if any
    while (q->num_deferred_messages != 0) {
        if (!mavlink_try_send_message(chan,
                                      q->deferred_messages[q->next_deferred_message],
                                      packet_drops)) {
            break;
        }
        q->next_deferred_message++;
        if (q->next_deferred_message == MAX_DEFERRED_MESSAGES) {
            q->next_deferred_message = 0;
        }
        q->num_deferred_messages--;
    }

    if (id == MSG_RETRY_DEFERRED) {
        return;
    }

    // this message id might already be deferred
    for (i=0, nextid = q->next_deferred_message; i < q->num_deferred_messages; i++) {
        if (q->deferred_messages[nextid] == id) {
            // its already deferred, discard
            return;
        }
        nextid++;
        if (nextid == MAX_DEFERRED_MESSAGES) {
            nextid = 0;
        }
    }

    if (q->num_deferred_messages != 0 ||
        !mavlink_try_send_message(chan, id, packet_drops)) {
        // can't send it now, so defer it
        if (q->num_deferred_messages == MAX_DEFERRED_MESSAGES) {
            // the defer buffer is full, discard
            return;
        }
        nextid = q->next_deferred_message + q->num_deferred_messages;
        if (nextid >= MAX_DEFERRED_MESSAGES) {
            nextid -= MAX_DEFERRED_MESSAGES;
        }
        q->deferred_messages[nextid] = id;
        q->num_deferred_messages++;
    }
}

void mavlink_send_text(mavlink_channel_t chan, gcs_severity severity, const char *str)
{
    if (telemetry_delayed(chan)) {
        return;
    }

    if (severity == SEVERITY_LOW) {
        // send via the deferred queuing system
        pending_status.severity = (uint8_t)severity;
        strncpy((char *)pending_status.text, str, sizeof(pending_status.text));
        mavlink_send_message(chan, MSG_STATUSTEXT, 0);
    } else {
        // send immediately
        mavlink_msg_statustext_send(
            chan,
            severity,
            str);
    }
}

const AP_Param::GroupInfo GCS_MAVLINK::var_info[] PROGMEM = {
    AP_GROUPINFO("RAW_SENS", 0, GCS_MAVLINK, streamRateRawSensors,      0),
    AP_GROUPINFO("EXT_STAT", 1, GCS_MAVLINK, streamRateExtendedStatus,  0),
    AP_GROUPINFO("RC_CHAN",  2, GCS_MAVLINK, streamRateRCChannels,      0),
    AP_GROUPINFO("RAW_CTRL", 3, GCS_MAVLINK, streamRateRawController,   0),
    AP_GROUPINFO("POSITION", 4, GCS_MAVLINK, streamRatePosition,        0),
    AP_GROUPINFO("EXTRA1",   5, GCS_MAVLINK, streamRateExtra1,          0),
    AP_GROUPINFO("EXTRA2",   6, GCS_MAVLINK, streamRateExtra2,          0),
    AP_GROUPINFO("EXTRA3",   7, GCS_MAVLINK, streamRateExtra3,          0),
    AP_GROUPINFO("PARAMS",   8, GCS_MAVLINK, streamRateParams,          0),
    AP_GROUPEND
};


GCS_MAVLINK::GCS_MAVLINK() :
    packet_drops(0),
    waypoint_send_timeout(1000), // 1 second
    waypoint_receive_timeout(1000) // 1 second
{

}

void
GCS_MAVLINK::init(FastSerial * port)
{
    GCS_Class::init(port);
    if (port == &Serial) {
        mavlink_comm_0_port = port;
        chan = MAVLINK_COMM_0;
    }else{
        mavlink_comm_1_port = port;
        chan = MAVLINK_COMM_1;
    }
    _queued_parameter = NULL;
}

void
GCS_MAVLINK::update(void)
{
    // receive new packets
    mavlink_message_t msg;
    mavlink_status_t status;
    status.packet_rx_drop_count = 0;

    // process received bytes
    while(comm_get_available(chan))
    {
        uint8_t c = comm_receive_ch(chan);

#if CLI_ENABLED == ENABLED
        /* allow CLI to be started by hitting enter 3 times, if no
         *  heartbeat packets have been received */
        if (mavlink_active == false) {
            if (c == '\n' || c == '\r') {
                crlf_count++;
            } else {
                crlf_count = 0;
            }
            if (crlf_count == 3) {
                run_cli();
            }
        }
#endif

        // Try to get a new message
        if (mavlink_parse_char(chan, c, &msg, &status)) {
            mavlink_active = true;
            handleMessage(&msg);
        }
    }

    // Update packet drops counter
    packet_drops += status.packet_rx_drop_count;

    if (!waypoint_receiving && !waypoint_sending) {
        return;
    }

    uint32_t tnow = millis();

    if (waypoint_receiving &&
        waypoint_request_i <= (unsigned)g.command_total &&
        tnow > waypoint_timelast_request + 500 + (stream_slowdown*20)) {
        waypoint_timelast_request = tnow;
        send_message(MSG_NEXT_WAYPOINT);
    }

    // stop waypoint sending if timeout
    if (waypoint_sending && (tnow - waypoint_timelast_send) > waypoint_send_timeout) {
        waypoint_sending = false;
    }

    // stop waypoint receiving if timeout
    if (waypoint_receiving && (tnow - waypoint_timelast_receive) > waypoint_receive_timeout) {
        waypoint_receiving = false;
    }
}

// see if we should send a stream now. Called at 50Hz
bool GCS_MAVLINK::stream_trigger(enum streams stream_num)
{
    AP_Int16 *stream_rates = &streamRateRawSensors;
    uint8_t rate = (uint8_t)stream_rates[stream_num].get();

    if (rate == 0) {
        return false;
    }

    if (stream_ticks[stream_num] == 0) {
        // we're triggering now, setup the next trigger point
        if (rate > 50) {
            rate = 50;
        }
        stream_ticks[stream_num] = (50 / rate) + stream_slowdown;
        return true;
    }

    // count down at 50Hz
    stream_ticks[stream_num]--;
    return false;
}

void
GCS_MAVLINK::data_stream_send(void)
{
    if (waypoint_receiving || waypoint_sending) {
        // don't interfere with mission transfer
        return;
    }

    if (_queued_parameter != NULL) {
        if (streamRateParams.get() <= 0) {
            streamRateParams.set(50);
        }
        if (stream_trigger(STREAM_PARAMS)) {
            send_message(MSG_NEXT_PARAM);
        }
        // don't send anything else at the same time as parameters
        return;
    }

    if (in_mavlink_delay) {
        // don't send any other stream types while in the delay callback
        return;
    }

    if (stream_trigger(STREAM_RAW_SENSORS)) {
        send_message(MSG_RAW_IMU1);
        send_message(MSG_RAW_IMU2);
        send_message(MSG_RAW_IMU3);
        //Serial.printf("mav1 %d\n", (int)streamRateRawSensors.get());
    }

    if (stream_trigger(STREAM_EXTENDED_STATUS)) {
        send_message(MSG_EXTENDED_STATUS1);
        send_message(MSG_EXTENDED_STATUS2);
        send_message(MSG_CURRENT_WAYPOINT);
        send_message(MSG_GPS_RAW);                                      // TODO - remove this message after location message is working
        send_message(MSG_NAV_CONTROLLER_OUTPUT);
        send_message(MSG_LIMITS_STATUS);


        if (last_gps_satellites != g_gps->num_sats) {
            // this message is mostly a huge waste of bandwidth,
            // except it is the only message that gives the number
            // of visible satellites. So only send it when that
            // changes.
            send_message(MSG_GPS_STATUS);
            last_gps_satellites = g_gps->num_sats;
        }
    }

    if (stream_trigger(STREAM_POSITION)) {
        // sent with GPS read
        //Serial.printf("mav3 %d\n", (int)streamRatePosition.get());
    }

    if (stream_trigger(STREAM_RAW_CONTROLLER)) {
        send_message(MSG_SERVO_OUT);
        //Serial.printf("mav4 %d\n", (int)streamRateRawController.get());
    }

    if (stream_trigger(STREAM_RC_CHANNELS)) {
        send_message(MSG_RADIO_OUT);
        send_message(MSG_RADIO_IN);
        //Serial.printf("mav5 %d\n", (int)streamRateRCChannels.get());
    }

    if (stream_trigger(STREAM_EXTRA1)) {
        send_message(MSG_ATTITUDE);
        send_message(MSG_SIMSTATE);
        //Serial.printf("mav6 %d\n", (int)streamRateExtra1.get());
    }

    if (stream_trigger(STREAM_EXTRA2)) {
        send_message(MSG_VFR_HUD);
        //Serial.printf("mav7 %d\n", (int)streamRateExtra2.get());
    }

    if (stream_trigger(STREAM_EXTRA3)) {
        send_message(MSG_AHRS);
        send_message(MSG_HWSTATUS);
    }
}



void
GCS_MAVLINK::send_message(enum ap_message id)
{
    mavlink_send_message(chan,id, packet_drops);
}

void
GCS_MAVLINK::send_text(gcs_severity severity, const char *str)
{
    mavlink_send_text(chan,severity,str);
}

void
GCS_MAVLINK::send_text(gcs_severity severity, const prog_char_t *str)
{
    mavlink_statustext_t m;
    uint8_t i;
    for (i=0; i<sizeof(m.text); i++) {
        m.text[i] = pgm_read_byte((const prog_char *)(str++));
    }
    if (i < sizeof(m.text)) m.text[i] = 0;
    mavlink_send_text(chan, severity, (const char *)m.text);
}

void GCS_MAVLINK::handleMessage(mavlink_message_t* msg)
{
    struct Location tell_command = {};                                  // command for telemetry
    switch (msg->msgid) {

    case MAVLINK_MSG_ID_REQUEST_DATA_STREAM:     //66
    {
        // decode
        mavlink_request_data_stream_t packet;
        mavlink_msg_request_data_stream_decode(msg, &packet);

        if (mavlink_check_target(packet.target_system, packet.target_component))
            break;

        int16_t freq = 0;                 // packet frequency

        if (packet.start_stop == 0)
            freq = 0;                     // stop sending
        else if (packet.start_stop == 1)
            freq = packet.req_message_rate;                     // start sending
        else
            break;

        switch(packet.req_stream_id) {

        case MAV_DATA_STREAM_ALL:
            streamRateRawSensors            = freq;
            streamRateExtendedStatus        = freq;
            streamRateRCChannels            = freq;
            streamRateRawController         = freq;
            streamRatePosition                      = freq;
            streamRateExtra1                        = freq;
            streamRateExtra2                        = freq;
            //streamRateExtra3.set_and_save(freq);	// We just do set and save on the last as it takes care of the whole group.
            streamRateExtra3                        = freq;                             // Don't save!!
            break;

        case MAV_DATA_STREAM_RAW_SENSORS:
            streamRateRawSensors = freq;                                        // We do not set and save this one so that if HIL is shut down incorrectly
            // we will not continue to broadcast raw sensor data at 50Hz.
            break;
        case MAV_DATA_STREAM_EXTENDED_STATUS:
            //streamRateExtendedStatus.set_and_save(freq);
            streamRateExtendedStatus = freq;
            break;

        case MAV_DATA_STREAM_RC_CHANNELS:
            streamRateRCChannels  = freq;
            break;

        case MAV_DATA_STREAM_RAW_CONTROLLER:
            streamRateRawController = freq;
            break;

        //case MAV_DATA_STREAM_RAW_SENSOR_FUSION:
        //	streamRateRawSensorFusion.set_and_save(freq);
        //	break;

        case MAV_DATA_STREAM_POSITION:
            streamRatePosition = freq;
            break;

        case MAV_DATA_STREAM_EXTRA1:
            streamRateExtra1 = freq;
            break;

        case MAV_DATA_STREAM_EXTRA2:
            streamRateExtra2 = freq;
            break;

        case MAV_DATA_STREAM_EXTRA3:
            streamRateExtra3 = freq;
            break;

        default:
            break;
        }
        break;
    }

    case MAVLINK_MSG_ID_COMMAND_LONG:
    {
        // decode
        mavlink_command_long_t packet;
        mavlink_msg_command_long_decode(msg, &packet);
        if (mavlink_check_target(packet.target_system, packet.target_component)) break;

        uint8_t result;

        // do command
        send_text(SEVERITY_LOW,PSTR("command received: "));

        switch(packet.command) {

        case MAV_CMD_NAV_LOITER_UNLIM:
            set_mode(LOITER);
            result = MAV_RESULT_ACCEPTED;
            break;

        case MAV_CMD_NAV_RETURN_TO_LAUNCH:
            set_mode(RTL);
            result = MAV_RESULT_ACCEPTED;
            break;

        case MAV_CMD_NAV_LAND:
            set_mode(LAND);
            result = MAV_RESULT_ACCEPTED;
            break;

        case MAV_CMD_MISSION_START:
            set_mode(AUTO);
            result = MAV_RESULT_ACCEPTED;
            break;

        case MAV_CMD_PREFLIGHT_CALIBRATION:
            if (packet.param1 == 1 ||
                packet.param2 == 1 ||
                packet.param3 == 1) {
                imu.init_accel(mavlink_delay, flash_leds);
            }
            if (packet.param4 == 1) {
                trim_radio();
            }
            result = MAV_RESULT_ACCEPTED;
            break;

        case MAV_CMD_COMPONENT_ARM_DISARM:
            if (packet.target_component == MAV_COMP_ID_SYSTEM_CONTROL) {
                if (packet.param1 == 1.0f) {
                    init_arm_motors();
                    result = MAV_RESULT_ACCEPTED;
                } else if (packet.param1 == 0.0f)  {
                    init_disarm_motors();
                    result = MAV_RESULT_ACCEPTED;
                } else {
                    result = MAV_RESULT_UNSUPPORTED;
                }
            } else {
                result = MAV_RESULT_UNSUPPORTED;
            }
            break;
        default:
            result = MAV_RESULT_UNSUPPORTED;
            break;
        }

        mavlink_msg_command_ack_send(
            chan,
            packet.command,
            result);

        break;
    }

    case MAVLINK_MSG_ID_SET_MODE:      //11
    {
        // decode
        mavlink_set_mode_t packet;
        mavlink_msg_set_mode_decode(msg, &packet);

        if (!(packet.base_mode & MAV_MODE_FLAG_CUSTOM_MODE_ENABLED)) {
            // we ignore base_mode as there is no sane way to map
            // from that bitmap to a APM flight mode. We rely on
            // custom_mode instead.
            break;
        }
        switch (packet.custom_mode) {
        case STABILIZE:
        case ACRO:
        case ALT_HOLD:
        case AUTO:
        case GUIDED:
        case LOITER:
        case RTL:
        case CIRCLE:
        case POSITION:
        case LAND:
        case OF_LOITER:
            set_mode(packet.custom_mode);
            break;
        }

        break;
    }

    /*case MAVLINK_MSG_ID_SET_NAV_MODE:
     *       {
     *               // decode
     *               mavlink_set_nav_mode_t packet;
     *               mavlink_msg_set_nav_mode_decode(msg, &packet);
     *               // To set some flight modes we must first receive a "set nav mode" message and then a "set mode" message
     *               mav_nav = packet.nav_mode;
     *               break;
     *       }
     */
    case MAVLINK_MSG_ID_MISSION_REQUEST_LIST:     //43
    {
        //send_text_P(SEVERITY_LOW,PSTR("waypoint request list"));

        // decode
        mavlink_mission_request_list_t packet;
        mavlink_msg_mission_request_list_decode(msg, &packet);
        if (mavlink_check_target(packet.target_system, packet.target_component))
            break;

        // Start sending waypoints
        mavlink_msg_mission_count_send(
            chan,msg->sysid,
            msg->compid,
            g.command_total);                     // includes home

        waypoint_timelast_send          = millis();
        waypoint_sending                        = true;
        waypoint_receiving                      = false;
        waypoint_dest_sysid                     = msg->sysid;
        waypoint_dest_compid            = msg->compid;
        break;
    }

    // XXX read a WP from EEPROM and send it to the GCS
    case MAVLINK_MSG_ID_MISSION_REQUEST:     // 40
    {
        //send_text_P(SEVERITY_LOW,PSTR("waypoint request"));

        // Check if sending waypiont
        //if (!waypoint_sending) break;
        // 5/10/11 - We are trying out relaxing the requirement that we be in waypoint sending mode to respond to a waypoint request.  DEW

        // decode
        mavlink_mission_request_t packet;
        mavlink_msg_mission_request_decode(msg, &packet);

        if (mavlink_check_target(packet.target_system, packet.target_component))
            break;

        // send waypoint
        tell_command = get_cmd_with_index(packet.seq);

        // set frame of waypoint
        uint8_t frame;

        if (tell_command.options & MASK_OPTIONS_RELATIVE_ALT) {
            frame = MAV_FRAME_GLOBAL_RELATIVE_ALT;                     // reference frame
        } else {
            frame = MAV_FRAME_GLOBAL;                     // reference frame
        }

        float param1 = 0, param2 = 0, param3 = 0, param4 = 0;

        // time that the mav should loiter in milliseconds
        uint8_t current = 0;                 // 1 (true), 0 (false)

        if (packet.seq == (uint16_t)g.command_index)
            current = 1;

        uint8_t autocontinue = 1;                 // 1 (true), 0 (false)

        float x = 0, y = 0, z = 0;

        if (tell_command.id < MAV_CMD_NAV_LAST) {
            // command needs scaling
            x = tell_command.lat/1.0e7;                     // local (x), global (latitude)
            y = tell_command.lng/1.0e7;                     // local (y), global (longitude)
            // ACM is processing alt inside each command. so we save and load raw values. - this is diffrent to APM
            z = tell_command.alt/1.0e2;                     // local (z), global/relative (altitude)
        }

        // Switch to map APM command fields into MAVLink command fields
        switch (tell_command.id) {

        case MAV_CMD_NAV_LOITER_TURNS:
        case MAV_CMD_CONDITION_CHANGE_ALT:
        case MAV_CMD_DO_SET_HOME:
            param1 = tell_command.p1;
            break;

        case MAV_CMD_NAV_ROI:
            param1 = tell_command.p1;                                   // MAV_ROI (aka roi mode) is held in wp's parameter but we actually do nothing with it because we only support pointing at a specific location provided by x,y and z parameters
            break;

        case MAV_CMD_CONDITION_YAW:
            param3 = tell_command.p1;
            param1 = tell_command.alt;
            param2 = tell_command.lat;
            param4 = tell_command.lng;
            break;

        case MAV_CMD_NAV_TAKEOFF:
            param1 = 0;
            break;

        case MAV_CMD_NAV_LOITER_TIME:
            param1 = tell_command.p1;                                   // ACM loiter time is in 1 second increments
            break;

        case MAV_CMD_CONDITION_DELAY:
        case MAV_CMD_CONDITION_DISTANCE:
            param1 = tell_command.lat;
            break;

        case MAV_CMD_DO_JUMP:
            param2 = tell_command.lat;
            param1 = tell_command.p1;
            break;

        case MAV_CMD_DO_REPEAT_SERVO:
            param4 = tell_command.lng;
        case MAV_CMD_DO_REPEAT_RELAY:
        case MAV_CMD_DO_CHANGE_SPEED:
            param3 = tell_command.lat;
            param2 = tell_command.alt;
            param1 = tell_command.p1;
            break;

        case MAV_CMD_NAV_WAYPOINT:
            param1 = tell_command.p1;
            break;

        case MAV_CMD_DO_SET_PARAMETER:
        case MAV_CMD_DO_SET_RELAY:
        case MAV_CMD_DO_SET_SERVO:
            param2 = tell_command.alt;
            param1 = tell_command.p1;
            break;
        }

        mavlink_msg_mission_item_send(chan,msg->sysid,
                                      msg->compid,
                                      packet.seq,
                                      frame,
                                      tell_command.id,
                                      current,
                                      autocontinue,
                                      param1,
                                      param2,
                                      param3,
                                      param4,
                                      x,
                                      y,
                                      z);

        // update last waypoint comm stamp
        waypoint_timelast_send = millis();
        break;
    }

    case MAVLINK_MSG_ID_MISSION_ACK:     //47
    {
        //send_text_P(SEVERITY_LOW,PSTR("waypoint ack"));

        // decode
        mavlink_mission_ack_t packet;
        mavlink_msg_mission_ack_decode(msg, &packet);
        if (mavlink_check_target(packet.target_system,packet.target_component)) break;

        // turn off waypoint send
        waypoint_sending = false;
        break;
    }

    case MAVLINK_MSG_ID_PARAM_REQUEST_LIST:     // 21
    {
        // gcs_send_text_P(SEVERITY_LOW,PSTR("param request list"));

        // decode
        mavlink_param_request_list_t packet;
        mavlink_msg_param_request_list_decode(msg, &packet);
        if (mavlink_check_target(packet.target_system,packet.target_component)) break;

        // Start sending parameters - next call to ::update will kick the first one out

        _queued_parameter = AP_Param::first(&_queued_parameter_token, &_queued_parameter_type);
        _queued_parameter_index = 0;
        _queued_parameter_count = _count_parameters();
        break;
    }

    case MAVLINK_MSG_ID_PARAM_REQUEST_READ:
    {
        // decode
        mavlink_param_request_read_t packet;
        mavlink_msg_param_request_read_decode(msg, &packet);
        if (mavlink_check_target(packet.target_system,packet.target_component)) break;
        if (packet.param_index != -1) {
            gcs_send_text_P(SEVERITY_LOW, PSTR("Param by index not supported"));
            break;
        }

        enum ap_var_type p_type;
        AP_Param *vp = AP_Param::find(packet.param_id, &p_type);
        if (vp == NULL) {
            gcs_send_text_fmt(PSTR("Unknown parameter %s"), packet.param_id);
            break;
        }
        char param_name[ONBOARD_PARAM_NAME_LENGTH];
        vp->copy_name(param_name, sizeof(param_name), true);

        float value = vp->cast_to_float(p_type);
        mavlink_msg_param_value_send(
            chan,
            param_name,
            value,
            mav_var_type(p_type),
            -1, -1);
        break;
    }

    case MAVLINK_MSG_ID_MISSION_CLEAR_ALL:     // 45
    {
        //send_text_P(SEVERITY_LOW,PSTR("waypoint clear all"));

        // decode
        mavlink_mission_clear_all_t packet;
        mavlink_msg_mission_clear_all_decode(msg, &packet);
        if (mavlink_check_target(packet.target_system, packet.target_component)) break;

        // clear all waypoints
        uint8_t type = 0;                 // ok (0), error(1)
        g.command_total.set_and_save(1);

        // send acknowledgement 3 times to makes sure it is received
        for (int16_t i=0; i<3; i++)
            mavlink_msg_mission_ack_send(chan, msg->sysid, msg->compid, type);

        break;
    }

    case MAVLINK_MSG_ID_MISSION_SET_CURRENT:     // 41
    {
        //send_text_P(SEVERITY_LOW,PSTR("waypoint set current"));

        // decode
        mavlink_mission_set_current_t packet;
        mavlink_msg_mission_set_current_decode(msg, &packet);
        if (mavlink_check_target(packet.target_system,packet.target_component)) break;

        // set current command
        change_command(packet.seq);

        mavlink_msg_mission_current_send(chan, g.command_index);
        break;
    }

    case MAVLINK_MSG_ID_MISSION_COUNT:     // 44
    {
        //send_text_P(SEVERITY_LOW,PSTR("waypoint count"));

        // decode
        mavlink_mission_count_t packet;
        mavlink_msg_mission_count_decode(msg, &packet);
        if (mavlink_check_target(packet.target_system,packet.target_component)) break;

        // start waypoint receiving
        if (packet.count > MAX_WAYPOINTS) {
            packet.count = MAX_WAYPOINTS;
        }
        g.command_total.set_and_save(packet.count);

        waypoint_timelast_receive = millis();
        waypoint_receiving   = true;
        waypoint_sending         = false;
        waypoint_request_i   = 0;
        waypoint_timelast_request = 0;
        break;
    }

#ifdef MAVLINK_MSG_ID_SET_MAG_OFFSETS
    case MAVLINK_MSG_ID_SET_MAG_OFFSETS:
    {
        mavlink_set_mag_offsets_t packet;
        mavlink_msg_set_mag_offsets_decode(msg, &packet);
        if (mavlink_check_target(packet.target_system,packet.target_component)) break;
        compass.set_offsets(Vector3f(packet.mag_ofs_x, packet.mag_ofs_y, packet.mag_ofs_z));
        break;
    }
#endif

    // XXX receive a WP from GCS and store in EEPROM
    case MAVLINK_MSG_ID_MISSION_ITEM:     //39
    {
        // decode
        mavlink_mission_item_t packet;
        mavlink_msg_mission_item_decode(msg, &packet);
        if (mavlink_check_target(packet.target_system,packet.target_component)) break;

        // defaults
        tell_command.id = packet.command;

        /*
         *  switch (packet.frame){
         *
         *       case MAV_FRAME_MISSION:
         *       case MAV_FRAME_GLOBAL:
         *               {
         *                       tell_command.lat = 1.0e7*packet.x; // in as DD converted to * t7
         *                       tell_command.lng = 1.0e7*packet.y; // in as DD converted to * t7
         *                       tell_command.alt = packet.z*1.0e2; // in as m converted to cm
         *                       tell_command.options = 0; // absolute altitude
         *                       break;
         *               }
         *
         *       case MAV_FRAME_LOCAL: // local (relative to home position)
         *               {
         *                       tell_command.lat = 1.0e7*ToDeg(packet.x/
         *                       (radius_of_earth*cos(ToRad(home.lat/1.0e7)))) + home.lat;
         *                       tell_command.lng = 1.0e7*ToDeg(packet.y/radius_of_earth) + home.lng;
         *                       tell_command.alt = packet.z*1.0e2;
         *                       tell_command.options = MASK_OPTIONS_RELATIVE_ALT;
         *                       break;
         *               }
         *       //case MAV_FRAME_GLOBAL_RELATIVE_ALT: // absolute lat/lng, relative altitude
         *       default:
         *               {
         *                       tell_command.lat = 1.0e7 * packet.x; // in as DD converted to * t7
         *                       tell_command.lng = 1.0e7 * packet.y; // in as DD converted to * t7
         *                       tell_command.alt = packet.z * 1.0e2;
         *                       tell_command.options = MASK_OPTIONS_RELATIVE_ALT; // store altitude relative!! Always!!
         *                       break;
         *               }
         *  }
         */

        // we only are supporting Abs position, relative Alt
        tell_command.lat = 1.0e7 * packet.x;                 // in as DD converted to * t7
        tell_command.lng = 1.0e7 * packet.y;                 // in as DD converted to * t7
        tell_command.alt = packet.z * 1.0e2;
        tell_command.options = 1;                 // store altitude relative to home alt!! Always!!

        switch (tell_command.id) {                                                      // Switch to map APM command fields into MAVLink command fields
        case MAV_CMD_NAV_LOITER_TURNS:
        case MAV_CMD_DO_SET_HOME:
            tell_command.p1 = packet.param1;
            break;

        case MAV_CMD_NAV_ROI:
            tell_command.p1 = packet.param1;                                    // MAV_ROI (aka roi mode) is held in wp's parameter but we actually do nothing with it because we only support pointing at a specific location provided by x,y and z parameters
            break;

        case MAV_CMD_CONDITION_YAW:
            tell_command.p1 = packet.param3;
            tell_command.alt = packet.param1;
            tell_command.lat = packet.param2;
            tell_command.lng = packet.param4;
            break;

        case MAV_CMD_NAV_TAKEOFF:
            tell_command.p1 = 0;
            break;

        case MAV_CMD_CONDITION_CHANGE_ALT:
            tell_command.p1 = packet.param1 * 100;
            break;

        case MAV_CMD_NAV_LOITER_TIME:
            tell_command.p1 = packet.param1;                                    // APM loiter time is in ten second increments
            break;

        case MAV_CMD_CONDITION_DELAY:
        case MAV_CMD_CONDITION_DISTANCE:
            tell_command.lat = packet.param1;
            break;

        case MAV_CMD_DO_JUMP:
            tell_command.lat = packet.param2;
            tell_command.p1  = packet.param1;
            break;

        case MAV_CMD_DO_REPEAT_SERVO:
            tell_command.lng = packet.param4;
        case MAV_CMD_DO_REPEAT_RELAY:
        case MAV_CMD_DO_CHANGE_SPEED:
            tell_command.lat = packet.param3;
            tell_command.alt = packet.param2;
            tell_command.p1 = packet.param1;
            break;

        case MAV_CMD_NAV_WAYPOINT:
            tell_command.p1 = packet.param1;
            break;

        case MAV_CMD_DO_SET_PARAMETER:
        case MAV_CMD_DO_SET_RELAY:
        case MAV_CMD_DO_SET_SERVO:
            tell_command.alt = packet.param2;
            tell_command.p1 = packet.param1;
            break;
        }

        if(packet.current == 2) {                                               //current = 2 is a flag to tell us this is a "guided mode" waypoint and not for the mission
            guided_WP = tell_command;

            // add home alt if needed
            if (guided_WP.options & MASK_OPTIONS_RELATIVE_ALT) {
                guided_WP.alt += home.alt;
            }

            set_mode(GUIDED);

            // make any new wp uploaded instant (in case we are already in Guided mode)
            set_next_WP(&guided_WP);

            // verify we recevied the command
            mavlink_msg_mission_ack_send(
                chan,
                msg->sysid,
                msg->compid,
                0);

        } else if(packet.current == 3) {                                               //current = 3 is a flag to tell us this is a alt change only

            // add home alt if needed
            if (tell_command.options & MASK_OPTIONS_RELATIVE_ALT) {
                tell_command.alt += home.alt;
            }

            set_new_altitude(tell_command.alt);

            // verify we recevied the command
            mavlink_msg_mission_ack_send(
                chan,
                msg->sysid,
                msg->compid,
                0);

        } else {
            // Check if receiving waypoints (mission upload expected)
            if (!waypoint_receiving) break;


            //Serial.printf("req: %d, seq: %d, total: %d\n", waypoint_request_i,packet.seq, g.command_total.get());

            // check if this is the requested waypoint
            if (packet.seq != waypoint_request_i)
                break;

            if(packet.seq != 0)
                set_cmd_with_index(tell_command, packet.seq);

            // update waypoint receiving state machine
            waypoint_timelast_receive = millis();
            waypoint_timelast_request = 0;
            waypoint_request_i++;

            if (waypoint_request_i == (uint16_t)g.command_total) {
                uint8_t type = 0;                         // ok (0), error(1)

                mavlink_msg_mission_ack_send(
                    chan,
                    msg->sysid,
                    msg->compid,
                    type);

                send_text(SEVERITY_LOW,PSTR("flight plan received"));
                waypoint_receiving = false;
                // XXX ignores waypoint radius for individual waypoints, can
                // only set WP_RADIUS parameter
            }
        }
        break;
    }

    case MAVLINK_MSG_ID_PARAM_SET:     // 23
    {
        AP_Param                  *vp;
        enum ap_var_type var_type;

        // decode
        mavlink_param_set_t packet;
        mavlink_msg_param_set_decode(msg, &packet);

        if (mavlink_check_target(packet.target_system, packet.target_component))
            break;

        // set parameter

        char key[ONBOARD_PARAM_NAME_LENGTH+1];
        strncpy(key, (char *)packet.param_id, ONBOARD_PARAM_NAME_LENGTH);
        key[ONBOARD_PARAM_NAME_LENGTH] = 0;

        // find the requested parameter
        vp = AP_Param::find(key, &var_type);
        if ((NULL != vp) &&                                                                                     // exists
            !isnan(packet.param_value) &&                                                  // not nan
            !isinf(packet.param_value)) {                                                  // not inf

            // add a small amount before casting parameter values
            // from float to integer to avoid truncating to the
            // next lower integer value.
            float rounding_addition = 0.01;

            // handle variables with standard type IDs
            if (var_type == AP_PARAM_FLOAT) {
                ((AP_Float *)vp)->set_and_save(packet.param_value);
            } else if (var_type == AP_PARAM_INT32) {
#if LOGGING_ENABLED == ENABLED
                Log_Write_Data(1, ((AP_Int32 *)vp)->get());
#endif
                if (packet.param_value < 0) rounding_addition = -rounding_addition;
                float v = packet.param_value+rounding_addition;
                v = constrain(v, -2147483648.0, 2147483647.0);
                ((AP_Int32 *)vp)->set_and_save(v);
            } else if (var_type == AP_PARAM_INT16) {
#if LOGGING_ENABLED == ENABLED
                Log_Write_Data(3, (int32_t)((AP_Int16 *)vp)->get());
#endif
                if (packet.param_value < 0) rounding_addition = -rounding_addition;
                float v = packet.param_value+rounding_addition;
                v = constrain(v, -32768, 32767);
                ((AP_Int16 *)vp)->set_and_save(v);
            } else if (var_type == AP_PARAM_INT8) {
#if LOGGING_ENABLED == ENABLED
                Log_Write_Data(4, (int32_t)((AP_Int8 *)vp)->get());
#endif
                if (packet.param_value < 0) rounding_addition = -rounding_addition;
                float v = packet.param_value+rounding_addition;
                v = constrain(v, -128, 127);
                ((AP_Int8 *)vp)->set_and_save(v);
            } else {
                // we don't support mavlink set on this parameter
                break;
            }

            // Report back the new value if we accepted the change
            // we send the value we actually set, which could be
            // different from the value sent, in case someone sent
            // a fractional value to an integer type
            mavlink_msg_param_value_send(
                chan,
                key,
                vp->cast_to_float(var_type),
                mav_var_type(var_type),
                _count_parameters(),
                -1);                         // XXX we don't actually know what its index is...

        }

        break;
    }             // end case

    case MAVLINK_MSG_ID_RC_CHANNELS_OVERRIDE: //70
    {
        // allow override of RC channel values for HIL
        // or for complete GCS control of switch position
        // and RC PWM values.
        if(msg->sysid != g.sysid_my_gcs) break;                         // Only accept control from our gcs
        mavlink_rc_channels_override_t packet;
        int16_t v[8];
        mavlink_msg_rc_channels_override_decode(msg, &packet);

        if (mavlink_check_target(packet.target_system,packet.target_component))
            break;

        v[0] = packet.chan1_raw;
        v[1] = packet.chan2_raw;
        v[2] = packet.chan3_raw;
        v[3] = packet.chan4_raw;
        v[4] = packet.chan5_raw;
        v[5] = packet.chan6_raw;
        v[6] = packet.chan7_raw;
        v[7] = packet.chan8_raw;
        APM_RC.setHIL(v);
        break;
    }


#if HIL_MODE != HIL_MODE_DISABLED
    case MAVLINK_MSG_ID_HIL_STATE:
    {
        mavlink_hil_state_t packet;
        mavlink_msg_hil_state_decode(msg, &packet);

        float vel = sqrt((packet.vx * (float)packet.vx) + (packet.vy * (float)packet.vy));
        float cog = wrap_360(ToDeg(atan2(packet.vx, packet.vy)) * 100);

        // set gps hil sensor
        g_gps->setHIL(packet.time_usec/1000,
                      packet.lat*1.0e-7, packet.lon*1.0e-7, packet.alt*1.0e-3,
                      vel*1.0e-2, cog*1.0e-2, 0, 10);

        if (gps_base_alt == 0) {
            gps_base_alt = g_gps->altitude;
        }
        current_loc.lng = g_gps->longitude;
        current_loc.lat = g_gps->latitude;
        current_loc.alt = g_gps->altitude - gps_base_alt;
        if (!home_is_set) {
            init_home();
        }


        // rad/sec
        Vector3f gyros;
        gyros.x = packet.rollspeed;
        gyros.y = packet.pitchspeed;
        gyros.z = packet.yawspeed;
        // m/s/s
        Vector3f accels;
        accels.x = (float)packet.xacc / 1000.0;
        accels.y = (float)packet.yacc / 1000.0;
        accels.z = (float)packet.zacc / 1000.0;

        imu.set_gyro(gyros);

        imu.set_accel(accels);


        // set AHRS hil sensor
        ahrs.setHil(packet.roll,packet.pitch,packet.yaw,packet.rollspeed,
                    packet.pitchspeed,packet.yawspeed);



        break;
    }
#endif //  HIL_MODE != HIL_MODE_DISABLED

/*
 *       case MAVLINK_MSG_ID_HEARTBEAT:
 *               {
 *                       // We keep track of the last time we received a heartbeat from our GCS for failsafe purposes
 *                       if(msg->sysid != g.sysid_my_gcs) break;
 *                       rc_override_fs_timer = millis();
 *                       break;
 *               }
 *
 * #if HIL_MODE != HIL_MODE_DISABLED
 *               // This is used both as a sensor and to pass the location
 *               // in HIL_ATTITUDE mode.
 *       case MAVLINK_MSG_ID_GPS_RAW:
 *               {
 *                       // decode
 *                       mavlink_gps_raw_t packet;
 *                       mavlink_msg_gps_raw_decode(msg, &packet);
 *
 *                       // set gps hil sensor
 *                       g_gps->setHIL(packet.usec/1000,packet.lat,packet.lon,packet.alt,
 *                       packet.v,packet.hdg,0,0);
 *                       break;
 *               }
 * #endif
 */
#if HIL_MODE == HIL_MODE_SENSORS

    case MAVLINK_MSG_ID_RAW_IMU: // 28
    {
        // decode
        mavlink_raw_imu_t packet;
        mavlink_msg_raw_imu_decode(msg, &packet);

        // set imu hil sensors
        // TODO: check scaling for temp/absPress
        float temp = 70;
        float absPress = 1;
        //      Serial.printf_P(PSTR("accel:\t%d\t%d\t%d\n"), packet.xacc, packet.yacc, packet.zacc);
        //      Serial.printf_P(PSTR("gyro:\t%d\t%d\t%d\n"), packet.xgyro, packet.ygyro, packet.zgyro);

        // rad/sec
        Vector3f gyros;
        gyros.x = (float)packet.xgyro / 1000.0;
        gyros.y = (float)packet.ygyro / 1000.0;
        gyros.z = (float)packet.zgyro / 1000.0;
        // m/s/s
        Vector3f accels;
        accels.x = (float)packet.xacc / 1000.0;
        accels.y = (float)packet.yacc / 1000.0;
        accels.z = (float)packet.zacc / 1000.0;

        imu.set_gyro(gyros);

        imu.set_accel(accels);

        compass.setHIL(packet.xmag,packet.ymag,packet.zmag);
        break;
    }

    case MAVLINK_MSG_ID_RAW_PRESSURE: //29
    {
        // decode
        mavlink_raw_pressure_t packet;
        mavlink_msg_raw_pressure_decode(msg, &packet);

        // set pressure hil sensor
        // TODO: check scaling
        float temp = 70;
        barometer.setHIL(temp,packet.press_diff1);
        break;
    }
#endif // HIL_MODE

#if CAMERA == ENABLED
    case MAVLINK_MSG_ID_DIGICAM_CONFIGURE:
    {
        g.camera.configure_msg(msg);
        break;
    }

    case MAVLINK_MSG_ID_DIGICAM_CONTROL:
    {
        g.camera.control_msg(msg);
        break;
    }
#endif // CAMERA == ENABLED

#if MOUNT == ENABLED
    case MAVLINK_MSG_ID_MOUNT_CONFIGURE:
    {
        camera_mount.configure_msg(msg);
        break;
    }

    case MAVLINK_MSG_ID_MOUNT_CONTROL:
    {
        camera_mount.control_msg(msg);
        break;
    }

    case MAVLINK_MSG_ID_MOUNT_STATUS:
    {
        camera_mount.status_msg(msg);
        break;
    }
#endif // MOUNT == ENABLED

    case MAVLINK_MSG_ID_RADIO:
    {
        mavlink_radio_t packet;
        mavlink_msg_radio_decode(msg, &packet);
        // use the state of the transmit buffer in the radio to
        // control the stream rate, giving us adaptive software
        // flow control
        if (packet.txbuf < 20 && stream_slowdown < 100) {
            // we are very low on space - slow down a lot
            stream_slowdown += 3;
        } else if (packet.txbuf < 50 && stream_slowdown < 100) {
            // we are a bit low on space, slow down slightly
            stream_slowdown += 1;
        } else if (packet.txbuf > 95 && stream_slowdown > 10) {
            // the buffer has plenty of space, speed up a lot
            stream_slowdown -= 2;
        } else if (packet.txbuf > 90 && stream_slowdown != 0) {
            // the buffer has enough space, speed up a bit
            stream_slowdown--;
        }
        break;
    }

#ifdef AP_LIMITS

    // receive an AP_Limits fence point from GCS and store in EEPROM
    // receive a fence point from GCS and store in EEPROM
    case MAVLINK_MSG_ID_FENCE_POINT: {
        mavlink_fence_point_t packet;
        mavlink_msg_fence_point_decode(msg, &packet);
        if (packet.count != geofence_limit.fence_total()) {
            send_text(SEVERITY_LOW,PSTR("bad fence point"));
        } else {
            Vector2l point;
            point.x = packet.lat*1.0e7;
            point.y = packet.lng*1.0e7;
            geofence_limit.set_fence_point_with_index(point, packet.idx);
        }
        break;
    }
    // send a fence point to GCS
    case MAVLINK_MSG_ID_FENCE_FETCH_POINT: {
        mavlink_fence_fetch_point_t packet;
        mavlink_msg_fence_fetch_point_decode(msg, &packet);
        if (mavlink_check_target(packet.target_system, packet.target_component))
            break;
        if (packet.idx >= geofence_limit.fence_total()) {
            send_text(SEVERITY_LOW,PSTR("bad fence point"));
        } else {
            Vector2l point = geofence_limit.get_fence_point_with_index(packet.idx);
            mavlink_msg_fence_point_send(chan, 0, 0, packet.idx, geofence_limit.fence_total(),
                                         point.x*1.0e-7, point.y*1.0e-7);
        }
        break;
    }


#endif // AP_LIMITS ENABLED

    }     // end switch
} // end handle mavlink

uint16_t
GCS_MAVLINK::_count_parameters()
{
    // if we haven't cached the parameter count yet...
    if (0 == _parameter_count) {
        AP_Param  *vp;
        AP_Param::ParamToken token;

        vp = AP_Param::first(&token, NULL);
        do {
            _parameter_count++;
        } while (NULL != (vp = AP_Param::next_scalar(&token, NULL)));
    }
    return _parameter_count;
}

/**
 * @brief Send the next pending parameter, called from deferred message
 * handling code
 */
void
GCS_MAVLINK::queued_param_send()
{
    // Check to see if we are sending parameters
    if (NULL == _queued_parameter) return;

    AP_Param      *vp;
    float value;

    // copy the current parameter and prepare to move to the next
    vp = _queued_parameter;

    // if the parameter can be cast to float, report it here and break out of the loop
    value = vp->cast_to_float(_queued_parameter_type);

    char param_name[ONBOARD_PARAM_NAME_LENGTH];
    vp->copy_name(param_name, sizeof(param_name), true);

    mavlink_msg_param_value_send(
        chan,
        param_name,
        value,
        mav_var_type(_queued_parameter_type),
        _queued_parameter_count,
        _queued_parameter_index);

    _queued_parameter = AP_Param::next_scalar(&_queued_parameter_token, &_queued_parameter_type);
    _queued_parameter_index++;
}

/**
 * @brief Send the next pending waypoint, called from deferred message
 * handling code
 */
void
GCS_MAVLINK::queued_waypoint_send()
{
    if (waypoint_receiving &&
        waypoint_request_i < (unsigned)g.command_total) {
        mavlink_msg_mission_request_send(
            chan,
            waypoint_dest_sysid,
            waypoint_dest_compid,
            waypoint_request_i);
    }
}

/*
 *  a delay() callback that processes MAVLink packets. We set this as the
 *  callback in long running library initialisation routines to allow
 *  MAVLink to process packets while waiting for the initialisation to
 *  complete
 */
static void mavlink_delay(unsigned long t)
{
    uint32_t tstart;
    static uint32_t last_1hz, last_50hz, last_5s;

    if (in_mavlink_delay) {
        // this should never happen, but let's not tempt fate by
        // letting the stack grow too much
        delay(t);
        return;
    }

    in_mavlink_delay = true;

    tstart = millis();
    do {
        uint32_t tnow = millis();
        if (tnow - last_1hz > 1000) {
            last_1hz = tnow;
            gcs_send_message(MSG_HEARTBEAT);
            gcs_send_message(MSG_EXTENDED_STATUS1);
        }
        if (tnow - last_50hz > 20) {
            last_50hz = tnow;
            gcs_update();
            gcs_data_stream_send();
        }
        if (tnow - last_5s > 5000) {
            last_5s = tnow;
            gcs_send_text_P(SEVERITY_LOW, PSTR("Initialising APM..."));
        }
        delay(1);
#if USB_MUX_PIN > 0
        check_usb_mux();
#endif
    } while (millis() - tstart < t);

    in_mavlink_delay = false;
}

/*
 *  send a message on both GCS links
 */
static void gcs_send_message(enum ap_message id)
{
    gcs0.send_message(id);
    if (gcs3.initialised) {
        gcs3.send_message(id);
    }
}

/*
 *  send data streams in the given rate range on both links
 */
static void gcs_data_stream_send(void)
{
    gcs0.data_stream_send();
    if (gcs3.initialised) {
        gcs3.data_stream_send();
    }
}

/*
 *  look for incoming commands on the GCS links
 */
static void gcs_update(void)
{
    gcs0.update();
    if (gcs3.initialised) {
        gcs3.update();
    }
}

static void gcs_send_text(gcs_severity severity, const char *str)
{
    gcs0.send_text(severity, str);
    if (gcs3.initialised) {
        gcs3.send_text(severity, str);
    }
}

static void gcs_send_text_P(gcs_severity severity, const prog_char_t *str)
{
    gcs0.send_text(severity, str);
    if (gcs3.initialised) {
        gcs3.send_text(severity, str);
    }
}

/*
 *  send a low priority formatted message to the GCS
 *  only one fits in the queue, so if you send more than one before the
 *  last one gets into the serial buffer then the old one will be lost
 */
static void gcs_send_text_fmt(const prog_char_t *fmt, ...)
{
    char fmtstr[40];
    va_list ap;
    uint8_t i;
    for (i=0; i<sizeof(fmtstr)-1; i++) {
        fmtstr[i] = pgm_read_byte((const prog_char *)(fmt++));
        if (fmtstr[i] == 0) break;
    }
    fmtstr[i] = 0;
    pending_status.severity = (uint8_t)SEVERITY_LOW;
    va_start(ap, fmt);
    vsnprintf((char *)pending_status.text, sizeof(pending_status.text), fmtstr, ap);
    va_end(ap);
    mavlink_send_message(MAVLINK_COMM_0, MSG_STATUSTEXT, 0);
    if (gcs3.initialised) {
        mavlink_send_message(MAVLINK_COMM_1, MSG_STATUSTEXT, 0);
    }
}

/// -*- tab-width: 4; Mode: C++; c-basic-offset: 4; indent-tabs-mode: nil -*-

/*
 *  GCS Protocol
 *
 *  4	Ardupilot Header
 *  D
 *  5	Payload length
 *  1	Message ID
 *  1	Message Version
 *  9	Payload byte 1
 *  8	Payload byte 2
 *  7	Payload byte 3
 *  A	Checksum byte 1
 *  B	Checksum byte 2
 *
 */

/*
 * #if GCS_PORT == 3
 # define SendSerw		Serial3.write
 # define SendSer		Serial3.print
 ##else
 # define SendSerw		Serial.write
 # define SendSer		Serial.print
 ##endif
 #
 #  byte mess_buffer[60];
 #  byte buff_pointer;
 #
 #  // Unions for getting byte values
 #  union f_out{
 #       byte bytes[4];
 #       float value;
 #  } floatOut;
 #
 #  union i_out {
 #       byte bytes[2];
 #       int16_t value;
 #  } intOut;
 #
 #  union l_out{
 #       byte bytes[4];
 #       int32_t value;
 #  } longOut;
 #
 #  // Add binary values to the buffer
 #  void write_byte(byte val)
 #  {
 #       mess_buffer[buff_pointer++] = val;
 #  }
 #
 #  void write_int(int16_t val )
 #  {
 #       intOut.value = val;
 #       mess_buffer[buff_pointer++] = intOut.bytes[0];
 #       mess_buffer[buff_pointer++] = intOut.bytes[1];
 #  }
 #
 #  void write_float(float val)
 #  {
 #       floatOut.value = val;
 #       mess_buffer[buff_pointer++] = floatOut.bytes[0];
 #       mess_buffer[buff_pointer++] = floatOut.bytes[1];
 #       mess_buffer[buff_pointer++] = floatOut.bytes[2];
 #       mess_buffer[buff_pointer++] = floatOut.bytes[3];
 #  }
 #
 #  void write_long(int32_t val)
 #  {
 #       longOut.value = val;
 #       mess_buffer[buff_pointer++] = longOut.bytes[0];
 #       mess_buffer[buff_pointer++] = longOut.bytes[1];
 #       mess_buffer[buff_pointer++] = longOut.bytes[2];
 #       mess_buffer[buff_pointer++] = longOut.bytes[3];
 #  }
 #
 #  void flush(byte id)
 #  {
 #       byte mess_ck_a = 0;
 #       byte mess_ck_b = 0;
 #       byte i;
 #
 #       SendSer("4D");             // This is the message preamble
 #       SendSerw(buff_pointer);    // Length
 #       SendSerw(2);               // id
 #
 #       for (i = 0; i < buff_pointer; i++) {
 #               SendSerw(mess_buffer[i]);
 #       }
 #
 #       buff_pointer = 0;
 #  }
 */#if INERTIAL_NAV == ENABLED

// generates a new location and velocity in space based on inertia
// Calc 100 hz
void calc_inertia()
{
    // rotate accels based on DCM
    // --------------------------
    accels_rotated          = ahrs.get_dcm_matrix() * imu.get_accel();
    //accels_rotated		+= accels_offset;						// skew accels to account for long term error using calibration
    accels_rotated.z        += 9.805;                                                                   // remove influence of gravity

    // rising       = 2
    // neutral      = 0
    // falling      = -2

    // ACC Y POS = going EAST
    // ACC X POS = going North
    // ACC Z POS = going DOWN (lets flip this)

    // Integrate accels to get the velocity
    // ------------------------------------
    Vector3f temp           = accels_rotated * (G_Dt * 100);
    temp.z                          = -temp.z;     // Temp is changed to world frame and we can use it normaly
    accels_velocity         += temp;

    // Integrate velocity to get the Position
    // ------------------------------------
    accels_position         += accels_velocity * G_Dt;

    /*
     *       current_loc.lng += accels_velocity.x * G_Dt;
     *       current_loc.lat += accels_velocity.y * G_Dt;
     *       current_loc.alt += accels_velocity.z * G_Dt;
     */
}

void xy_error_correction()
{
    // Calculate speed error
    // ---------------------
    speed_error.x           = x_actual_speed - accels_velocity.x;
    speed_error.y           = y_actual_speed - accels_velocity.y;

    // Calculate position error
    // ------------------------
    //position_error.x	= accels_position.x - current_loc.lng;
    //position_error.y	= accels_position.y - current_loc.lat;

    // correct integrated velocity by speed_error
    // this number must be small or we will bring back sensor latency
    // -------------------------------------------
    accels_velocity.x       += speed_error.x * 0.03;                                                                    // g.speed_correction_x;
    accels_velocity.y       += speed_error.y * 0.03;

    // Error correct the accels to deal with calibration, drift and noise
    // ------------------------------------------------------------------
    //accels_position.x	-= position_error.x * 0.08;         // g.loiter_offset_correction; //.001;
    //accels_position.y	-= position_error.y * 0.08;         // g.loiter_offset_correction; //.001;

    accels_position.x = 0;
    accels_position.y = 0;
}

void z_error_correction()
{
    // Calculate speed error
    // ---------------------
    speed_error.z           = climb_rate - accels_velocity.z;
    //position_error.z	= accels_position.z - current_loc.alt;

    // correct integrated velocity by speed_error
    // this number must be small or we will bring back sensor latency
    // -------------------------------------------
    accels_velocity.z       += speed_error.z * 0.0350;                                                          //speed_correction_z;

    // ------------------------------------------------------------------
    //accels_position.z   -= position_error.z * 0.006;      //g.alt_offset_correction; // OK

    accels_position.z = 0;

    // For developement only
    // ---------------------
    if(motors.armed())
        Log_Write_Raw();
}

#endifstatic void update_lights()
{
    switch(led_mode) {
    case NORMAL_LEDS:
        update_motor_light();
        update_GPS_light();
        break;

    case AUTO_TRIM_LEDS:
        dancing_light();
        break;
    }
}

static void update_GPS_light(void)
{
    // GPS LED on if we have a fix or Blink GPS LED if we are receiving data
    // ---------------------------------------------------------------------
    switch (g_gps->status()) {

    case (2):
        if(home_is_set) {                                      // JLN update
            digitalWrite(C_LED_PIN, LED_ON);                  //Turn LED C on when gps has valid fix AND home is set.
        } else {
            digitalWrite(C_LED_PIN, LED_OFF);
        }
        break;

    case (1):
        if (g_gps->valid_read == true) {
            GPS_light = !GPS_light;                     // Toggle light on and off to indicate gps messages being received, but no GPS fix lock
            if (GPS_light) {
                digitalWrite(C_LED_PIN, LED_OFF);
            }else{
                digitalWrite(C_LED_PIN, LED_ON);
            }
            g_gps->valid_read = false;
        }
        break;

    default:
        digitalWrite(C_LED_PIN, LED_OFF);
        break;
    }
}

static void update_motor_light(void)
{
    if(motors.armed() == false) {
        motor_light = !motor_light;

        // blink
        if(motor_light) {
            digitalWrite(A_LED_PIN, LED_ON);
        }else{
            digitalWrite(A_LED_PIN, LED_OFF);
        }
    }else{
        if(!motor_light) {
            motor_light = true;
            digitalWrite(A_LED_PIN, LED_ON);
        }
    }
}

static void dancing_light()
{
    static byte step;

    if (step++ == 3)
        step = 0;

    switch(step)
    {
    case 0:
        digitalWrite(C_LED_PIN, LED_OFF);
        digitalWrite(A_LED_PIN, LED_ON);
        break;

    case 1:
        digitalWrite(A_LED_PIN, LED_OFF);
        digitalWrite(B_LED_PIN, LED_ON);
        break;

    case 2:
        digitalWrite(B_LED_PIN, LED_OFF);
        digitalWrite(C_LED_PIN, LED_ON);
        break;
    }
}
static void clear_leds()
{
    digitalWrite(A_LED_PIN, LED_OFF);
    digitalWrite(B_LED_PIN, LED_OFF);
    digitalWrite(C_LED_PIN, LED_OFF);
    motor_light = false;
    led_mode = NORMAL_LEDS;
}

/////////////////////////////////////////////////////////////////////////////////////////////
//	Copter LEDS by Robert Lefebvre
//	Based on the work of U4eake, Bill Sanford, Max Levine, and Oliver
//	g.copter_leds_mode controls the copter leds function via bitmath
//	Zeroeth bit turns motor leds on and off:                                00000001
//	First bit turns GPS function on and off:                                00000010
//	Second bit turns Aux function on and off:                               00000100
//	Third bit turns on Beeper (legacy Piezo) function:                      00001000
//	Fourth bit toggles between Fast Flash or Oscillate on Low Battery:      00010000		(0) does Fast Flash, (1) does Oscillate
//	Fifth bit causes motor LEDs to Nav Blink:                               00100000
//	Sixth bit causes GPS LEDs to Nav Blink:                                 01000000
//	This code is written in order to be backwards compatible with the old Motor_LEDS code
//	I hope to include at least some of the Show_LEDS code in the future
//	copter_leds_GPS_blink controls the blinking of the GPS LEDS
//	copter_leds_motor_blink controls the blinking of the motor LEDS
//	Piezo Code and beeps once on Startup to verify operation
//	Piezo Enables Tone on reaching low battery or current alert
/////////////////////////////////////////////////////////////////////////////////////////////


#if COPTER_LEDS == ENABLED
static void update_copter_leds(void)
{
    if (g.copter_leds_mode == 0) {
        copter_leds_reset();                                                                    //method of reintializing LED state
    }

    if ( bitRead(g.copter_leds_mode, 0) ) {
        if (motors.armed() == true) {
            if (low_batt == true) {
                if ( bitRead(g.copter_leds_mode, 4 )) {
                    copter_leds_oscillate();                                                    //if motors are armed, but battery level is low, motor leds fast blink
                } else {
                    copter_leds_fast_blink();                                                   //if motors are armed, but battery level is low, motor leds oscillate
                }
            } else if ( !bitRead(g.copter_leds_mode, 5 ) ) {
                copter_leds_on();                                                                       //if motors are armed, battery level OK, all motor leds ON
            } else if ( bitRead(g.copter_leds_mode, 5 ) ) {
                if ( copter_leds_nav_blink >0 ) {
                    copter_leds_slow_blink();                                                           //if nav command was seen, blink LEDs.
                } else {
                    copter_leds_on();
                }
            }
        } else {
            copter_leds_slow_blink();                                                           //if motors are not armed, blink motor leds
        }
    }

    if ( bitRead(g.copter_leds_mode, 1) ) {

        // GPS LED on if we have a fix or Blink GPS LED if we are receiving data
        // ---------------------------------------------------------------------
        switch (g_gps->status()) {

        case (2):
            if(home_is_set) {
                if ( !bitRead(g.copter_leds_mode, 6 ) ) {
                    copter_leds_GPS_on();                                                                       //Turn GPS LEDs on when gps has valid fix AND home is set
                } else if (bitRead(g.copter_leds_mode, 6 ) ) {
                    if ( copter_leds_nav_blink >0 ) {
                        copter_leds_GPS_slow_blink();                                                   //if nav command was seen, blink LEDs.
                    } else {
                        copter_leds_GPS_on();
                    }
                }
            } else {
                copter_leds_GPS_fast_blink();                                                                   //if GPS has fix, but home is not set, blink GPS LED fast
            }
            break;

        case (1):

            copter_leds_GPS_slow_blink();                                                                       //if GPS has valid reads, but no fix, blink GPS LED slow

            break;

        default:
            copter_leds_GPS_off();                                                                                      //if no valid GPS signal, turn GPS LED off
            break;
        }
    }

    if ( bitRead(g.copter_leds_mode, 2) ) {
        if (200 <= g.rc_7.control_in && g.rc_7.control_in < 400) {
            copter_leds_aux_on();                                                                                       //if sub-control of Ch7 is high, turn Aux LED on
        } else if (g.rc_7.control_in < 200) {
            copter_leds_aux_off();                                                                                      //if sub-control of Ch7 is low, turn Aux LED off
        }
    }

}

static void copter_leds_reset(void) {
    digitalWrite(COPTER_LED_1, COPTER_LED_OFF);
    digitalWrite(COPTER_LED_2, COPTER_LED_OFF);
    digitalWrite(COPTER_LED_3, COPTER_LED_OFF);
    digitalWrite(COPTER_LED_4, COPTER_LED_OFF);
    digitalWrite(COPTER_LED_5, COPTER_LED_OFF);
    digitalWrite(COPTER_LED_6, COPTER_LED_OFF);
    digitalWrite(COPTER_LED_7, COPTER_LED_OFF);
    digitalWrite(COPTER_LED_8, COPTER_LED_OFF);
}

static void copter_leds_on(void) {
    if ( !bitRead(g.copter_leds_mode, 2) ) {
        digitalWrite(COPTER_LED_1, COPTER_LED_ON);
    }
 #if CONFIG_APM_HARDWARE == APM_HARDWARE_APM2
    if ( !bitRead(g.copter_leds_mode, 3) ) {
        digitalWrite(COPTER_LED_2, COPTER_LED_ON);
    }
 #else
    digitalWrite(COPTER_LED_2, COPTER_LED_ON);
 #endif
    if ( !bitRead(g.copter_leds_mode, 1) ) {
        digitalWrite(COPTER_LED_3, COPTER_LED_ON);
    }
    digitalWrite(COPTER_LED_4, COPTER_LED_ON);
    digitalWrite(COPTER_LED_5, COPTER_LED_ON);
    digitalWrite(COPTER_LED_6, COPTER_LED_ON);
    digitalWrite(COPTER_LED_7, COPTER_LED_ON);
    digitalWrite(COPTER_LED_8, COPTER_LED_ON);
}

static void copter_leds_off(void) {
    if ( !bitRead(g.copter_leds_mode, 2) ) {
        digitalWrite(COPTER_LED_1, COPTER_LED_OFF);
    }
 #if CONFIG_APM_HARDWARE == APM_HARDWARE_APM2
    if ( !bitRead(g.copter_leds_mode, 3) ) {
        digitalWrite(COPTER_LED_2, COPTER_LED_OFF);
    }
 #else
    digitalWrite(COPTER_LED_2, COPTER_LED_OFF);
 #endif
    if ( !bitRead(g.copter_leds_mode, 1) ) {
        digitalWrite(COPTER_LED_3, COPTER_LED_OFF);
    }
    digitalWrite(COPTER_LED_4, COPTER_LED_OFF);
    digitalWrite(COPTER_LED_5, COPTER_LED_OFF);
    digitalWrite(COPTER_LED_6, COPTER_LED_OFF);
    digitalWrite(COPTER_LED_7, COPTER_LED_OFF);
    digitalWrite(COPTER_LED_8, COPTER_LED_OFF);
}

static void copter_leds_slow_blink(void) {
    copter_leds_motor_blink++;                                                                                                                                                  // this increments once every 1/10 second because it is in the 10hz loop
    if ( 0 < copter_leds_motor_blink && copter_leds_motor_blink < 6 ) {                                                                                                 // when the counter reaches 5 (1/2 sec), then toggle the leds
        copter_leds_off();
        if (  bitRead(g.copter_leds_mode, 5 ) && !bitRead(g.copter_leds_mode, 6 ) && copter_leds_nav_blink >0 ) {               // if blinking is called by the Nav Blinker...
            copter_leds_nav_blink--;                                                                                                                                                                            // decrement the Nav Blink counter
        }
    }else if (5 < copter_leds_motor_blink && copter_leds_motor_blink < 11) {
        copter_leds_on();
    }
    else copter_leds_motor_blink = 0;                                                                                                                                                   // start blink cycle again
}

static void copter_leds_fast_blink(void) {
    copter_leds_motor_blink++;                                                                                                                                                  // this increments once every 1/10 second because it is in the 10hz loop
    if ( 0 < copter_leds_motor_blink && copter_leds_motor_blink < 3 ) {                                                                                                 // when the counter reaches 3 (1/5 sec), then toggle the leds
        copter_leds_on();
    }else if (2 < copter_leds_motor_blink && copter_leds_motor_blink < 5) {
        copter_leds_off();
    }
    else copter_leds_motor_blink = 0;                                                                                                                                                   // start blink cycle again
}


static void copter_leds_oscillate(void) {
    copter_leds_motor_blink++;                                                                                                                                                  // this increments once every 1/10 second because it is in the 10hz loop
    if ( 0 < copter_leds_motor_blink && copter_leds_motor_blink < 3 ) {                                                                                                 // when the counter reaches 3 (1/5 sec), then toggle the leds
        if ( !bitRead(g.copter_leds_mode, 2) ) {
            digitalWrite(COPTER_LED_1, COPTER_LED_ON);
        }
 #if CONFIG_APM_HARDWARE == APM_HARDWARE_APM2
        if ( !bitRead(g.copter_leds_mode, 3) ) {
            digitalWrite(COPTER_LED_2, COPTER_LED_ON);
        }
 #else
        digitalWrite(COPTER_LED_2, COPTER_LED_ON);
 #endif
        if ( !bitRead(g.copter_leds_mode, 1) ) {
            digitalWrite(COPTER_LED_3, COPTER_LED_OFF);
        }
        digitalWrite(COPTER_LED_4, COPTER_LED_OFF);
        digitalWrite(COPTER_LED_5, COPTER_LED_ON);
        digitalWrite(COPTER_LED_6, COPTER_LED_ON);
        digitalWrite(COPTER_LED_7, COPTER_LED_OFF);
        digitalWrite(COPTER_LED_8, COPTER_LED_OFF);
    }else if (2 < copter_leds_motor_blink && copter_leds_motor_blink < 5) {
        if ( !bitRead(g.copter_leds_mode, 2) ) {
            digitalWrite(COPTER_LED_1, COPTER_LED_OFF);
        }
 #if CONFIG_APM_HARDWARE == APM_HARDWARE_APM2
        if ( !bitRead(g.copter_leds_mode, 3) ) {
            digitalWrite(COPTER_LED_2, COPTER_LED_OFF);
        }
 #else
        digitalWrite(COPTER_LED_2, COPTER_LED_OFF);
 #endif
        if ( !bitRead(g.copter_leds_mode, 1) ) {
            digitalWrite(COPTER_LED_3, COPTER_LED_ON);
        }
        digitalWrite(COPTER_LED_4, COPTER_LED_ON);
        digitalWrite(COPTER_LED_5, COPTER_LED_OFF);
        digitalWrite(COPTER_LED_6, COPTER_LED_OFF);
        digitalWrite(COPTER_LED_7, COPTER_LED_ON);
        digitalWrite(COPTER_LED_8, COPTER_LED_ON);
    }
    else copter_leds_motor_blink = 0;                                                                                           // start blink cycle again
}



static void copter_leds_GPS_on(void) {
    digitalWrite(COPTER_LED_3, COPTER_LED_ON);
}

static void copter_leds_GPS_off(void) {
    digitalWrite(COPTER_LED_3, COPTER_LED_OFF);
}

static void copter_leds_GPS_slow_blink(void) {
    copter_leds_GPS_blink++;                                                                                            // this increments once every 1/10 second because it is in the 10hz loop
    if ( 0 < copter_leds_GPS_blink && copter_leds_GPS_blink < 6 ) {                                             // when the counter reaches 5 (1/2 sec), then toggle the leds
        copter_leds_GPS_off();
        if (  bitRead(g.copter_leds_mode, 6 ) && copter_leds_nav_blink >0 ) {                           // if blinking is called by the Nav Blinker...
            copter_leds_nav_blink--;                                                                                                                    // decrement the Nav Blink counter
        }
    }else if (5 < copter_leds_GPS_blink && copter_leds_GPS_blink < 11) {
        copter_leds_GPS_on();
    }
    else copter_leds_GPS_blink = 0;                                                                                             // start blink cycle again
}

static void copter_leds_GPS_fast_blink(void) {
    copter_leds_GPS_blink++;                                                                                            // this increments once every 1/10 second because it is in the 10hz loop
    if ( 0 < copter_leds_GPS_blink && copter_leds_GPS_blink < 3 ) {                                             // when the counter reaches 3 (1/5 sec), then toggle the leds
        copter_leds_GPS_off();
    }else if (2 < copter_leds_GPS_blink && copter_leds_GPS_blink < 5) {
        copter_leds_GPS_on();
    }
    else copter_leds_GPS_blink = 0;                                                                                             // start blink cycle again
}

static void copter_leds_aux_off(void){
    digitalWrite(COPTER_LED_1, COPTER_LED_OFF);
}

static void copter_leds_aux_on(void){
    digitalWrite(COPTER_LED_1, COPTER_LED_ON);
}

void piezo_on(){
    digitalWrite(PIEZO_PIN,HIGH);
}

void piezo_off(){
    digitalWrite(PIEZO_PIN,LOW);
}

void piezo_beep(){                                                                                                                      // Note! This command should not be used in time sensitive loops
    piezo_on();
    delay(100);
    piezo_off();
}

#endif                  //COPTER_LEDS// Main state machine loop for AP_Limits. Called from slow or superslow loop.

#if AP_LIMITS == ENABLED

uint8_t lim_state = 0, lim_old_state = 0;

void set_recovery_home_alt() {

    uint32_t return_altitude_cm_ahl = 0;     // in centimeters above home level.
    uint32_t amin_meters_ahl, amax_meters_ahl;

    // for flying vehicles only
    if (altitude_limit.enabled()) {

        amin_meters_ahl = (uint32_t) (altitude_limit.min_alt());
        amax_meters_ahl = (uint32_t) (altitude_limit.max_alt());

        // See if we have a meaningful setting
        if (amax_meters_ahl && ((amax_meters_ahl - amin_meters_ahl) > 1)) {
            // there is a max_alt set
            // set a return altitude that is halfway between the minimum and maximum altitude setting.
            // return_altitude is in centimeters, not meters, so we multiply
            return_altitude_cm_ahl = (uint32_t) (home.alt + (100 * (uint16_t) ((amax_meters_ahl - amin_meters_ahl) / 2)));
        }
    } else {
        return_altitude_cm_ahl = (uint32_t) (home.alt + g.RTL_altitude*100);
    }
    // final sanity check
    // if our return is less than 4 meters from ground, set it to 4m, to clear "people" height.
    if ((return_altitude_cm_ahl - (uint32_t) home.alt) < 400) {
        return_altitude_cm_ahl = home.alt + 400;
    }
    guided_WP.id = 0;
    guided_WP.p1 = 0;
    guided_WP.options = 0;
    guided_WP.lat = home.lat;
    guided_WP.lng = home.lng;
    guided_WP.alt = return_altitude_cm_ahl;
}

static void limits_loop() {

    lim_state = limits.state();

    // Use limits channel to determine LIMITS_ENABLED or LIMITS_DISABLED state
    if (lim_state != LIMITS_DISABLED  && limits.channel() !=0 && APM_RC.InputCh(limits.channel()-1) < LIMITS_ENABLE_PWM) {
        limits.set_state(LIMITS_DISABLED);
    }
    else if (lim_state == LIMITS_DISABLED && limits.channel() !=0 && APM_RC.InputCh(limits.channel()-1) >= LIMITS_ENABLE_PWM) {
        limits.set_state(LIMITS_ENABLED);
    }

    if ((uint32_t) millis() - (uint32_t) limits.last_status_update > 1000) {     // more than a second has passed - time for an update
        gcs_send_message(MSG_LIMITS_STATUS);
    }

    if (lim_state != lim_old_state) {     // state changed
        lim_old_state = lim_state;         // we only use lim_oldstate here, for reporting purposes. So, reset it.
        gcs_send_message(MSG_LIMITS_STATUS);

        if (limits.debug()) switch (lim_state) {
            case LIMITS_INIT: gcs_send_text_P(SEVERITY_LOW,PSTR("Limits - State change: INIT")); break;
            case LIMITS_DISABLED: gcs_send_text_P(SEVERITY_LOW,PSTR("Limits - State change: DISABLED")); break;
            case LIMITS_ENABLED: gcs_send_text_P(SEVERITY_LOW,PSTR("Limits - State change: ENABLED")); break;
            case LIMITS_TRIGGERED: gcs_send_text_P(SEVERITY_LOW,PSTR("Limits - State change: TRIGGERED")); break;
            case LIMITS_RECOVERING: gcs_send_text_P(SEVERITY_LOW,PSTR("Limits - State change: RECOVERING")); break;
            case LIMITS_RECOVERED: gcs_send_text_P(SEVERITY_LOW,PSTR("Limits - State change: RECOVERED")); break;
            default: gcs_send_text_P(SEVERITY_LOW,PSTR("Limits - State change: UNKNOWN")); break;
            }
    }

    switch (limits.state()) {

    // have not initialized yet
    case LIMITS_INIT:
        if (limits.init()) {                 // initialize system

            // See what the "master" on/off swith is and go to the appropriate start state
            if (!limits.enabled()) {
                limits.set_state(LIMITS_DISABLED);
            }
            else {
                limits.set_state(LIMITS_ENABLED);
            }
        }
        break;

    // We have been switched off
    case LIMITS_DISABLED:

        // check if we have been switched on
        if (limits.enabled()) {
            limits.set_state(LIMITS_ENABLED);
            break;
        }
        break;

    // Limits module is enabled
    case LIMITS_ENABLED:

        // check if we've been switched off
        if (!limits.enabled()) {
            limits.set_state(LIMITS_DISABLED);
            break;
        }

        // Until motors are armed, do nothing, just wait in ENABLED state
        if (!motors.armed()) {

            // we are waiting for motors to arm
            // do nothing
            break;
        }

        bool required_only;

        required_only = (limits.last_clear == 0);                 // if we haven't yet 'cleared' all limits, check required limits only

        // check if any limits have been breached and trigger if they have
        if  (limits.check_triggered(required_only)) {

            //
            // TRIGGER - BREACH OF LIMITS
            //
            // make a note of which limits triggered, so if we know if we recovered them
            limits.mods_recovering = limits.mods_triggered;

            limits.last_action = 0;
            limits.last_trigger = millis();
            limits.breach_count++;

            limits.set_state(LIMITS_TRIGGERED);
            break;
        }

        if (motors.armed() && limits.enabled() && !limits.mods_triggered) {

            // All clear.
	    if (limits.debug()) gcs_send_text_P(SEVERITY_LOW, PSTR("Limits - All Clear"));
            limits.last_clear = millis();
        }

        break;

    // Limits have been triggered
    case LIMITS_TRIGGERED:

        // check if we've been switched off
        if (!limits.enabled()) {
            limits.set_state(LIMITS_DISABLED);
            break;
        }

#if LIMITS_TRIGGERED_PIN > 0
        digitalWrite(LIMITS_TRIGGERED_PIN, HIGH);
#endif

        if (limits.debug()) {
		if (limits.mods_triggered & LIMIT_GPSLOCK) gcs_send_text_P(SEVERITY_LOW, PSTR("!GPSLock"));
		if (limits.mods_triggered & LIMIT_GEOFENCE) gcs_send_text_P(SEVERITY_LOW, PSTR("!Geofence"));
		if (limits.mods_triggered & LIMIT_ALTITUDE) gcs_send_text_P(SEVERITY_LOW, PSTR("!Altitude"));
        }

        // If the motors are not armed, we have triggered pre-arm checks. Do nothing
        if (motors.armed() == false) {
            limits.set_state(LIMITS_ENABLED);                     // go back to checking limits
            break;
        }

        // If we are triggered but no longer in breach, that means we recovered
        // somehow, via auto recovery or pilot action
        if (!limits.check_all()) {
            limits.last_recovery = millis();
            limits.set_state(LIMITS_RECOVERED);
            break;
        }
        else {
            limits.set_state(LIMITS_RECOVERING);
            limits.last_action = 0;                     // reset timer
            // We are about to take action on a real breach. Make sure we notify immediately
            gcs_send_message(MSG_LIMITS_STATUS);
            break;
        }
        break;

    // Take action to recover
    case LIMITS_RECOVERING:
        // If the motors are not armed, we have triggered pre-arm checks. Do nothing
        if (motors.armed() == false) {
            limits.set_state(LIMITS_ENABLED);                     // go back to checking limits
            break;
        }

        // check if we've been switched off
        if (!limits.enabled() && limits.old_mode_switch == oldSwitchPosition) {
            limits.old_mode_switch = 0;
            reset_control_switch();
            limits.set_state(LIMITS_DISABLED);
            break;
        }

        // Still need action?
        if (limits.check_all() == 0) {                 // all triggers clear
            limits.set_state(LIMITS_RECOVERED);
            break;
        }

        if (limits.mods_triggered != limits.mods_recovering)  {                 // if any *new* triggers, hit the trigger again
            //
            // TRIGGER - BREACH OF LIMITS
            //
            // make a note of which limits triggered, so if we know if we recovered them
            limits.mods_recovering = limits.mods_triggered;

            limits.last_action = 0;
            limits.last_trigger = millis();
            limits.breach_count++;

            limits.set_state(LIMITS_TRIGGERED);
            limits.set_state(LIMITS_TRIGGERED);
            break;
        }

        // Recovery Action
        // if there was no previous action, take action, take note of time  send GCS.
        if (limits.last_action == 0) {

            // save mode switch
            limits.old_mode_switch = oldSwitchPosition;


//				// Take action
//				// This ensures no "radical" RTL, like a full throttle take-off,happens if something triggers at ground level
//				if ((uint32_t) current_loc.alt < ((uint32_t)home.alt * 200) ) { // we're under 2m (200cm), already at "people" height or on the ground
//					if (limits.debug()) gcs_send_text_P(SEVERITY_LOW,PSTR("Limits Action: near ground - do nothing"));
//					// TODO: Will this work for a plane? Does it make sense in general?
//
//					//set_mode(LAND);
//					limits.last_action = millis(); // start counter
//				    gcs_send_message(MSG_LIMITS_STATUS);
//
//					break;
//				}


            // TODO: This applies only to planes - hold for porting
//					if (control_mode == MANUAL && g.auto_trim) {
//					            // make sure we don't auto trim the surfaces on this change
//					            control_mode = STABILIZE;
//					}


            switch (limits.recmode()) {

            case 0:                                     // RTL mode

                if (limits.debug()) gcs_send_text_P(SEVERITY_LOW,PSTR("Limits Action - RTL"));

                set_mode(RTL);
                limits.last_action = millis();
                gcs_send_message(MSG_LIMITS_STATUS);
                break;

            case 1:                                     // Bounce mode

                if (limits.debug()) gcs_send_text_P(SEVERITY_LOW,PSTR("Limits Action - bounce mode, POSITION"));
                // ALT_HOLD gives us yaw hold, roll& pitch hold and throttle hold.
                // It is like position hold, but without manual throttle control.

                //set_recovery_home_alt();
                set_mode(POSITION);
                throttle_mode = THROTTLE_AUTO;
                limits.last_action = millis();
                gcs_send_message(MSG_LIMITS_STATUS);
                break;

            }
            break;
        }


        // In bounce mode, take control for 3 seconds, and then wait for the pilot to make us "safe".
        // If the vehicle does not recover, the escalation action will trigger.
        if (limits.recmode() == 1) {

            if (control_mode == POSITION && ((uint32_t)millis() - (uint32_t)limits.last_action) > 3000) {
                if (limits.debug()) gcs_send_text_P(SEVERITY_LOW,PSTR("Limits Recovery Bounce: Returning control to pilot"));
                set_mode(STABILIZE);
            } else if (control_mode == STABILIZE && ((uint32_t)millis() - (uint32_t)limits.last_action) > 6000) {
                // after 3 more seconds, reset action counter to take action again
                limits.last_action = 0;
            }
        }

        // ESCALATE We have not recovered after 2 minutes of recovery action

        if (((uint32_t)millis() - (uint32_t)limits.last_action) > 120000 ) {

            // TODO: Secondary recovery
            if (limits.debug()) gcs_send_text_P(SEVERITY_LOW,PSTR("Limits Recovery Escalation: RTL"));
            set_mode(RTL);
            limits.last_action = millis();
            break;
        }
        break;

    // Have recovered, relinquish control and re-enable
    case LIMITS_RECOVERED:


        // check if we've been switched off
        if (!limits.enabled()) {
            limits.set_state(LIMITS_DISABLED);
            break;
        }

#if LIMITS_TRIGGERED_PIN > 0
        digitalWrite(LIMITS_TRIGGERED_PIN, LOW);
#endif

        // Reset action counter
        limits.last_action = 0;

        if (((uint32_t)millis() - (uint32_t)limits.last_recovery) > (uint32_t)(limits.safetime() * 1000)) {                 // Wait "safetime" seconds of recovery before we give back control

            // Our recovery action worked.
            limits.set_state(LIMITS_ENABLED);

            // Switch to stabilize
            if (limits.debug()) gcs_send_text_P(SEVERITY_LOW,PSTR("Limits - Returning controls"));
            set_mode(STABILIZE);                            limits.last_recovery = millis();

            break;
        }
        break;

    default:
        if (limits.debug()) gcs_send_text_P(SEVERITY_LOW,PSTR("Limits: unknown state"));
        break;
    }
}

// This function below, should really be in the AP_Limits class, but it is impossible to untangle the mavlink includes.

void limits_send_mavlink_status(mavlink_channel_t chan) {

    limits.last_status_update = millis();

    if (limits.enabled()) {
        mavlink_msg_limits_status_send(chan,
                                       (uint8_t) limits.state(),
                                       (uint32_t) limits.last_trigger,
                                       (uint32_t) limits.last_action,
                                       (uint32_t) limits.last_recovery,
                                       (uint32_t) limits.last_clear,
                                       (uint16_t) limits.breach_count,
                                       (LimitModuleBits) limits.mods_enabled,
                                       (LimitModuleBits) limits.mods_required,
                                       (LimitModuleBits) limits.mods_triggered);
    }
}

#endif
// -*- tab-width: 4; Mode: C++; c-basic-offset: 4; indent-tabs-mode: nil -*-

#if LOGGING_ENABLED == ENABLED

// Code to Write and Read packets from DataFlash log memory
// Code to interact with the user to dump or erase logs

 #define HEAD_BYTE1      0xA3   // Decimal 163
 #define HEAD_BYTE2      0x95   // Decimal 149
 #define END_BYTE        0xBA   // Decimal 186


// These are function definitions so the Menu can be constructed before the functions
// are defined below. Order matters to the compiler.
static bool     print_log_menu(void);
static int8_t   dump_log(uint8_t argc,                  const Menu::arg *argv);
static int8_t   erase_logs(uint8_t argc,                const Menu::arg *argv);
static int8_t   select_logs(uint8_t argc,               const Menu::arg *argv);

// This is the help function
// PSTR is an AVR macro to read strings from flash memory
// printf_P is a version of print_f that reads from flash memory
//static int8_t	help_log(uint8_t argc,          const Menu::arg *argv)
/*{
 *       Serial.printf_P(PSTR("\n"
 *                                                "Commands:\n"
 *                                                "  dump <n>"
 *                                                "  erase (all logs)\n"
 *                                                "  enable <name> | all\n"
 *                                                "  disable <name> | all\n"
 *                                                "\n"));
 *   return 0;
 *  }*/

// Creates a constant array of structs representing menu options
// and stores them in Flash memory, not RAM.
// User enters the string in the console to call the functions on the right.
// See class Menu in AP_Coommon for implementation details
const struct Menu::command log_menu_commands[] PROGMEM = {
    {"dump",        dump_log},
    {"erase",       erase_logs},
    {"enable",      select_logs},
    {"disable",     select_logs}
};

static int32_t get_int(float f)
{
    float_int.float_value = f;
    return float_int.int_value;
}

static float get_float(int32_t i)
{
    float_int.int_value = i;
    return float_int.float_value;
}


// A Macro to create the Menu
MENU2(log_menu, "Log", log_menu_commands, print_log_menu);

static bool
print_log_menu(void)
{
    int16_t log_start;
    int16_t log_end;
    int16_t temp;
    int16_t last_log_num = DataFlash.find_last_log();

    uint16_t num_logs = DataFlash.get_num_logs();

    Serial.printf_P(PSTR("logs enabled: "));

    if (0 == g.log_bitmask) {
        Serial.printf_P(PSTR("none"));
    }else{
        if (g.log_bitmask & MASK_LOG_ATTITUDE_FAST) Serial.printf_P(PSTR(" ATTITUDE_FAST"));
        if (g.log_bitmask & MASK_LOG_ATTITUDE_MED) Serial.printf_P(PSTR(" ATTITUDE_MED"));
        if (g.log_bitmask & MASK_LOG_GPS) Serial.printf_P(PSTR(" GPS"));
        if (g.log_bitmask & MASK_LOG_PM) Serial.printf_P(PSTR(" PM"));
        if (g.log_bitmask & MASK_LOG_CTUN) Serial.printf_P(PSTR(" CTUN"));
        if (g.log_bitmask & MASK_LOG_NTUN) Serial.printf_P(PSTR(" NTUN"));
        if (g.log_bitmask & MASK_LOG_RAW) Serial.printf_P(PSTR(" RAW"));
        if (g.log_bitmask & MASK_LOG_CMD) Serial.printf_P(PSTR(" CMD"));
        if (g.log_bitmask & MASK_LOG_CUR) Serial.printf_P(PSTR(" CURRENT"));
        if (g.log_bitmask & MASK_LOG_MOTORS) Serial.printf_P(PSTR(" MOTORS"));
        if (g.log_bitmask & MASK_LOG_OPTFLOW) Serial.printf_P(PSTR(" OPTFLOW"));
        if (g.log_bitmask & MASK_LOG_PID) Serial.printf_P(PSTR(" PID"));
        if (g.log_bitmask & MASK_LOG_ITERM) Serial.printf_P(PSTR(" ITERM"));
    }

    Serial.println();

    if (num_logs == 0) {
        Serial.printf_P(PSTR("\nNo logs\n\n"));
    }else{
        Serial.printf_P(PSTR("\n%u logs\n"), (unsigned)num_logs);

        for(int16_t i=num_logs; i>=1; i--) {
            int16_t last_log_start = log_start, last_log_end = log_end;
            temp = last_log_num-i+1;
            DataFlash.get_log_boundaries(temp, log_start, log_end);
            Serial.printf_P(PSTR("Log %d,    start %d,   end %d\n"), (int)temp, (int)log_start, (int)log_end);
            if (last_log_start == log_start && last_log_end == log_end) {
                // we are printing bogus logs
                break;
            }
        }
        Serial.println();
    }
    return(true);
}

static int8_t
dump_log(uint8_t argc, const Menu::arg *argv)
{
    int16_t dump_log;
    int16_t dump_log_start;
    int16_t dump_log_end;
    int16_t last_log_num;

    // check that the requested log number can be read
    dump_log = argv[1].i;
    last_log_num = DataFlash.find_last_log();

    if (dump_log == -2) {
        for(uint16_t count=1; count<=DataFlash.df_NumPages; count++) {
            DataFlash.StartRead(count);
            Serial.printf_P(PSTR("DF page, log file #, log page: %d,\t"), (int)count);
            Serial.printf_P(PSTR("%d,\t"), (int)DataFlash.GetFileNumber());
            Serial.printf_P(PSTR("%d\n"), (int)DataFlash.GetFilePage());
        }
        return(-1);
    } else if (dump_log <= 0) {
        Serial.printf_P(PSTR("dumping all\n"));
        Log_Read(1, DataFlash.df_NumPages);
        return(-1);
    } else if ((argc != 2) || (dump_log <= (last_log_num - DataFlash.get_num_logs())) || (dump_log > last_log_num)) {
        Serial.printf_P(PSTR("bad log number\n"));
        return(-1);
    }

    DataFlash.get_log_boundaries(dump_log, dump_log_start, dump_log_end);
    /*Serial.printf_P(PSTR("Dumping Log number %d,    start %d,   end %d\n"),
     *                         dump_log,
     *                         dump_log_start,
     *                         dump_log_end);
     */
    Log_Read(dump_log_start, dump_log_end);
    //Serial.printf_P(PSTR("Done\n"));
    return (0);
}

static void do_erase_logs(void)
{
	gcs_send_text_P(SEVERITY_LOW, PSTR("Erasing logs\n"));
    DataFlash.EraseAll(mavlink_delay);
	gcs_send_text_P(SEVERITY_LOW, PSTR("Log erase complete\n"));
}

static int8_t
erase_logs(uint8_t argc, const Menu::arg *argv)
{
    in_mavlink_delay = true;
    do_erase_logs();
    in_mavlink_delay = false;
    return 0;
}

static int8_t
select_logs(uint8_t argc, const Menu::arg *argv)
{
    uint16_t bits;

    if (argc != 2) {
        Serial.printf_P(PSTR("missing log type\n"));
        return(-1);
    }

    bits = 0;

    // Macro to make the following code a bit easier on the eye.
    // Pass it the capitalised name of the log option, as defined
    // in defines.h but without the LOG_ prefix.  It will check for
    // that name as the argument to the command, and set the bit in
    // bits accordingly.
    //
    if (!strcasecmp_P(argv[1].str, PSTR("all"))) {
        bits = ~0;
    } else {
 #define TARG(_s)        if (!strcasecmp_P(argv[1].str, PSTR(# _s))) bits |= MASK_LOG_ ## _s
        TARG(ATTITUDE_FAST);
        TARG(ATTITUDE_MED);
        TARG(GPS);
        TARG(PM);
        TARG(CTUN);
        TARG(NTUN);
        TARG(MODE);
        TARG(RAW);
        TARG(CMD);
        TARG(CUR);
        TARG(MOTORS);
        TARG(OPTFLOW);
        TARG(PID);
        TARG(ITERM);
 #undef TARG
    }

    if (!strcasecmp_P(argv[0].str, PSTR("enable"))) {
        g.log_bitmask.set_and_save(g.log_bitmask | bits);
    }else{
        g.log_bitmask.set_and_save(g.log_bitmask & ~bits);
    }

    return(0);
}

static int8_t
process_logs(uint8_t argc, const Menu::arg *argv)
{
    log_menu.run();
    return 0;
}

// print_latlon - prints an latitude or longitude value held in an int32_t
// probably this should be moved to AP_Common
void print_latlon(BetterStream *s, int32_t lat_or_lon)
{
    int32_t dec_portion, frac_portion;
    int32_t abs_lat_or_lon = labs(lat_or_lon);

    // extract decimal portion (special handling of negative numbers to ensure we round towards zero)
    dec_portion = abs_lat_or_lon / T7;

    // extract fractional portion
    frac_portion = abs_lat_or_lon - dec_portion*T7;

    // print output including the minus sign
    if( lat_or_lon < 0 ) {
        s->printf_P(PSTR("-"));
    }
    s->printf_P(PSTR("%ld.%07ld"),(long)dec_portion,(long)frac_portion);
}

// Write an GPS packet. Total length : 31 bytes
static void Log_Write_GPS()
{
    DataFlash.WriteByte(HEAD_BYTE1);
    DataFlash.WriteByte(HEAD_BYTE2);
    DataFlash.WriteByte(LOG_GPS_MSG);

    DataFlash.WriteLong(g_gps->time);                                                   // 1
    DataFlash.WriteByte(g_gps->num_sats);                                       // 2

    DataFlash.WriteLong(current_loc.lat);                                       // 3
    DataFlash.WriteLong(current_loc.lng);                                       // 4
    DataFlash.WriteLong(current_loc.alt);                                       // 5
    DataFlash.WriteLong(g_gps->altitude);                                       // 6

    DataFlash.WriteInt(g_gps->ground_speed);                                    // 7
    DataFlash.WriteLong(g_gps->ground_course);                  // 8

    DataFlash.WriteByte(END_BYTE);
}

// Read a GPS packet
static void Log_Read_GPS()
{
    int32_t temp1   = DataFlash.ReadLong();                     // 1 time
    int8_t temp2    = DataFlash.ReadByte();                     // 2 sats
    int32_t temp3   = DataFlash.ReadLong();                     // 3 lat
    int32_t temp4   = DataFlash.ReadLong();                     // 4 lon
    float temp5     = DataFlash.ReadLong() / 100.0;     // 5 sensor alt
    float temp6     = DataFlash.ReadLong() / 100.0;     // 6 gps alt
    int16_t temp7   = DataFlash.ReadInt();                      // 7 ground speed
    int32_t temp8   = DataFlash.ReadLong();                     // 8 ground course

    //  1   2    3      4     5      6      7    8
    Serial.printf_P(PSTR("GPS, %ld, %d, "),
                    (long)temp1,                                                // 1 time
                    (int)temp2);                                                // 2 sats
    print_latlon(&Serial, temp3);
    Serial.print_P(PSTR(", "));
    print_latlon(&Serial, temp4);
    Serial.printf_P(PSTR(", %4.4f, %4.4f, %d, %ld\n"),
                    temp5,                                              // 5 gps alt
                    temp6,                                              // 6 sensor alt
                    (int)temp7,                                                 // 7 ground speed
                    (long)temp8);                                               // 8 ground course
}

 #if INERTIAL_NAV == ENABLED
static void Log_Write_Raw()
{
    Vector3f accel = imu.get_accel();

    DataFlash.WriteByte(HEAD_BYTE1);
    DataFlash.WriteByte(HEAD_BYTE2);
    DataFlash.WriteByte(LOG_RAW_MSG);

    DataFlash.WriteLong(get_int(accels_velocity.x));
    DataFlash.WriteInt(x_actual_speed);
    DataFlash.WriteLong(get_int(accels_velocity.y));
    DataFlash.WriteInt(y_actual_speed);
    DataFlash.WriteLong(get_int(accels_velocity.z));
    DataFlash.WriteInt(climb_rate_actual);

    //DataFlash.WriteLong(get_int(accel.x));
    //DataFlash.WriteLong(get_int(accel.y));
    //DataFlash.WriteLong(get_int(accel.z));

    DataFlash.WriteByte(END_BYTE);
}

// Read a raw accel/gyro packet
static void Log_Read_Raw()
{
    /*
     *  float logvar;
     *  Serial.printf_P(PSTR("RAW,"));
     *  for (int16_t y = 0; y < 9; y++) {
     *       logvar = get_float(DataFlash.ReadLong());
     *       Serial.print(logvar);
     *       Serial.print(", ");
     *  }
     *  Serial.println(" ");
     */

    float vx        = get_float(DataFlash.ReadLong());
    int16_t sx      = DataFlash.ReadInt();
    float vy        = get_float(DataFlash.ReadLong());
    int16_t sy      = DataFlash.ReadInt();
    float vz        = get_float(DataFlash.ReadLong());
    int16_t sz      = DataFlash.ReadInt();

    Serial.printf_P(PSTR("RAW, %1.4f, %d, %1.4f, %d, %1.4f, %d\n"),
                    vx,
                    (int)sx,
                    vy,
                    (int)sy,
                    vz,
                    (int)sz);

}
 #else
static void Log_Write_Raw()
{
    Vector3f gyro = imu.get_gyro();
    Vector3f accel = imu.get_accel();

    DataFlash.WriteByte(HEAD_BYTE1);
    DataFlash.WriteByte(HEAD_BYTE2);
    DataFlash.WriteByte(LOG_RAW_MSG);

    DataFlash.WriteLong(get_int(gyro.x));
    DataFlash.WriteLong(get_int(gyro.y));
    DataFlash.WriteLong(get_int(gyro.z));

    DataFlash.WriteLong(get_int(accel.x));
    DataFlash.WriteLong(get_int(accel.y));
    DataFlash.WriteLong(get_int(accel.z));

    DataFlash.WriteByte(END_BYTE);

	/*
	DataFlash.WriteByte(HEAD_BYTE1);
	DataFlash.WriteByte(HEAD_BYTE2);
	DataFlash.WriteByte(LOG_RAW_MSG);
	DataFlash.WriteLong(get_int(ahrs._omega_I.x));
	DataFlash.WriteLong(get_int(ahrs._omega_I.y));

    DataFlash.WriteByte(END_BYTE);
	*/
}

// Read a raw accel/gyro packet
static void Log_Read_Raw()
{
    float logvar;
    Serial.printf_P(PSTR("RAW,"));
    for (int16_t y = 0; y < 6; y++) {
        logvar = get_float(DataFlash.ReadLong());
        Serial.print(logvar);
        Serial.print_P(PSTR(", "));
    }
    Serial.println_P(PSTR(" "));

	/*
	float temp1 = get_float(DataFlash.ReadLong());
	float temp2 = get_float(DataFlash.ReadLong());

	Serial.printf_P(PSTR("RAW, %4.4f, %4.4f\n"),
			temp1,
			temp2);
	*/
}
 #endif


// Write an Current data packet. Total length : 16 bytes
static void Log_Write_Current()
{
    DataFlash.WriteByte(HEAD_BYTE1);
    DataFlash.WriteByte(HEAD_BYTE2);
    DataFlash.WriteByte(LOG_CURRENT_MSG);

    DataFlash.WriteInt(g.rc_3.control_in);                      // 1
    DataFlash.WriteLong(throttle_integrator);                   // 2
    DataFlash.WriteInt(battery_voltage1     * 100.0);           // 3
    DataFlash.WriteInt(current_amps1        * 100.0);           // 4
    DataFlash.WriteInt(current_total1);                                 // 5

    DataFlash.WriteByte(END_BYTE);
}

// Read a Current packet
static void Log_Read_Current()
{
    int16_t temp1 = DataFlash.ReadInt();                        // 1
    int32_t temp2 = DataFlash.ReadLong();                       // 2
    float temp3 = DataFlash.ReadInt() / 100.f;          // 3
    float temp4 = DataFlash.ReadInt() / 100.f;          // 4
    int16_t temp5 = DataFlash.ReadInt();                        // 5

    //  1    2    3      4      5
    Serial.printf_P(PSTR("CURR, %d, %ld, %4.4f, %4.4f, %d\n"),
                    (int)temp1,
                    (long)temp2,
                    temp3,
                    temp4,
                    (int)temp5);
}

// Write an Motors packet. Total length : 12 ~ 20 bytes
static void Log_Write_Motors()
{
    DataFlash.WriteByte(HEAD_BYTE1);
    DataFlash.WriteByte(HEAD_BYTE2);
    DataFlash.WriteByte(LOG_MOTORS_MSG);

 #if FRAME_CONFIG ==     TRI_FRAME
    DataFlash.WriteInt(motors.motor_out[AP_MOTORS_MOT_1]);    //1
    DataFlash.WriteInt(motors.motor_out[AP_MOTORS_MOT_2]);    //2
    DataFlash.WriteInt(motors.motor_out[AP_MOTORS_MOT_4]);    //3
    DataFlash.WriteInt(g.rc_4.radio_out);    //4

 #elif FRAME_CONFIG == HEXA_FRAME
    DataFlash.WriteInt(motors.motor_out[AP_MOTORS_MOT_1]);    //1
    DataFlash.WriteInt(motors.motor_out[AP_MOTORS_MOT_2]);    //2
    DataFlash.WriteInt(motors.motor_out[AP_MOTORS_MOT_3]);    //3
    DataFlash.WriteInt(motors.motor_out[AP_MOTORS_MOT_4]);    //4
    DataFlash.WriteInt(motors.motor_out[AP_MOTORS_MOT_5]);    //5
    DataFlash.WriteInt(motors.motor_out[AP_MOTORS_MOT_6]);    //6

 #elif FRAME_CONFIG == Y6_FRAME
    //left
    DataFlash.WriteInt(motors.motor_out[AP_MOTORS_MOT_2]);    //1
    DataFlash.WriteInt(motors.motor_out[AP_MOTORS_MOT_3]);    //2
    //right
    DataFlash.WriteInt(motors.motor_out[AP_MOTORS_MOT_5]);    //3
    DataFlash.WriteInt(motors.motor_out[AP_MOTORS_MOT_1]);    //4
    //back
    DataFlash.WriteInt(motors.motor_out[AP_MOTORS_MOT_6]);    //5
    DataFlash.WriteInt(motors.motor_out[AP_MOTORS_MOT_4]);    //6

 #elif FRAME_CONFIG == OCTA_FRAME || FRAME_CONFIG == OCTA_QUAD_FRAME
    DataFlash.WriteInt(motors.motor_out[AP_MOTORS_MOT_1]);    //1
    DataFlash.WriteInt(motors.motor_out[AP_MOTORS_MOT_2]);    //2
    DataFlash.WriteInt(motors.motor_out[AP_MOTORS_MOT_3]);    //3
    DataFlash.WriteInt(motors.motor_out[AP_MOTORS_MOT_4]);    //4
    DataFlash.WriteInt(motors.motor_out[AP_MOTORS_MOT_5]);    //5
    DataFlash.WriteInt(motors.motor_out[AP_MOTORS_MOT_6]);     //6
    DataFlash.WriteInt(motors.motor_out[AP_MOTORS_MOT_7]);    //7
    DataFlash.WriteInt(motors.motor_out[AP_MOTORS_MOT_8]);    //8

 #elif FRAME_CONFIG == HELI_FRAME
    DataFlash.WriteInt(motors.motor_out[AP_MOTORS_MOT_1]);    //1
    DataFlash.WriteInt(motors.motor_out[AP_MOTORS_MOT_2]);    //2
    DataFlash.WriteInt(motors.motor_out[AP_MOTORS_MOT_3]);    //3
    DataFlash.WriteInt(motors.motor_out[AP_MOTORS_MOT_4]);    //4
    DataFlash.WriteInt(motors.ext_gyro_gain);    //5

 #else        // quads
    DataFlash.WriteInt(motors.motor_out[AP_MOTORS_MOT_1]);    //1
    DataFlash.WriteInt(motors.motor_out[AP_MOTORS_MOT_2]);    //2
    DataFlash.WriteInt(motors.motor_out[AP_MOTORS_MOT_3]);    //3
    DataFlash.WriteInt(motors.motor_out[AP_MOTORS_MOT_4]);    //4
 #endif

    DataFlash.WriteByte(END_BYTE);
}

// Read a Motors packet.
static void Log_Read_Motors()
{
 #if FRAME_CONFIG == HEXA_FRAME || FRAME_CONFIG == Y6_FRAME
    int16_t temp1 = DataFlash.ReadInt();                        // 1
    int16_t temp2 = DataFlash.ReadInt();                        // 2
    int16_t temp3 = DataFlash.ReadInt();                        // 3
    int16_t temp4 = DataFlash.ReadInt();                        // 4
    int16_t temp5 = DataFlash.ReadInt();                        // 5
    int16_t temp6 = DataFlash.ReadInt();                        // 6
    // 1  2   3   4   5   6
    Serial.printf_P(PSTR("MOT, %d, %d, %d, %d, %d, %d\n"),
                    (int)temp1,         //1
                    (int)temp2,         //2
                    (int)temp3,         //3
                    (int)temp4,         //4
                    (int)temp5,         //5
                    (int)temp6);        //6

 #elif FRAME_CONFIG == OCTA_FRAME || FRAME_CONFIG == OCTA_QUAD_FRAME
    int16_t temp1 = DataFlash.ReadInt();                        // 1
    int16_t temp2 = DataFlash.ReadInt();                        // 2
    int16_t temp3 = DataFlash.ReadInt();                        // 3
    int16_t temp4 = DataFlash.ReadInt();                        // 4
    int16_t temp5 = DataFlash.ReadInt();                        // 5
    int16_t temp6 = DataFlash.ReadInt();                        // 6
    int16_t temp7 = DataFlash.ReadInt();                        // 7
    int16_t temp8 = DataFlash.ReadInt();                        // 8
    // 1   2   3   4   5   6   7   8
    Serial.printf_P(PSTR("MOT, %d, %d, %d, %d, %d, %d, %d, %d\n"),
                    (int)temp1,         //1
                    (int)temp2,         //2
                    (int)temp3,         //3
                    (int)temp4,         //4
                    (int)temp5,         //5
                    (int)temp6,         //6
                    (int)temp7,         //7
                    (int)temp8);        //8

 #elif FRAME_CONFIG == HELI_FRAME
    int16_t temp1 = DataFlash.ReadInt();                        // 1
    int16_t temp2 = DataFlash.ReadInt();                        // 2
    int16_t temp3 = DataFlash.ReadInt();                        // 3
    int16_t temp4 = DataFlash.ReadInt();                        // 4
    int16_t temp5 = DataFlash.ReadInt();                        // 5
    // 1   2   3   4   5
    Serial.printf_P(PSTR("MOT, %d, %d, %d, %d, %d\n"),
                    (int)temp1,         //1
                    (int)temp2,         //2
                    (int)temp3,         //3
                    (int)temp4,         //4
                    (int)temp5);        //5

 #else        // quads, TRIs
    int16_t temp1 = DataFlash.ReadInt();                        // 1
    int16_t temp2 = DataFlash.ReadInt();                        // 2
    int16_t temp3 = DataFlash.ReadInt();                        // 3
    int16_t temp4 = DataFlash.ReadInt();                        // 4

    // 1   2   3   4
    Serial.printf_P(PSTR("MOT, %d, %d, %d, %d\n"),
                    (int)temp1,         //1
                    (int)temp2,         //2
                    (int)temp3,         //3
                    (int)temp4);     //4;
 #endif
}

// Write an optical flow packet. Total length : 30 bytes
static void Log_Write_Optflow()
{
 #ifdef OPTFLOW_ENABLED
    DataFlash.WriteByte(HEAD_BYTE1);
    DataFlash.WriteByte(HEAD_BYTE2);
    DataFlash.WriteByte(LOG_OPTFLOW_MSG);
    DataFlash.WriteInt((int)optflow.dx);
    DataFlash.WriteInt((int)optflow.dy);
    DataFlash.WriteInt((int)optflow.surface_quality);
    DataFlash.WriteInt((int)optflow.x_cm);
    DataFlash.WriteInt((int)optflow.y_cm);
    DataFlash.WriteLong(optflow.vlat);    //optflow_offset.lat + optflow.lat);
    DataFlash.WriteLong(optflow.vlon);    //optflow_offset.lng + optflow.lng);
    DataFlash.WriteLong(of_roll);
    DataFlash.WriteLong(of_pitch);
    DataFlash.WriteByte(END_BYTE);
 #endif
}

// Read an optical flow packet.
static void Log_Read_Optflow()
{
 #ifdef OPTFLOW_ENABLED
    int16_t temp1   = DataFlash.ReadInt();                      // 1
    int16_t temp2   = DataFlash.ReadInt();                      // 2
    int16_t temp3   = DataFlash.ReadInt();                      // 3
    int16_t temp4   = DataFlash.ReadInt();                      // 4
    int16_t temp5   = DataFlash.ReadInt();                      // 5
    float temp6     = DataFlash.ReadLong();                     // 6
    float temp7     = DataFlash.ReadLong();                     // 7
    int32_t temp8   = DataFlash.ReadLong();                     // 8
    int32_t temp9   = DataFlash.ReadLong();                     // 9

    Serial.printf_P(PSTR("OF, %d, %d, %d, %d, %d, %4.7f, %4.7f, %ld, %ld\n"),
                    (int)temp1,
                    (int)temp2,
                    (int)temp3,
                    (int)temp4,
                    (int)temp5,
                    temp6,
                    temp7,
                    (long)temp8,
                    (long)temp9);
 #endif
}

// Write an Nav Tuning packet. Total length : 24 bytes
static void Log_Write_Nav_Tuning()
{
    //Matrix3f tempmat = dcm.get_dcm_matrix();

    DataFlash.WriteByte(HEAD_BYTE1);
    DataFlash.WriteByte(HEAD_BYTE2);
    DataFlash.WriteByte(LOG_NAV_TUNING_MSG);

	DataFlash.WriteInt(wp_distance);                        // 1
	DataFlash.WriteInt(target_bearing/100);                 // 2
	DataFlash.WriteInt(long_error);                         // 3
	DataFlash.WriteInt(lat_error);                          // 4

	DataFlash.WriteInt(nav_pitch);                          // 5
	DataFlash.WriteInt(nav_roll);                           // 6
	DataFlash.WriteInt(x_actual_speed);                     // 7
	DataFlash.WriteInt(y_actual_speed);                     // 8

    DataFlash.WriteByte(END_BYTE);
}

// Read a Nav Tuning packet.
static void Log_Read_Nav_Tuning()
{
    int16_t temp;

    Serial.printf_P(PSTR("NTUN, "));

    for(int8_t i = 1; i < 8; i++ ) {
        temp = DataFlash.ReadInt();
        Serial.printf_P(PSTR("%d, "), (int)temp);
    }
    // read 8
    temp = DataFlash.ReadInt();
    Serial.printf_P(PSTR("%d\n"), (int)temp);
}


// Write a control tuning packet. Total length : 26 bytes
static void Log_Write_Control_Tuning()
{
    DataFlash.WriteByte(HEAD_BYTE1);
    DataFlash.WriteByte(HEAD_BYTE2);
    DataFlash.WriteByte(LOG_CONTROL_TUNING_MSG);

    DataFlash.WriteInt(g.rc_3.control_in);                 	// 1
    DataFlash.WriteInt(sonar_alt);                          // 2
    DataFlash.WriteInt(baro_alt);                           // 3
    DataFlash.WriteInt(next_WP.alt);                        // 4
    DataFlash.WriteInt(nav_throttle);                       // 5
    DataFlash.WriteInt(angle_boost);                        // 6
    DataFlash.WriteInt(climb_rate_actual);                 	// 7
    DataFlash.WriteInt(g.rc_3.servo_out);                  	// 8

    DataFlash.WriteByte(END_BYTE);
}

// Read an control tuning packet
static void Log_Read_Control_Tuning()
{
    int16_t temp;

    Serial.printf_P(PSTR("CTUN, "));

    for(uint8_t i = 1; i < 8; i++ ) {
        temp = DataFlash.ReadInt();
        Serial.printf_P(PSTR("%d, "), (int)temp);
    }
    // read 8
    temp = DataFlash.ReadInt();
    Serial.printf_P(PSTR("%d\n"), (int)temp);
}

static void Log_Write_Iterm()
{
    DataFlash.WriteByte(HEAD_BYTE1);
    DataFlash.WriteByte(HEAD_BYTE2);
    DataFlash.WriteByte(LOG_ITERM_MSG);

    DataFlash.WriteInt((int16_t)g.pi_stabilize_roll.get_integrator());   	// 1
    DataFlash.WriteInt((int16_t)g.pi_stabilize_pitch.get_integrator());  	// 2
    DataFlash.WriteInt((int16_t)g.pi_stabilize_yaw.get_integrator());    	// 3
    DataFlash.WriteInt((int16_t)g.pid_rate_roll.get_integrator());     		// 4
    DataFlash.WriteInt((int16_t)g.pid_rate_pitch.get_integrator());    	 	// 5
    DataFlash.WriteInt((int16_t)g.pid_rate_yaw.get_integrator());    	 	// 6
	DataFlash.WriteInt((int16_t)g.pid_nav_lat.get_integrator());         	// 7
	DataFlash.WriteInt((int16_t)g.pid_nav_lon.get_integrator());         	// 8
	DataFlash.WriteInt((int16_t)g.pid_loiter_rate_lat.get_integrator()); 	// 9
	DataFlash.WriteInt((int16_t)g.pid_loiter_rate_lon.get_integrator()); 	// 10
	DataFlash.WriteInt((int16_t)g.pid_throttle.get_integrator()); 			// 11
	DataFlash.WriteInt(g.throttle_cruise); 									// 12

    DataFlash.WriteByte(END_BYTE);
}

// Read an control tuning packet
static void Log_Read_Iterm()
{
    int16_t temp;

    Serial.printf_P(PSTR("ITERM, "));

    for(uint8_t i = 1; i < 12; i++ ) {
        temp = DataFlash.ReadInt();
        Serial.printf_P(PSTR("%d, "), (int)temp);
    }
    // read 12
    temp = DataFlash.ReadInt();
    Serial.println((int)temp);
}


// Write a performance monitoring packet. Total length : 9 bytes
static void Log_Write_Performance()
{
    DataFlash.WriteByte(HEAD_BYTE1);
    DataFlash.WriteByte(HEAD_BYTE2);
    DataFlash.WriteByte(LOG_PERFORMANCE_MSG);
    DataFlash.WriteByte(    imu.adc_constraints);                               //1
    DataFlash.WriteByte(    ahrs.renorm_range_count);                           //2
    DataFlash.WriteByte(    ahrs.renorm_blowup_count);                          //3
    DataFlash.WriteByte(    gps_fix_count);                                             //4
    DataFlash.WriteByte(END_BYTE);
}

// Read a performance packet
static void Log_Read_Performance()
{
    int8_t temp1    = DataFlash.ReadByte();
    int8_t temp2    = DataFlash.ReadByte();
    int8_t temp3    = DataFlash.ReadByte();
    int8_t temp4    = DataFlash.ReadByte();

    //1   2   3   4
    Serial.printf_P(PSTR("PM, %d, %d, %d, %d\n"),
                    (int)temp1,
                    (int)temp2,
                    (int)temp3,
                    (int)temp4);
}

// Write a command processing packet.  Total length : 21 bytes
static void Log_Write_Cmd(byte num, struct Location *wp)
{
    DataFlash.WriteByte(HEAD_BYTE1);
    DataFlash.WriteByte(HEAD_BYTE2);
    DataFlash.WriteByte(LOG_CMD_MSG);

    DataFlash.WriteByte(g.command_total);       // 1
    DataFlash.WriteByte(num);                                   // 2
    DataFlash.WriteByte(wp->id);                        // 3
    DataFlash.WriteByte(wp->options);                   // 4
    DataFlash.WriteByte(wp->p1);                        // 5
    DataFlash.WriteLong(wp->alt);                       // 6
    DataFlash.WriteLong(wp->lat);                       // 7
    DataFlash.WriteLong(wp->lng);                       // 8

    DataFlash.WriteByte(END_BYTE);
}
//CMD, 3, 0, 16, 8, 1, 800, 340440192, -1180692736


// Read a command processing packet
static void Log_Read_Cmd()
{
    int8_t temp1    = DataFlash.ReadByte();
    int8_t temp2    = DataFlash.ReadByte();
    int8_t temp3    = DataFlash.ReadByte();
    int8_t temp4    = DataFlash.ReadByte();
    int8_t temp5    = DataFlash.ReadByte();
    int32_t temp6   = DataFlash.ReadLong();
    int32_t temp7   = DataFlash.ReadLong();
    int32_t temp8   = DataFlash.ReadLong();

    //  1   2    3   4   5   6   7    8
    Serial.printf_P(PSTR( "CMD, %d, %d, %d, %d, %d, %ld, %ld, %ld\n"),
                    (int)temp1,
                    (int)temp2,
                    (int)temp3,
                    (int)temp4,
                    (int)temp5,
                    (long)temp6,
                    (long)temp7,
                    (long)temp8);
}

// Write an attitude packet. Total length : 16 bytes
static void Log_Write_Attitude()
{
    DataFlash.WriteByte(HEAD_BYTE1);
    DataFlash.WriteByte(HEAD_BYTE2);
    DataFlash.WriteByte(LOG_ATTITUDE_MSG);

    DataFlash.WriteInt(control_roll);										// 1
    DataFlash.WriteInt((int16_t)ahrs.roll_sensor);                          // 2
    DataFlash.WriteInt(control_pitch);                                      // 3
    DataFlash.WriteInt((int16_t)ahrs.pitch_sensor);                         // 4
    DataFlash.WriteInt(g.rc_4.control_in);                                  // 5
    DataFlash.WriteInt((uint16_t)ahrs.yaw_sensor);                          // 6
    DataFlash.WriteInt((uint16_t)nav_yaw);                                  // 7 (this used to be compass.heading)
    DataFlash.WriteByte(END_BYTE);
}

// Read an attitude packet
static void Log_Read_Attitude()
{
    int16_t temp1   = DataFlash.ReadInt();
    int16_t temp2   = DataFlash.ReadInt();
    int16_t temp3   = DataFlash.ReadInt();
    int16_t temp4   = DataFlash.ReadInt();
    int16_t temp5   = DataFlash.ReadInt();
    uint16_t temp6  = DataFlash.ReadInt();
    uint16_t temp7  = DataFlash.ReadInt();

    // 1   2   3    4   5   6  7    8   9
    Serial.printf_P(PSTR("ATT, %d, %d, %d, %d, %d, %u, %u\n"),
                    (int)temp1,
                    (int)temp2,
                    (int)temp3,
                    (int)temp4,
                    (int)temp5,
                    (unsigned)temp6,
                    (unsigned)temp7);
}

// Write a mode packet. Total length : 7 bytes
static void Log_Write_Mode(byte mode)
{
    DataFlash.WriteByte(HEAD_BYTE1);
    DataFlash.WriteByte(HEAD_BYTE2);
    DataFlash.WriteByte(LOG_MODE_MSG);
    DataFlash.WriteByte(mode);
    DataFlash.WriteInt(g.throttle_cruise);
    DataFlash.WriteByte(END_BYTE);
}

// Read a mode packet
static void Log_Read_Mode()
{
    Serial.printf_P(PSTR("MOD:"));
    print_flight_mode(DataFlash.ReadByte());
    Serial.printf_P(PSTR(", %d\n"),(int)DataFlash.ReadInt());
}

// Write Startup packet. Total length : 4 bytes
static void Log_Write_Startup()
{
    DataFlash.WriteByte(HEAD_BYTE1);
    DataFlash.WriteByte(HEAD_BYTE2);
    DataFlash.WriteByte(LOG_STARTUP_MSG);
    DataFlash.WriteByte(END_BYTE);
}

// Read a startup packet
static void Log_Read_Startup()
{
    Serial.printf_P(PSTR("START UP\n"));
}

static void Log_Write_Data(int8_t _type, float _data)
{
    DataFlash.WriteByte(HEAD_BYTE1);
    DataFlash.WriteByte(HEAD_BYTE2);
    DataFlash.WriteByte(LOG_DATA_MSG);
    DataFlash.WriteByte(_type);
    DataFlash.WriteByte(1);
    DataFlash.WriteLong(get_int(_data));
    DataFlash.WriteByte(END_BYTE);
}

static void Log_Write_Data(int8_t _type, int32_t _data)
{
    DataFlash.WriteByte(HEAD_BYTE1);
    DataFlash.WriteByte(HEAD_BYTE2);
    DataFlash.WriteByte(LOG_DATA_MSG);
    DataFlash.WriteByte(_type);
    DataFlash.WriteByte(0);
    DataFlash.WriteLong(_data);
    DataFlash.WriteByte(END_BYTE);
}

// Read a mode packet
static void Log_Read_Data()
{
    int8_t temp1 = DataFlash.ReadByte();
    int8_t temp2 = DataFlash.ReadByte();

    if(temp2 == 1) {
        float temp3 = get_float(DataFlash.ReadLong());
        Serial.printf_P(PSTR("DATA: %d, %1.6f\n"), (int)temp1, temp3);
    }else{
        int32_t temp3 = DataFlash.ReadLong();
        Serial.printf_P(PSTR("DATA: %d, %ld\n"), (int)temp1, (long)temp3);
    }
}

// Write an PID packet. Total length : 28 bytes
static void Log_Write_PID(int8_t pid_id, int32_t error, int32_t p, int32_t i, int32_t d, int32_t output, float gain)
{
    DataFlash.WriteByte(HEAD_BYTE1);
    DataFlash.WriteByte(HEAD_BYTE2);
    DataFlash.WriteByte(LOG_PID_MSG);

    DataFlash.WriteByte(pid_id);                        // 1
    DataFlash.WriteLong(error);                                 // 2
    DataFlash.WriteLong(p);                                     // 3
    DataFlash.WriteLong(i);                                     // 4
    DataFlash.WriteLong(d);                                     // 5
    DataFlash.WriteLong(output);                        // 6
    DataFlash.WriteLong(gain * 1000);                   // 7

    DataFlash.WriteByte(END_BYTE);
}

// Read a PID packet
static void Log_Read_PID()
{
    int8_t temp1    = DataFlash.ReadByte();             // pid id
    int32_t temp2   = DataFlash.ReadLong();             // error
    int32_t temp3   = DataFlash.ReadLong();             // p
    int32_t temp4   = DataFlash.ReadLong();             // i
    int32_t temp5   = DataFlash.ReadLong();             // d
    int32_t temp6   = DataFlash.ReadLong();             // output
    float temp7     = DataFlash.ReadLong() / 1000.f;                    // gain

    //  1    2    3    4    5    6      7
    Serial.printf_P(PSTR("PID-%d, %ld, %ld, %ld, %ld, %ld, %4.4f\n"),
                    (int)temp1,         // pid id
                    (long)temp2,                // error
                    (long)temp3,                // p
                    (long)temp4,                // i
                    (long)temp5,                // d
                    (long)temp6,                // output
                    temp7);             // gain
}

// Write a DMP attitude packet. Total length : 16 bytes
static void Log_Write_DMP()
{
#if SECONDARY_DMP_ENABLED == ENABLED
    DataFlash.WriteByte(HEAD_BYTE1);
    DataFlash.WriteByte(HEAD_BYTE2);
    DataFlash.WriteByte(LOG_DMP_MSG);

    DataFlash.WriteInt((int16_t)ahrs.roll_sensor);                          // 1
    DataFlash.WriteInt((int16_t)ahrs2.roll_sensor);                         // 2
    DataFlash.WriteInt((int16_t)ahrs.pitch_sensor);                         // 3
    DataFlash.WriteInt((int16_t)ahrs2.pitch_sensor);                        // 4
    DataFlash.WriteInt((uint16_t)ahrs.yaw_sensor);                          // 5
    DataFlash.WriteInt((uint16_t)ahrs2.yaw_sensor);                         // 6
    DataFlash.WriteByte(END_BYTE);
#endif
}

// Read an attitude packet
static void Log_Read_DMP()
{
    int16_t temp1   = DataFlash.ReadInt();
    int16_t temp2   = DataFlash.ReadInt();
    int16_t temp3   = DataFlash.ReadInt();
    int16_t temp4   = DataFlash.ReadInt();
    uint16_t temp5   = DataFlash.ReadInt();
    uint16_t temp6  = DataFlash.ReadInt();

                             // 1   2   3   4   5   6
    Serial.printf_P(PSTR("DMP, %d, %d, %d, %d, %u, %u\n"),
                    (int)temp1,
                    (int)temp2,
                    (int)temp3,
                    (int)temp4,
                    (unsigned)temp5,
                    (unsigned)temp6);
}

// Read the DataFlash log memory
static void Log_Read(int16_t start_page, int16_t end_page)
{
    int16_t packet_count = 0;

 #ifdef AIRFRAME_NAME
    Serial.printf_P(PSTR((AIRFRAME_NAME)
 #endif

    Serial.printf_P(PSTR("\n" THISFIRMWARE
                         "\nFree RAM: %u\n"),
                    (unsigned) memcheck_available_memory());

 #if CONFIG_APM_HARDWARE == APM_HARDWARE_APM2
    Serial.printf_P(PSTR("APM 2\n"));
 #elif  CONFIG_APM_HARDWARE == APM2_BETA_HARDWARE
    Serial.printf_P(PSTR("APM 2Beta\n"));
 #else
    Serial.printf_P(PSTR("APM 1\n"));
 #endif

#if CLI_ENABLED == ENABLED
	setup_show(0, NULL);
#endif

    if(start_page > end_page) {
        packet_count = Log_Read_Process(start_page, DataFlash.df_NumPages);
        packet_count += Log_Read_Process(1, end_page);
    } else {
        packet_count = Log_Read_Process(start_page, end_page);
    }

    //Serial.printf_P(PSTR("Number of packets read: %d\n"), (int)packet_count);
}

// Read the DataFlash log memory : Packet Parser
static int16_t Log_Read_Process(int16_t start_page, int16_t end_page)
{
    byte data;
    byte log_step           = 0;
    int16_t page                    = start_page;
    int16_t packet_count = 0;

    DataFlash.StartRead(start_page);

	while(page < end_page && page != -1){

		data = DataFlash.ReadByte();

		// This is a state machine to read the packets
		switch(log_step) {
			case 0:
				if(data == HEAD_BYTE1)  // Head byte 1
					log_step++;
				break;

			case 1:
				if(data == HEAD_BYTE2)  // Head byte 2
					log_step++;
				else{
					log_step = 0;
					Serial.println_P(PSTR("."));
				}
				break;

			case 2:
				log_step = 0;
				switch(data) {
					case LOG_ATTITUDE_MSG:
						Log_Read_Attitude();
						break;

					case LOG_MODE_MSG:
						Log_Read_Mode();
						break;

					case LOG_CONTROL_TUNING_MSG:
						Log_Read_Control_Tuning();
						break;

					case LOG_NAV_TUNING_MSG:
						Log_Read_Nav_Tuning();
						break;

					case LOG_PERFORMANCE_MSG:
						Log_Read_Performance();
						break;

					case LOG_RAW_MSG:
						Log_Read_Raw();
						break;

					case LOG_CMD_MSG:
						Log_Read_Cmd();
						break;

					case LOG_CURRENT_MSG:
						Log_Read_Current();
						break;

					case LOG_STARTUP_MSG:
						Log_Read_Startup();
						break;

					case LOG_MOTORS_MSG:
						Log_Read_Motors();
						break;

					case LOG_OPTFLOW_MSG:
						Log_Read_Optflow();
						break;

					case LOG_GPS_MSG:
						Log_Read_GPS();
						break;

					case LOG_DATA_MSG:
						Log_Read_Data();
						break;

					case LOG_PID_MSG:
						Log_Read_PID();
						break;

					case LOG_ITERM_MSG:
						Log_Read_Iterm();
						break;

					case LOG_DMP_MSG:
						Log_Read_DMP();
						break;
				}
				break;
		case 3:
			if(data == END_BYTE){
				packet_count++;
			}else{
				Serial.printf_P(PSTR("Error Reading END_BYTE: %d\n"),data);
			}
			log_step = 0;                   // Restart sequence: new packet...
			break;
		}
		page = DataFlash.GetPage();
	}
	return packet_count;
}


#else // LOGGING_ENABLED

static void Log_Write_Startup() {
}
static void Log_Read_Startup() {
}
static void Log_Read(int16_t start_page, int16_t end_page) {
}
static void Log_Write_Cmd(byte num, struct Location *wp) {
}
static void Log_Write_Mode(byte mode) {
}
static void Log_Write_Raw() {
}
static void Log_Write_GPS() {
}
static void Log_Write_Current() {
}
static void Log_Write_Iterm() {
}
static void Log_Write_Attitude() {
}
static void Log_Write_Data(int8_t _type, float _data){
}
static void Log_Write_Data(int8_t _type, int32_t _data){
}
static void Log_Write_Optflow() {
}
static void Log_Write_Nav_Tuning() {
}
static void Log_Write_Control_Tuning() {
}
static void Log_Write_Motors() {
}
static void Log_Write_Performance() {
}
static void Log_Write_PID(int8_t pid_id, int32_t error, int32_t p, int32_t i, int32_t d, int32_t output, float gain) {
}
static void Log_Write_DMP() {
}
static int8_t process_logs(uint8_t argc, const Menu::arg *argv) {
    return 0;
}

#endif // LOGGING_DISABLED
include ../libraries/AP_Common/Arduino.mk

nologging:
	make -f Makefile EXTRAFLAGS="-DLOGGING_ENABLED=DISABLED"

nogps:
	make -f Makefile EXTRAFLAGS="-DGPS_PROTOCOL=GPS_PROTOCOL_NONE -DLOGGING_ENABLED=DISABLED"

hil:
	make -f Makefile EXTRAFLAGS="-DHIL_MODE=HIL_MODE_ATTITUDE -DCLI_SLIDER_ENABLED=DISABLED -DLOGGING_ENABLED=DISABLED"

hilsensors:
	make -f Makefile EXTRAFLAGS="-DHIL_MODE=HIL_MODE_SENSORS -DCLI_SLIDER_ENABLED=DISABLED -DLOGGING_ENABLED=DISABLED"

hilnocli:
	make -f Makefile EXTRAFLAGS="-DHIL_MODE=HIL_MODE_ATTITUDE -DCLI_ENABLED=DISABLED -DLOGGING_ENABLED=DISABLED"

heli:
	make -f Makefile EXTRAFLAGS="-DFRAME_CONFIG=HELI_FRAME"

apm2:
	make -f Makefile EXTRAFLAGS="-DCONFIG_APM_HARDWARE=APM_HARDWARE_APM2"

dmp:
	make -f Makefile EXTRAFLAGS="-DDMP_ENABLED=ENABLED"

apm2hexa:
	make -f Makefile EXTRAFLAGS="-DCONFIG_APM_HARDWARE=APM_HARDWARE_APM2 -DFRAME_CONFIG=HEXA_FRAME"

apm2beta:
	make -f Makefile EXTRAFLAGS="-DCONFIG_APM_HARDWARE=APM_HARDWARE_APM2 -DAPM2_BETA_HARDWARE"

sitl:
	make -f ../libraries/Desktop/Makefile.desktop

sitl-octa:
	make -f ../libraries/Desktop/Makefile.desktop octa

sitl-hexa:
	make -f ../libraries/Desktop/Makefile.desktop hexa

sitl-y6:
	make -f ../libraries/Desktop/Makefile.desktop y6

etags:
	cd .. && etags -f ArduCopter/TAGS --langmap=C++:.pde.cpp.h $$(git ls-files ArduCopter libraries)

/// -*- tab-width: 4; Mode: C++; c-basic-offset: 4; indent-tabs-mode: nil -*-

// 10 = 1 second
#define ARM_DELAY 20
#define DISARM_DELAY 20
#define LEVEL_DELAY 100


// called at 10hz
static void arm_motors()
{
    static int16_t arming_counter;

    // don't allow arming/disarming in anything but manual
    if ((g.rc_3.control_in > 0) || (arming_counter > LEVEL_DELAY)) {
        arming_counter = 0;
        return;
    }

    if ((control_mode > ACRO) && ((control_mode != TOY_A) && (control_mode != TOY_M))) {
        arming_counter = 0;
        return;
    }

#if TOY_EDF == ENABLED
    int16_t tmp = g.rc_1.control_in;
#else
    int16_t tmp = g.rc_4.control_in;
#endif

    // full right
    if (tmp > 4000) {
        if (arming_counter == LEVEL_DELAY) {
            //Serial.printf("\nAL\n");
            // begin auto leveling
            auto_level_counter = 250;
            arming_counter = 0;

        }else if (arming_counter == ARM_DELAY) {
            if(motors.armed() == false) {
                // arm the motors and configure for flight

////////////////////////////////////////////////////////////////////////////////
// Experimental AP_Limits library - set constraints, limits, fences, minima, maxima on various parameters
////////////////////////////////////////////////////////////////////////////////
#ifdef AP_LIMITS
                if (limits.enabled() && limits.required()) {
                    gcs_send_text_P(SEVERITY_LOW, PSTR("Limits - Running pre-arm checks"));

                    // check only pre-arm required modules
                    if (limits.check_required()) {
                        gcs_send_text_P(SEVERITY_LOW, PSTR("ARMING PREVENTED - Limit Breached"));
                        limits.set_state(LIMITS_TRIGGERED);
                        gcs_send_message(MSG_LIMITS_STATUS);

                        arming_counter++;                                 // restart timer by cycling
                    }else{
                        init_arm_motors();
                    }
                }else{
                    init_arm_motors();
                }

#else  // without AP_LIMITS, just arm motors
                init_arm_motors();
#endif //AP_LIMITS_ENABLED

            }
            // keep going up
            arming_counter++;
        } else{
            arming_counter++;
        }

        // full left
    }else if (tmp < -4000) {
        if (arming_counter == LEVEL_DELAY) {
            //Serial.printf("\nLEV\n");

            // begin manual leveling
            imu.init_accel(mavlink_delay, flash_leds);
            arming_counter = 0;

        }else if (arming_counter == DISARM_DELAY) {
            if(motors.armed()) {
                // arm the motors and configure for flight
                init_disarm_motors();
            }
            // keep going up
            arming_counter++;
        }else{
            arming_counter++;
        }

        // Yaw is centered
    }else{
        arming_counter = 0;
    }
}


static void init_arm_motors()
{
    // Flag used to track if we have armed the motors the first time.
    // This is used to decide if we should run the ground_start routine
    // which calibrates the IMU
    static bool did_ground_start = false;

    // disable failsafe because initialising everything takes a while
    failsafe_disable();

    //Serial.printf("\nARM\n");
#if HIL_MODE != HIL_MODE_DISABLED || defined(DESKTOP_BUILD)
    gcs_send_text_P(SEVERITY_HIGH, PSTR("ARMING MOTORS"));
#endif

    // we don't want writes to the serial port to cause us to pause
    // mid-flight, so set the serial ports non-blocking once we arm
    // the motors
    Serial.set_blocking_writes(false);
    if (gcs3.initialised) {
        Serial3.set_blocking_writes(false);
    }

#if COPTER_LEDS == ENABLED
    if ( bitRead(g.copter_leds_mode, 3) ) {
        piezo_beep();
        delay(50);
        piezo_beep();
    }
#endif

    // Remember Orientation
    // --------------------
    init_simple_bearing();

    init_z_damper();

    // Reset home position
    // -------------------
    if(home_is_set)
        init_home();

    // all I terms are invalid
    // -----------------------
    reset_I_all();

    if(did_ground_start == false) {
        did_ground_start = true;
        startup_ground();
    }

#if HIL_MODE != HIL_MODE_ATTITUDE
    // read Baro pressure at ground -
    // this resets Baro for more accuracy
    //-----------------------------------
    init_barometer();
#endif

    // temp hack
    motor_light = true;
    digitalWrite(A_LED_PIN, LED_ON);

    // go back to normal AHRS gains
    ahrs.set_fast_gains(false);
#if SECONDARY_DMP_ENABLED == ENABLED
    ahrs2.set_fast_gains(false);
#endif

    // finally actually arm the motors
    motors.armed(true);

    // reenable failsafe
    failsafe_enable();
}


static void init_disarm_motors()
{
    //Serial.printf("\nDISARM\n");
#if HIL_MODE != HIL_MODE_DISABLED || defined(DESKTOP_BUILD)
    gcs_send_text_P(SEVERITY_HIGH, PSTR("DISARMING MOTORS"));
#endif

    motors.armed(false);
    compass.save_offsets();

    g.throttle_cruise.save();

    // we are not in the air
    takeoff_complete = false;

#if COPTER_LEDS == ENABLED
    if ( bitRead(g.copter_leds_mode, 3) ) {
        piezo_beep();
    }
#endif

    // setup fast AHRS gains to get right attitude
    ahrs.set_fast_gains(true);
#if SECONDARY_DMP_ENABLED == ENABLED
    ahrs2.set_fast_gains(true);
#endif
}

/*****************************************
* Set the flight control servos based on the current calculated values
*****************************************/
static void
set_servos_4()
{
    // temp fix for bad attitude
    g.rc_3.servo_out = min(g.rc_3.servo_out, 800);

    motors.output();
}

// -*- tab-width: 4; Mode: C++; c-basic-offset: 4; indent-tabs-mode: nil -*-

//****************************************************************
// Function that will calculate the desired direction to fly and distance
//****************************************************************
static void navigate()
{
    // waypoint distance from plane in cm
    // ---------------------------------------
    wp_distance     = get_distance_cm(&filtered_loc, &next_WP);
    home_distance   = get_distance_cm(&filtered_loc, &home);

    // target_bearing is where we should be heading
    // --------------------------------------------
    target_bearing                  = get_bearing_cd(&filtered_loc, &next_WP);
    home_to_copter_bearing  = get_bearing_cd(&home, &current_loc);
}

static bool check_missed_wp()
{
    int32_t temp;
    temp = target_bearing - original_target_bearing;
    temp = wrap_180(temp);
    return (labs(temp) > 9000);         // we passed the waypoint by 100 degrees
}

// ------------------------------
static void calc_XY_velocity(){
    static int32_t last_longitude = 0;
    static int32_t last_latitude  = 0;

    // called after GPS read
    // offset calculation of GPS speed:
    // used for estimations below 1.5m/s
    // y_GPS_speed positve = Up
    // x_GPS_speed positve = Right

    // initialise last_longitude and last_latitude
    if( last_longitude == 0 && last_latitude == 0 ) {
        last_longitude = g_gps->longitude;
        last_latitude = g_gps->latitude;
    }

    // this speed is ~ in cm because we are using 10^7 numbers from GPS
    float tmp = 1.0/dTnav;

    x_actual_speed  = (float)(g_gps->longitude - last_longitude)  * scaleLongDown * tmp;
    y_actual_speed  = (float)(g_gps->latitude  - last_latitude)  * tmp;

    last_longitude  = g_gps->longitude;
    last_latitude   = g_gps->latitude;

#if INERTIAL_NAV == ENABLED
    // inertial_nav
    xy_error_correction();
    filtered_loc.lng = xLeadFilter.get_position(g_gps->longitude, accels_velocity.x);
    filtered_loc.lat = yLeadFilter.get_position(g_gps->latitude,  accels_velocity.y);
#else
    filtered_loc.lng = xLeadFilter.get_position(g_gps->longitude, x_actual_speed, g_gps->get_lag());
    filtered_loc.lat = yLeadFilter.get_position(g_gps->latitude,  y_actual_speed, g_gps->get_lag());
#endif
}

static void calc_location_error(struct Location *next_loc)
{
    /*
     *  Becuase we are using lat and lon to do our distance errors here's a quick chart:
     *  100     = 1m
     *  1000    = 11m	 = 36 feet
     *  1800    = 19.80m = 60 feet
     *  3000    = 33m
     *  10000   = 111m
     */

    // X Error
    long_error      = (float)(next_loc->lng - current_loc.lng) * scaleLongDown;       // 500 - 0 = 500 Go East

    // Y Error
    lat_error       = next_loc->lat - current_loc.lat;                                                          // 500 - 0 = 500 Go North
}

#define NAV_ERR_MAX 600
#define NAV_RATE_ERR_MAX 250
static void calc_loiter(int16_t x_error, int16_t y_error)
{
    int32_t p,i,d;                                              // used to capture pid values for logging
    int32_t output;
    int32_t x_target_speed, y_target_speed;

    // East / West
    x_target_speed  = g.pi_loiter_lon.get_p(x_error);                           // calculate desired speed from lon error

#if LOGGING_ENABLED == ENABLED
    // log output if PID logging is on and we are tuning the yaw
    if( g.log_bitmask & MASK_LOG_PID && (g.radio_tuning == CH6_LOITER_KP || g.radio_tuning == CH6_LOITER_KI) ) {
        Log_Write_PID(CH6_LOITER_KP, x_error, x_target_speed, 0, 0, x_target_speed, tuning_value);
    }
#endif


    // calculate rate error
#if INERTIAL_NAV == ENABLED
    x_rate_error    = x_target_speed - accels_velocity.x;               // calc the speed error
#else
    x_rate_error    = x_target_speed - x_actual_speed;                          // calc the speed error
#endif


    p                               = g.pid_loiter_rate_lon.get_p(x_rate_error);
    i                               = g.pid_loiter_rate_lon.get_i(x_rate_error + x_error, dTnav);
    d                               = g.pid_loiter_rate_lon.get_d(x_error, dTnav);
    d                               = constrain(d, -2000, 2000);

    // get rid of noise
    if(abs(x_actual_speed) < 50) {
        d = 0;
    }

    output                  = p + i + d;
    nav_lon                 = constrain(output, -3200, 3200);

#if LOGGING_ENABLED == ENABLED
    // log output if PID logging is on and we are tuning the yaw
    if( g.log_bitmask & MASK_LOG_PID && (g.radio_tuning == CH6_LOITER_RATE_KP || g.radio_tuning == CH6_LOITER_RATE_KI || g.radio_tuning == CH6_LOITER_RATE_KD) ) {
        Log_Write_PID(CH6_LOITER_RATE_KP, x_rate_error, p, i, d, nav_lon, tuning_value);
    }
#endif

    // North / South
    y_target_speed  = g.pi_loiter_lat.get_p(y_error);                           // calculate desired speed from lat error

#if LOGGING_ENABLED == ENABLED
    // log output if PID logging is on and we are tuning the yaw
    if( g.log_bitmask & MASK_LOG_PID && (g.radio_tuning == CH6_LOITER_KP || g.radio_tuning == CH6_LOITER_KI) ) {
        Log_Write_PID(CH6_LOITER_KP+100, y_error, y_target_speed, 0, 0, y_target_speed, tuning_value);
    }
#endif

    // calculate rate error
#if INERTIAL_NAV == ENABLED
    y_rate_error    = y_target_speed - accels_velocity.y;               // calc the speed error
#else
    y_rate_error    = y_target_speed - y_actual_speed;                          // calc the speed error
#endif

    p                               = g.pid_loiter_rate_lat.get_p(y_rate_error);
    i                               = g.pid_loiter_rate_lat.get_i(y_rate_error + y_error, dTnav);
    d                               = g.pid_loiter_rate_lat.get_d(y_error, dTnav);
    d                               = constrain(d, -2000, 2000);

    // get rid of noise
    if(abs(y_actual_speed) < 50) {
        d = 0;
    }

    output                  = p + i + d;
    nav_lat                 = constrain(output, -3200, 3200);

#if LOGGING_ENABLED == ENABLED
    // log output if PID logging is on and we are tuning the yaw
    if( g.log_bitmask & MASK_LOG_PID && (g.radio_tuning == CH6_LOITER_RATE_KP || g.radio_tuning == CH6_LOITER_RATE_KI || g.radio_tuning == CH6_LOITER_RATE_KD) ) {
        Log_Write_PID(CH6_LOITER_RATE_KP+100, y_rate_error, p, i, d, nav_lat, tuning_value);
    }
#endif

    // copy over I term to Nav_Rate
    g.pid_nav_lon.set_integrator(g.pid_loiter_rate_lon.get_integrator());
    g.pid_nav_lat.set_integrator(g.pid_loiter_rate_lat.get_integrator());
}

static void calc_nav_rate(int16_t max_speed)
{
    float temp, temp_x, temp_y;

    // push us towards the original track
    update_crosstrack();

    int16_t cross_speed = crosstrack_error * -g.crosstrack_gain;     // scale down crosstrack_error in cm
    cross_speed     = constrain(cross_speed, -150, 150);

    // rotate by 90 to deal with trig functions
    temp                    = (9000l - target_bearing) * RADX100;
    temp_x                  = cos(temp);
    temp_y                  = sin(temp);

    // rotate desired spped vector:
    int32_t x_target_speed = max_speed   * temp_x - cross_speed * temp_y;
    int32_t y_target_speed = cross_speed * temp_x + max_speed   * temp_y;

    // East / West
    // calculate rate error
#if INERTIAL_NAV == ENABLED
    x_rate_error    = x_target_speed - accels_velocity.x;
#else
    x_rate_error    = x_target_speed - x_actual_speed;
#endif

    x_rate_error    = constrain(x_rate_error, -500, 500);
    nav_lon                 = g.pid_nav_lon.get_pid(x_rate_error, dTnav);
    int32_t tilt    = (x_target_speed * x_target_speed * (int32_t)g.tilt_comp) / 10000;

    if(x_target_speed < 0) tilt = -tilt;
    nav_lon                 += tilt;
    nav_lon                 = constrain(nav_lon, -3200, 3200);


    // North / South
    // calculate rate error
#if INERTIAL_NAV == ENABLED
    y_rate_error    = y_target_speed - accels_velocity.y;
#else
    y_rate_error    = y_target_speed - y_actual_speed;
#endif

    y_rate_error    = constrain(y_rate_error, -500, 500);       // added a rate error limit to keep pitching down to a minimum
    nav_lat                 = g.pid_nav_lat.get_pid(y_rate_error, dTnav);
    tilt                    = (y_target_speed * y_target_speed * (int32_t)g.tilt_comp) / 10000;

    if(y_target_speed < 0) tilt = -tilt;
    nav_lat                 += tilt;
    nav_lat                 = constrain(nav_lat, -3200, 3200);

    // copy over I term to Loiter_Rate
    g.pid_loiter_rate_lon.set_integrator(g.pid_nav_lon.get_integrator());
    g.pid_loiter_rate_lat.set_integrator(g.pid_nav_lat.get_integrator());
}


// this calculation rotates our World frame of reference to the copter's frame of reference
// We use the DCM's matrix to precalculate these trig values at 50hz
static void calc_loiter_pitch_roll()
{
    //Serial.printf("ys %ld, cx %1.4f, _cx %1.4f | sy %1.4f, _sy %1.4f\n", dcm.yaw_sensor, cos_yaw_x, _cos_yaw_x, sin_yaw_y, _sin_yaw_y);
    // rotate the vector
    auto_roll       = (float)nav_lon * sin_yaw_y - (float)nav_lat * cos_yaw_x;
    auto_pitch      = (float)nav_lon * cos_yaw_x + (float)nav_lat * sin_yaw_y;

    // flip pitch because forward is negative
    auto_pitch = -auto_pitch;
}

static int16_t get_desired_speed(int16_t max_speed, bool _slow)
{
    /*
     * |< WP Radius
     *  0  1   2   3   4   5   6   7   8m
     *  ...|...|...|...|...|...|...|...|
     *         100  |  200	  300	  400cm/s
     |                              +|+
     ||< we should slow to 1.5 m/s as we hit the target
     */

    if(fast_corner) {
        waypoint_radius = g.waypoint_radius * 2;
        //max_speed         = max_speed;
    }else{
        waypoint_radius = g.waypoint_radius;
        max_speed               = min(max_speed, (wp_distance - g.waypoint_radius) / 3);
        max_speed               = max(max_speed, WAYPOINT_SPEED_MIN);           // go at least 100cm/s
    }

    // limit the ramp up of the speed
    // waypoint_speed_gov is reset to 0 at each new WP command
    if(max_speed > waypoint_speed_gov) {
        waypoint_speed_gov += (int)(100.0 * dTnav);         // increase at .5/ms
        max_speed = waypoint_speed_gov;
    }

    return max_speed;
}

static int16_t get_desired_climb_rate()
{
    if(alt_change_flag == ASCENDING) {
        return constrain(altitude_error / 4, 100, 180);         // 180cm /s up, minimum is 100cm/s

    }else if(alt_change_flag == DESCENDING) {
        return constrain(altitude_error / 6, -100, -10);         // -100cm /s down, max is -10cms

    }else{
        return 0;
    }
}

static void update_crosstrack(void)
{
    // Crosstrack Error
    // ----------------
    // If we are too far off or too close we don't do track following
    float temp = (target_bearing - original_target_bearing) * RADX100;
    crosstrack_error = sin(temp) * wp_distance;          // Meters we are off track line
}

static int32_t get_altitude_error()
{
    // Next_WP alt is our target alt
    // It changes based on climb rate
    // until it reaches the target_altitude
    return next_WP.alt - current_loc.alt;
}

static void clear_new_altitude()
{
    alt_change_flag = REACHED_ALT;
}

static void force_new_altitude(int32_t new_alt)
{
    next_WP.alt     = new_alt;
    alt_change_flag = REACHED_ALT;
}

static void set_new_altitude(int32_t new_alt)
{
    next_WP.alt     = new_alt;

    if(next_WP.alt > current_loc.alt + 20) {
        // we are below, going up
        alt_change_flag = ASCENDING;

    }else if(next_WP.alt < current_loc.alt - 20) {
        // we are above, going down
        alt_change_flag = DESCENDING;

    }else{
        // No Change
        alt_change_flag = REACHED_ALT;
    }
}

static void verify_altitude()
{
    if(alt_change_flag == ASCENDING) {
        // we are below, going up
        if(current_loc.alt >  next_WP.alt - 50) {
            alt_change_flag = REACHED_ALT;
        }
    }else if (alt_change_flag == DESCENDING) {
        // we are above, going down
        if(current_loc.alt <=  next_WP.alt + 50)
            alt_change_flag = REACHED_ALT;
    }
}


static int32_t wrap_360(int32_t error)
{
    if (error > 36000) error -= 36000;
    if (error < 0) error += 36000;
    return error;
}

static int32_t wrap_180(int32_t error)
{
    if (error > 18000) error -= 36000;
    if (error < -18000) error += 36000;
    return error;
}

#
# This files is used by cmake to present options to the 
# user in the cmake-gui, it can also be used directly to
# set options in the cmake command line.
#
# This file generates APM_Config_cmake.h
# which overrides the APM_Config.h file. When disributing
# to the Arduino IDE user. APM_Confg_cmake.h could be copied to
# APM_Config.h, but this is not necessary. The 
# advantage would be that the Arduino user would have 
# a more up-to-date/ complete list of options and the developers
# using cmake have a nice gui/ command-line interface.
# 

apm_option("APM_PROGRAMMING_PORT" TYPE STRING
    DESCRIPTION "Programming upload port?"
    DEFAULT "/dev/ttyACM0")

apm_option("CONFIG_APM_HARDWARE" TYPE STRING
    DESCRIPTION "APM Hardware?" 
    OPTIONS "APM_HARDWARE_APM2" "APM_HARDWARE_APM1"
    DEFAULT "APM_HARDWARE_APM2")

apm_option("APM2_BETA_HARDWARE" TYPE BOOL DEFINE_ONLY
    DESCRIPTION "Is this an APM 2.0 Beta board?" 
    DEFAULT OFF)

apm_option("APM_PROCESSOR" TYPE STRING
    DESCRIPTION "ArduPilotMega processor (2560 for APM2 and later APM1)?" 
    DEFAULT "mega2560"
    OPTIONS "mega" "mega2560")

#apm_option("CLI_SLIDER_ENABLED" TYPE BOOL
    #DESCRIPTION "Enable command line interface switch?" 
    #DEFAULT OFF)

apm_option("LOGGING_ENABLED" TYPE BOOL
    DESCRIPTION "Enable logging?" 
    DEFAULT OFF)

apm_option("GPS_PROTOCOL" TYPE STRING
    DESCRIPTION "GPS protocol?"
    DEFAULT "GPS_PROTOCOL_AUTO" 
    OPTIONS 
        "GPS_PROTOOCL_NONE"
        "GPS_PROTOCOL_AUTO"
        "GPS_PROTOCOL_NONE"
        "GPS_PROTOCOL_IMU"
        "GPS_PROTOCOL_MTK"
        "GPS_PROTOCOL_MTK16"
        "GPS_PROTOCOL_UBLOX"
        "GPS_PROTOCOL_SIRF"
        "GPS_PROTOCOL_NMEA")

apm_option("AIRSPEED_SENSOR" TYPE BOOL
    DESCRIPTION "Enable airspeed sensor?"
    DEFAULT OFF)

apm_option("PITOT_ENABLED" TYPE BOOL
    DESCRIPTION "Enable pitot static system?"
    DEFAULT OFF)

apm_option("SONAR_ENABLED" TYPE BOOL
    DESCRIPTION "Enable sonar?"
    DEFAULT OFF)

apm_option("AIRSPEED_RATIO" TYPE STRING ADVANCED
    DESCRIPTION "Airspeed ratio?"
    DEFAULT "1.9936")

#apm_option("MAGNETOMETER" TYPE BOOL
    #DESCRIPTION "Enable airspeed sensor?"
    #DEFAULT OFF)

#apm_option("MAG_ORIENTATION" TYPE STRING ADVANCED
    #DESCRIPTION "Magnetometer orientation?" 
    #DEFAULT "AP_COMPASS_COMPONENTS_DOWN_PINS_FORWARD"
    #OPTIONS 
        #"AP_COMPASS_COMPONENTS_DOWN_PINS_FORWARD"
        #"AP_COMPASS_COMPONENTS_DOWN_PINS_BACK"
        #"AP_COMPASS_COMPONENTS_UP_PINS_FORWARD"
        #"AP_COMPASS_COMPONENTS_UP_PINS_BACK")

apm_option("HIL_MODE" TYPE STRING
    DESCRIPTION "Hardware-in-the-loop- mode?"
    DEFAULT "HIL_MODE_DISABLED"
    OPTIONS 
        "HIL_MODE_DISABLED"
        "HIL_MODE_ATTITUDE"
        "HIL_MODE_SENSORS")

apm_option("MAV_SYSTEM_ID" TYPE STRING ADVANCED
    DESCRIPTION "MAVLink System ID?"
    DEFAULT "1")

apm_option("SERIAL0_BAUD" TYPE STRING ADVANCED
    DESCRIPTION "Serial 0 baudrate?"
    DEFAULT "115200" 
    OPTIONS "57600" "115200") 

apm_option("SERIAL3_BAUD" TYPE STRING ADVANCED
    DESCRIPTION "Serial 3 baudrate?"
    DEFAULT "57600" 
    OPTIONS "57600" "115200") 

apm_option("BATTERY_EVENT" TYPE BOOL ADVANCED
    DESCRIPTION "Enable low voltage/ high discharge warnings?"
    DEFAULT OFF)

apm_option("LOW_VOLTAGE" TYPE STRING ADVANCED
    DESCRIPTION "Voltage to consider low (volts)?"
    DEFAULT "9.6")

apm_option("VOLT_DIV_RATIO" TYPE STRING ADVANCED
    DESCRIPTION "Voltage division ratio?"
    DEFAULT "3.56")

apm_option("CUR_AMPS_PER_VOLT" TYPE STRING ADVANCED
    DESCRIPTION "Current amps/volt?"
    DEFAULT "27.32")

apm_option("CUR_AMPS_OFFSET" TYPE STRING ADVANCED
    DESCRIPTION "Current amps offset?"
    DEFAULT "0.0")

# arducopter specific
apm_option("FRAME_CONFIG" TYPE STRING
    DESCRIPTION "Vehicle type?"
    DEFAULT "QUAD_FRAME"
    OPTIONS
        "QUAD_FRAME"
        "TRI_FRAME"
        "HEXA_FRAME"
        "Y6_FRAME"
        "OCTA_FRAME"
        "OCTA_QUAD_FRAME"
        "HELI_FRAME"
    )

apm_option("FRAME_ORIENTATION" TYPE STRING
    DESCRIPTION "Vehicle type?"
    DEFAULT "PLUS_FRAME"
    OPTIONS
	    "PLUS_FRAME"
	    "X_FRAME"
	    "V_FRAME"
    )

apm_option("CH7_OPTION" TYPE STRING
    DESCRIPTION "Channel 7 option? (ADC_FILTER is experimental)"
    DEFAULT "CH7_SAVE_WP" 
    OPTIONS 
        "CH7_DO_NOTHING"
        "CH7_SET_HOVER"
        "CH7_FLIP"
        "CH7_RTL"
        "CH7_AUTO_TRIM"
        "CH7_ADC_FILTER"
        "CH7_SAVE_WP")

apm_option("ACCEL_ALT_HOLD" TYPE BOOL ADVANCED
    DESCRIPTION "Disabled by default, work in progress."
    DEFAULT OFF)
// -*- tab-width: 4; Mode: C++; c-basic-offset: 4; indent-tabs-mode: nil -*-

#ifndef PARAMETERS_H
#define PARAMETERS_H

#include <AP_Common.h>

// Global parameter class.
//
class Parameters {
public:
    // The version of the layout as described by the parameter enum.
    //
    // When changing the parameter enum in an incompatible fashion, this
    // value should be incremented by one.
    //
    // The increment will prevent old parameters from being used incorrectly
    // by newer code.
    //
    static const uint16_t        k_format_version = 120;

    // The parameter software_type is set up solely for ground station use
    // and identifies the software type (eg ArduPilotMega versus
    // ArduCopterMega)
    // GCS will interpret values 0-9 as ArduPilotMega.  Developers may use
    // values within that range to identify different branches.
    //
    static const uint16_t        k_software_type = 10;          // 0 for APM
                                                                // trunk

    // Parameter identities.
    //
    // The enumeration defined here is used to ensure that every parameter
    // or parameter group has a unique ID number.	This number is used by
    // AP_Var to store and locate parameters in EEPROM.
    //
    // Note that entries without a number are assigned the next number after
    // the entry preceding them.	When adding new entries, ensure that they
    // don't overlap.
    //
    // Try to group related variables together, and assign them a set
    // range in the enumeration.	Place these groups in numerical order
    // at the end of the enumeration.
    //
    // WARNING: Care should be taken when editing this enumeration as the
    //			AP_Var load/save code depends on the values here to identify
    //			variables saved in EEPROM.
    //
    //
    enum {
        // Layout version number, always key zero.
        //
        k_param_format_version = 0,
        k_param_software_type,
        k_param_ins,

        // simulation
        k_param_sitl = 10,

        // Misc
        //
        k_param_log_bitmask = 20,
        k_param_log_last_filenumber,            // *** Deprecated - remove
                                                // with next eeprom number
                                                // change
        k_param_toy_yaw_rate,                           // THOR The memory
                                                        // location for the
                                                        // Yaw Rate 1 = fast,
                                                        // 2 = med, 3 = slow

        // 65: AP_Limits Library
        k_param_limits = 65,
        k_param_gpslock_limit,
        k_param_geofence_limit,
        k_param_altitude_limit,

        //
        // 80: Heli
        //
        k_param_heli_servo_1 = 80,
        k_param_heli_servo_2,
        k_param_heli_servo_3,
        k_param_heli_servo_4,

        //
        // 90: Motors
        //
        k_param_motors = 90,

        // 110: Telemetry control
        //
        k_param_gcs0 = 110,
        k_param_gcs3,
        k_param_sysid_this_mav,
        k_param_sysid_my_gcs,
        k_param_serial3_baud,
        k_param_telem_delay,

        //
        // 140: Sensor parameters
        //
        k_param_imu = 140, // sensor calibration
        k_param_battery_monitoring,
        k_param_volt_div_ratio,
        k_param_curr_amp_per_volt,
        k_param_input_voltage,
        k_param_pack_capacity,
        k_param_compass_enabled,
        k_param_compass,
        k_param_sonar_enabled,
        k_param_frame_orientation,
        k_param_optflow_enabled,
        k_param_low_voltage,
        k_param_ch7_option,
        k_param_auto_slew_rate,
        k_param_sonar_type,
        k_param_super_simple = 155,
        k_param_axis_enabled = 157,
        k_param_copter_leds_mode,
        k_param_ahrs, // AHRS group

        //
        // 160: Navigation parameters
        //
        k_param_RTL_altitude = 160,
        k_param_crosstrack_gain,
        k_param_auto_land_timeout,
        k_param_rtl_approach_alt,
        k_param_tilt_comp, //164


        //
        // Camera and mount parameters
        //
        k_param_camera = 165,
        k_param_camera_mount,
        k_param_camera_mount2,

        //
        // Batery monitoring parameters
        //
        k_param_battery_volt_pin = 168,
        k_param_battery_curr_pin,   // 169

        //
        // 170: Radio settings
        //
        k_param_rc_1 = 170,
        k_param_rc_2,
        k_param_rc_3,
        k_param_rc_4,
        k_param_rc_5,
        k_param_rc_6,
        k_param_rc_7,
        k_param_rc_8,
        k_param_rc_10,
        k_param_rc_11,
        k_param_throttle_min,
        k_param_throttle_max,
        k_param_throttle_fs_enabled,
        k_param_throttle_fs_action,
        k_param_throttle_fs_value,
        k_param_throttle_cruise,
        k_param_esc_calibrate,
        k_param_radio_tuning,
        k_param_radio_tuning_high,
        k_param_radio_tuning_low,
        k_param_rc_speed = 192,

        //
        // 200: flight modes
        //
        k_param_flight_mode1 = 200,
        k_param_flight_mode2,
        k_param_flight_mode3,
        k_param_flight_mode4,
        k_param_flight_mode5,
        k_param_flight_mode6,
        k_param_simple_modes,

        //
        // 210: Waypoint data
        //
        k_param_waypoint_mode = 210, // remove
        k_param_command_total,
        k_param_command_index,
        k_param_command_nav_index,
        k_param_waypoint_radius,
        k_param_loiter_radius,
        k_param_waypoint_speed_max,

        //
        // 220: PI/D Controllers
        //
        k_param_stabilize_d_schedule = 219,
        k_param_stabilize_d = 220,
        k_param_acro_p,
        k_param_axis_lock_p,
        k_param_pid_rate_roll,
        k_param_pid_rate_pitch,
        k_param_pid_rate_yaw,
        k_param_pi_stabilize_roll,
        k_param_pi_stabilize_pitch,
        k_param_pi_stabilize_yaw,
        k_param_pi_loiter_lat,
        k_param_pi_loiter_lon,
        k_param_pid_loiter_rate_lat,
        k_param_pid_loiter_rate_lon,
        k_param_pid_nav_lat,
        k_param_pid_nav_lon,
        k_param_pi_alt_hold,
        k_param_pid_throttle,
        k_param_pid_optflow_roll,
        k_param_pid_optflow_pitch,

        // 254,255: reserved
    };

    AP_Int16        format_version;
    AP_Int8         software_type;

    // Telemetry control
    //
    AP_Int16        sysid_this_mav;
    AP_Int16        sysid_my_gcs;
    AP_Int8         serial3_baud;
    AP_Int8         telem_delay;

    AP_Int16        RTL_altitude;
    AP_Int8         sonar_enabled;
    AP_Int8         sonar_type;       // 0 = XL, 1 = LV,
                                      // 2 = XLL (XL with 10m range)
                                      // 3 = HRLV
    AP_Int8         battery_monitoring;         // 0=disabled, 3=voltage only,
                                                // 4=voltage and current
    AP_Float        volt_div_ratio;
    AP_Float        curr_amp_per_volt;
    AP_Float        input_voltage;
    AP_Int16        pack_capacity;              // Battery pack capacity less
                                                // reserve
    AP_Int8         compass_enabled;
    AP_Int8         optflow_enabled;
    AP_Float        low_voltage;
    AP_Int8         super_simple;
    AP_Int16        rtl_approach_alt;
    AP_Int8         tilt_comp;
    AP_Int8         axis_enabled;
    AP_Int8         copter_leds_mode;           // Operating mode of LED
                                                // lighting system

    AP_Int8         battery_volt_pin;
    AP_Int8         battery_curr_pin;

    // Waypoints
    //
    AP_Int8         waypoint_mode;
    AP_Int8         command_total;
    AP_Int8         command_index;
    AP_Int8         command_nav_index;
    AP_Int16        waypoint_radius;
    AP_Int16        loiter_radius;
    AP_Int16        waypoint_speed_max;
    AP_Float        crosstrack_gain;
    AP_Int32        auto_land_timeout;


    // Throttle
    //
    AP_Int16        throttle_min;
    AP_Int16        throttle_max;
    AP_Int8         throttle_fs_enabled;
    AP_Int8         throttle_fs_action;
    AP_Int16        throttle_fs_value;
    AP_Int16        throttle_cruise;

    // Flight modes
    //
    AP_Int8         flight_mode1;
    AP_Int8         flight_mode2;
    AP_Int8         flight_mode3;
    AP_Int8         flight_mode4;
    AP_Int8         flight_mode5;
    AP_Int8         flight_mode6;
    AP_Int8         simple_modes;

    // Misc
    //
    AP_Int16        log_bitmask;
    AP_Int16        log_last_filenumber;        // *** Deprecated - remove
                                                // with next eeprom number
                                                // change
    AP_Int8         toy_yaw_rate;                               // THOR The
                                                                // Yaw Rate 1
                                                                // = fast, 2 =
                                                                // med, 3 =
                                                                // slow
    AP_Int8         esc_calibrate;
    AP_Int8         radio_tuning;
    AP_Int16        radio_tuning_high;
    AP_Int16        radio_tuning_low;
    AP_Int8         frame_orientation;
    AP_Int8         ch7_option;
    AP_Int16        auto_slew_rate;

#if FRAME_CONFIG ==     HELI_FRAME
    // Heli
    RC_Channel        heli_servo_1, heli_servo_2, heli_servo_3, heli_servo_4;   //
                                                                                // servos
                                                                                // for
                                                                                // swash
                                                                                // plate
                                                                                // and
                                                                                // tail
#endif

    // Camera
#if CAMERA == ENABLED
    AP_Camera        camera;
#endif

    // RC channels
    RC_Channel              rc_1;
    RC_Channel              rc_2;
    RC_Channel              rc_3;
    RC_Channel              rc_4;
    RC_Channel_aux          rc_5;
    RC_Channel_aux          rc_6;
    RC_Channel_aux          rc_7;
    RC_Channel_aux          rc_8;

#if MOUNT == ENABLED
    RC_Channel_aux          rc_10;
    RC_Channel_aux          rc_11;
#endif
    AP_Int16                rc_speed; // speed of fast RC Channels in Hz

    AP_Float                stabilize_d;
    AP_Float                stabilize_d_schedule;

    // PI/D controllers
    AP_Float                acro_p;
    AP_Float                axis_lock_p;

    AC_PID                  pid_rate_roll;
    AC_PID                  pid_rate_pitch;
    AC_PID                  pid_rate_yaw;
    AC_PID                  pid_loiter_rate_lat;
    AC_PID                  pid_loiter_rate_lon;
    AC_PID                  pid_nav_lat;
    AC_PID                  pid_nav_lon;

    AC_PID                  pid_throttle;
    AC_PID                  pid_optflow_roll;
    AC_PID                  pid_optflow_pitch;

    APM_PI                  pi_loiter_lat;
    APM_PI                  pi_loiter_lon;
    APM_PI                  pi_stabilize_roll;
    APM_PI                  pi_stabilize_pitch;
    APM_PI                  pi_stabilize_yaw;
    APM_PI                  pi_alt_hold;

    // Note: keep initializers here in the same order as they are declared
    // above.
    Parameters() :

#if FRAME_CONFIG ==     HELI_FRAME
        heli_servo_1        (CH_1),
        heli_servo_2        (CH_2),
        heli_servo_3        (CH_3),
        heli_servo_4        (CH_4),
#endif

        rc_1                (CH_1),
        rc_2                (CH_2),
        rc_3                (CH_3),
        rc_4                (CH_4),
        rc_5                (CH_5),
        rc_6                (CH_6),
        rc_7                (CH_7),
        rc_8                (CH_8),
#if MOUNT == ENABLED
        rc_10               (CH_10),
        rc_11               (CH_11),
#endif

        // PID controller	initial P	        initial I		    initial D
        //          initial imax
        //-----------------------------------------------------------------------------------------------------
        pid_rate_roll           (RATE_ROLL_P,           RATE_ROLL_I,            RATE_ROLL_D,            RATE_ROLL_IMAX * 100),
        pid_rate_pitch          (RATE_PITCH_P,          RATE_PITCH_I,           RATE_PITCH_D,           RATE_PITCH_IMAX * 100),
        pid_rate_yaw            (RATE_YAW_P,            RATE_YAW_I,             RATE_YAW_D,             RATE_YAW_IMAX * 100),

        pid_loiter_rate_lat     (LOITER_RATE_P,         LOITER_RATE_I,          LOITER_RATE_D,          LOITER_RATE_IMAX * 100),
        pid_loiter_rate_lon     (LOITER_RATE_P,         LOITER_RATE_I,          LOITER_RATE_D,          LOITER_RATE_IMAX * 100),

        pid_nav_lat             (NAV_P,                 NAV_I,                  NAV_D,                  NAV_IMAX * 100),
        pid_nav_lon             (NAV_P,                 NAV_I,                  NAV_D,                  NAV_IMAX * 100),

        pid_throttle            (THROTTLE_P,            THROTTLE_I,             THROTTLE_D,             THROTTLE_IMAX),
        pid_optflow_roll        (OPTFLOW_ROLL_P,        OPTFLOW_ROLL_I,         OPTFLOW_ROLL_D,         OPTFLOW_IMAX * 100),
        pid_optflow_pitch       (OPTFLOW_PITCH_P,       OPTFLOW_PITCH_I,        OPTFLOW_PITCH_D,        OPTFLOW_IMAX * 100),

        // PI controller	initial P			initial I			initial
        // imax
        //----------------------------------------------------------------------
        pi_loiter_lat           (LOITER_P,              LOITER_I,               LOITER_IMAX * 100),
        pi_loiter_lon           (LOITER_P,              LOITER_I,               LOITER_IMAX * 100),

        pi_stabilize_roll       (STABILIZE_ROLL_P,      STABILIZE_ROLL_I,       STABILIZE_ROLL_IMAX * 100),
        pi_stabilize_pitch      (STABILIZE_PITCH_P,     STABILIZE_PITCH_I,      STABILIZE_PITCH_IMAX * 100),
        pi_stabilize_yaw        (STABILIZE_YAW_P,       STABILIZE_YAW_I,        STABILIZE_YAW_IMAX * 100),

        pi_alt_hold             (ALT_HOLD_P,            ALT_HOLD_I,             ALT_HOLD_IMAX)
    {
    }
};

extern const AP_Param::Info        var_info[];

#endif // PARAMETERS_H

/// -*- tab-width: 4; Mode: C++; c-basic-offset: 4; indent-tabs-mode: t -*-

/*
 *  ArduCopter parameter definitions
 *
 *  This firmware is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 2.1 of the License, or (at your option) any later version.
 */

#define GSCALAR(v, name, def) { g.v.vtype, name, Parameters::k_param_ ## v, &g.v, {def_value : def} }
#define GGROUP(v, name, class) { AP_PARAM_GROUP, name, Parameters::k_param_ ## v, &g.v, {group_info : class::var_info} }
#define GOBJECT(v, name, class) { AP_PARAM_GROUP, name, Parameters::k_param_ ## v, &v, {group_info : class::var_info} }

const AP_Param::Info var_info[] PROGMEM = {
    GSCALAR(format_version, "SYSID_SW_MREV",   0),
    GSCALAR(software_type,  "SYSID_SW_TYPE",   Parameters::k_software_type),

    GSCALAR(sysid_this_mav, "SYSID_THISMAV",   MAV_SYSTEM_ID),
    GSCALAR(sysid_my_gcs,   "SYSID_MYGCS",     255),

    // @Param: SERIAL3_BAUD
    // @DisplayName: Telemetry Baud Rate
    // @Description: The baud rate used on the telemetry port
    // @Values: 1:1200,2:2400,4:4800,9:9600,19:19200,38:38400,57:57600,111:111100,115:115200
    // @User: Standard
    GSCALAR(serial3_baud,   "SERIAL3_BAUD",     SERIAL3_BAUD/1000),

    // @Param: TELEM_DELAY
    // @DisplayName: Telemetry startup delay 
    // @Description: The amount of time (in seconds) to delay radio telemetry to prevent an Xbee bricking on power up
    // @User: Standard
    // @Units: seconds
    // @Range: 0 10
    // @Increment: 1
    GSCALAR(telem_delay,            "TELEM_DELAY",     0),

    // @Param: ALT_HOLD_RTL
    // @DisplayName: RTL Altitude
    // @Description: This is the altitude the model will move to before Returning to Launch.  Set to zero to return at current altitude.
    // @Units: centimeters
    // @Range: 0 4000
    // @Increment: 1
    // @User: Standard
    GSCALAR(RTL_altitude,   "ALT_HOLD_RTL",     RTL_HOLD_ALT),

    // @Param: SONAR_ENABLE
    // @DisplayName: Enable Sonar
    // @Description: Setting this to Enabled(1) will enable the sonar. Setting this to Disabled(0) will disable the sonar
    // @Values: 0:Disabled,1:Enabled
    // @User: Standard
    GSCALAR(sonar_enabled,  "SONAR_ENABLE",     DISABLED),

    GSCALAR(sonar_type,     "SONAR_TYPE",           AP_RANGEFINDER_MAXSONARXL),
    GSCALAR(battery_monitoring, "BATT_MONITOR", DISABLED),

    // @Param: VOLT_DIVIDER
    // @DisplayName: Voltage Divider
    // @Description: TODO
    GSCALAR(volt_div_ratio, "VOLT_DIVIDER",     VOLT_DIV_RATIO),

    GSCALAR(curr_amp_per_volt,      "AMP_PER_VOLT", CURR_AMP_PER_VOLT),
    GSCALAR(input_voltage,  "INPUT_VOLTS",      INPUT_VOLTAGE),

    // @Param: BATT_CAPACITY
    // @DisplayName: Battery Capacity
    // @Description: Battery capacity in milliamp-hours (mAh)
    // @Units: mAh
    GSCALAR(pack_capacity,  "BATT_CAPACITY",    HIGH_DISCHARGE),

    // @Param: MAG_ENABLE
    // @DisplayName: Enable Compass
    // @Description: Setting this to Enabled(1) will enable the compass. Setting this to Disabled(0) will disable the compass
    // @Values: 0:Disabled,1:Enabled
    // @User: Standard
    GSCALAR(compass_enabled,        "MAG_ENABLE",   MAGNETOMETER),

    // @Param: FLOW_ENABLE
    // @DisplayName: Enable Optical Flow
    // @Description: Setting this to Enabled(1) will enable optical flow. Setting this to Disabled(0) will disable optical flow
    // @Values: 0:Disabled,1:Enabled
    // @User: Standard
    GSCALAR(optflow_enabled,        "FLOW_ENABLE",  OPTFLOW),

    // @Param: LOW_VOLT
    // @DisplayName: Low Voltage
    // @Description: Set this to the voltage you want to represent low voltage
    // @Range: 0 20
    // @Increment: .1
    // @User: Standard
    GSCALAR(low_voltage,    "LOW_VOLT",         LOW_VOLTAGE),

    // @Param: SUPER_SIMPLE
    // @DisplayName: Enable Super Simple Mode
    // @Description: Setting this to Enabled(1) will enable Super Simple Mode. Setting this to Disabled(0) will disable Super Simple Mode
    // @Values: 0:Disabled,1:Enabled
    // @User: Standard
    GSCALAR(super_simple,   "SUPER_SIMPLE",     SUPER_SIMPLE),

    // @Param: APPROACH_ALT
    // @DisplayName: RTL Approach Altitude
    // @Description: This is the altitude the vehicle will move to as the final stage of Returning to Launch.  Set to zero to land.
    // @Units: centimeters
    // @Range: 0 1000
    // @Increment: 1
    // @User: Standard
    GSCALAR(rtl_approach_alt,       "APPROACH_ALT", RTL_APPROACH_ALT),

	// @Param: TILT
    // @DisplayName: Auto Tilt Compensation
    // @Description: This is a feed-forward compensation which helps the aircraft achieve target waypoint speed.
    // @Range: 0 100
    // @Increment: 1
    // @User: Advanced
	GSCALAR(tilt_comp,      "TILT",     TILT_COMPENSATION),
	
    // @Param: BATT_VOLT_PIN
    // @DisplayName: Battery Voltage sensing pin
    // @Description: Setting this to 0 ~ 13 will enable battery current sensing on pins A0 ~ A13.
    // @Values: 99:Disabled, 0:A0, 1:A1, 13:A13
    // @User: Standard
    GSCALAR(battery_volt_pin,    "BATT_VOLT_PIN",    BATTERY_VOLT_PIN),

    // @Param: BATT_CURR_PIN
    // @DisplayName: Battery Current sensing pin
    // @Description: Setting this to 0 ~ 13 will enable battery current sensing on pins A0 ~ A13.
    // @Values: 99:Disabled, 1:A1, 2:A2, 12:A12
    // @User: Standard
    GSCALAR(battery_curr_pin,    "BATT_CURR_PIN",    BATTERY_CURR_PIN),

    GSCALAR(waypoint_mode,  "WP_MODE",          0),
    GSCALAR(command_total,  "WP_TOTAL",         0),
    GSCALAR(command_index,  "WP_INDEX",         0),
    GSCALAR(command_nav_index,      "WP_MUST_INDEX",0),

    // @Param: WP_RADIUS
    // @DisplayName: Waypoint Radius
    // @Description: Defines the distance from a waypoint, that when crossed indicates the wp has been hit.
    // @Units: Meters
    // @Range: 1 127
    // @Increment: 1
    // @User: Standard
    GSCALAR(waypoint_radius,        "WP_RADIUS",    WP_RADIUS_DEFAULT),

    // @Param: WP_LOITER_RAD
    // @DisplayName: Waypoint Loiter Radius
    // @Description: Defines the distance from the waypoint center, the vehicle will maintain during a loiter
    // @Units: Meters
    // @Range: 1 127
    // @Increment: 1
    // @User: Standard
    GSCALAR(loiter_radius,  "WP_LOITER_RAD",    LOITER_RADIUS),
	
	// @Param: WP_SPEED_MAX
    // @DisplayName: Waypoint Max Speed Target
    // @Description: Defines the speed which the aircraft will attempt to maintain during a WP mission.
    // @Units: Centimeters/Second
    // @Increment: 100
    // @User: Standard
    GSCALAR(waypoint_speed_max,     "WP_SPEED_MAX", WAYPOINT_SPEED_MAX),
	
	// @Param: XTRK_GAIN_SC
    // @DisplayName: Cross-Track Gain
    // @Description: This controls the rate that the Auto Controller will attempt to return original track
    // @Units: Dimensionless
	// @User: Standard
    GSCALAR(crosstrack_gain,        "XTRK_GAIN_SC", CROSSTRACK_GAIN),
    GSCALAR(auto_land_timeout,      "AUTO_LAND",    AUTO_LAND_TIME*1000),

    // @Param: THR_MIN
    // @DisplayName: Minimum Throttle
    // @Description: The minimum throttle which the autopilot will apply.
    // @Units: Percent
    // @Range: 0 100
    // @Increment: 1
    // @User: Standard
    GSCALAR(throttle_min,   "THR_MIN",          MINIMUM_THROTTLE),

    // @Param: THR_MAX
    // @DisplayName: Maximum Throttle
    // @Description: The maximum throttle which the autopilot will apply.
    // @Units: Percent
    // @Range: 0 100
    // @Increment: 1
    // @User: Standard
    GSCALAR(throttle_max,   "THR_MAX",          MAXIMUM_THROTTLE),

    // @Param: THR_FAILSAFE
    // @DisplayName: Throttle Failsafe Enable
    // @Description: The throttle failsafe allows you to configure a software failsafe activated by a setting on the throttle input channel
    // @Values: 0:Disabled,1:Enabled
    // @User: Standard
    GSCALAR(throttle_fs_enabled,    "THR_FAILSAFE", THROTTLE_FAILSAFE),

    GSCALAR(throttle_fs_action,     "THR_FS_ACTION",    THROTTLE_FAILSAFE_ACTION),

    // @Param: THR_FS_VALUE
    // @DisplayName: Throttle Failsafe Value
    // @Description: The PWM level on channel 3 below which throttle sailsafe triggers
    // @User: Standard
    GSCALAR(throttle_fs_value, "THR_FS_VALUE",      THROTTLE_FS_VALUE),

    GSCALAR(throttle_cruise,        "TRIM_THROTTLE",    THROTTLE_CRUISE),

    GSCALAR(flight_mode1, "FLTMODE1",               FLIGHT_MODE_1),
    GSCALAR(flight_mode2, "FLTMODE2",               FLIGHT_MODE_2),
    GSCALAR(flight_mode3, "FLTMODE3",               FLIGHT_MODE_3),
    GSCALAR(flight_mode4, "FLTMODE4",               FLIGHT_MODE_4),
    GSCALAR(flight_mode5, "FLTMODE5",               FLIGHT_MODE_5),
    GSCALAR(flight_mode6, "FLTMODE6",               FLIGHT_MODE_6),
    GSCALAR(simple_modes, "SIMPLE",                 0),

    // @Param: LOG_BITMASK
    // @DisplayName: Log bitmask
    // @Description: bitmap of log fields to enable
    // @User: Advanced
    GSCALAR(log_bitmask,    "LOG_BITMASK",          DEFAULT_LOG_BITMASK),
    GSCALAR(log_last_filenumber, "LOG_LASTFILE",    0),
    // THOR
    // Added to allow change of Rate in the Mission planner
    GSCALAR(toy_yaw_rate, "TOY_RATE",               1),

    GSCALAR(esc_calibrate, "ESC",                   0),
    GSCALAR(radio_tuning, "TUNE",                   0),
    GSCALAR(radio_tuning_low, "TUNE_LOW",           0),
    GSCALAR(radio_tuning_high, "TUNE_HIGH",         1000),
    GSCALAR(frame_orientation, "FRAME",             FRAME_ORIENTATION),
    GSCALAR(ch7_option, "CH7_OPT",                  CH7_OPTION),
	
	// @Param: AUTO_SLEW
    // @DisplayName: Auto Slew Rate
    // @Description: This restricts the rate of change of the attitude allowed by the Auto Controller
    // @Units: Degrees/Second
	// @Range: 1 45
    // @Increment: 1
    // @User: Advanced
    GSCALAR(auto_slew_rate, "AUTO_SLEW",            AUTO_SLEW_RATE),

#if FRAME_CONFIG ==     HELI_FRAME
    GGROUP(heli_servo_1,    "HS1_", RC_Channel),
    GGROUP(heli_servo_2,    "HS2_", RC_Channel),
    GGROUP(heli_servo_3,    "HS3_", RC_Channel),
    GGROUP(heli_servo_4,    "HS4_", RC_Channel),
#endif

#if CAMERA == ENABLED
    // @Group: CAM_
    // @Path: ../libraries/AP_Camera/AP_Camera.cpp
    GGROUP(camera,                  "CAM_", AP_Camera),
#endif

    // RC channel
    //-----------
    // @Group: RC1_
    // @Path: ../libraries/RC_Channel/RC_Channel.cpp
    GGROUP(rc_1,    "RC1_", RC_Channel),
    // @Group: RC2_
    // @Path: ../libraries/RC_Channel/RC_Channel.cpp
    GGROUP(rc_2,    "RC2_", RC_Channel),
    // @Group: RC3_
    // @Path: ../libraries/RC_Channel/RC_Channel.cpp
    GGROUP(rc_3,    "RC3_", RC_Channel),
    // @Group: RC4_
    // @Path: ../libraries/RC_Channel/RC_Channel.cpp
    GGROUP(rc_4,    "RC4_", RC_Channel),
    // @Group: RC5_
    // @Path: ../libraries/RC_Channel/RC_Channel_aux.cpp
    GGROUP(rc_5,    "RC5_", RC_Channel_aux),
    // @Group: RC6_
    // @Path: ../libraries/RC_Channel/RC_Channel_aux.cpp
    GGROUP(rc_6,    "RC6_", RC_Channel_aux),
    // @Group: RC7_
    // @Path: ../libraries/RC_Channel/RC_Channel_aux.cpp
    GGROUP(rc_7,    "RC7_", RC_Channel_aux),
    // @Group: RC8_
    // @Path: ../libraries/RC_Channel/RC_Channel_aux.cpp
    GGROUP(rc_8,    "RC8_", RC_Channel_aux),

#if MOUNT == ENABLED
    // @Group: RC10_
    // @Path: ../libraries/RC_Channel/RC_Channel_aux.cpp
    GGROUP(rc_10,                    "RC10_", RC_Channel_aux),

    // @Group: RC11_
    // @Path: ../libraries/RC_Channel/RC_Channel_aux.cpp
    GGROUP(rc_11,                    "RC11_", RC_Channel_aux),
#endif

    // @Param: RC_SPEED
    // @DisplayName: ESC Update Speed
    // @Description: This is the speed in Hertz that your ESCs will receive updates
    // @Units: Hertz (Hz)
    // @Values: 125,400,490
    // @User: Advanced
    GSCALAR(rc_speed, "RC_SPEED",              RC_FAST_SPEED),

    // variable
    //---------
    GSCALAR(stabilize_d,                    "STAB_D",  STABILIZE_D),

    // @Param: STAB_D_S
    // @DisplayName: Stabilize D Schedule
    // @Description: This value is a percentage of scheduling applied to the Stabilize D term.
    // @Range: 0 1
    // @Increment: .01
    // @User: Advanced
    GSCALAR(stabilize_d_schedule, "STAB_D_S",  STABILIZE_D_SCHEDULE),

    GSCALAR(acro_p,                         "ACRO_P",      ACRO_P),
    GSCALAR(axis_lock_p,            "AXIS_P",      AXIS_LOCK_P),
    GSCALAR(axis_enabled,           "AXIS_ENABLE", AXIS_LOCK_ENABLED),
    GSCALAR(copter_leds_mode,       "LED_MODE",    9),

    // PID controller
    //---------------
    GGROUP(pid_rate_roll,     "RATE_RLL_", AC_PID),
    GGROUP(pid_rate_pitch,    "RATE_PIT_", AC_PID),
    GGROUP(pid_rate_yaw,      "RATE_YAW_", AC_PID),


    GGROUP(pid_loiter_rate_lat,      "LOITER_LAT_",  AC_PID),
    GGROUP(pid_loiter_rate_lon,      "LOITER_LON_",  AC_PID),

    GGROUP(pid_nav_lat,             "NAV_LAT_",  AC_PID),
    GGROUP(pid_nav_lon,             "NAV_LON_",  AC_PID),

    GGROUP(pid_throttle,      "THR_RATE_", AC_PID),
    GGROUP(pid_optflow_roll,  "OF_RLL_",   AC_PID),
    GGROUP(pid_optflow_pitch, "OF_PIT_",   AC_PID),

    // PI controller
    //--------------
    GGROUP(pi_stabilize_roll,       "STB_RLL_", APM_PI),
    GGROUP(pi_stabilize_pitch,      "STB_PIT_", APM_PI),
    GGROUP(pi_stabilize_yaw,        "STB_YAW_", APM_PI),

    GGROUP(pi_alt_hold,             "THR_ALT_", APM_PI),
    GGROUP(pi_loiter_lat,   "HLD_LAT_", APM_PI),
    GGROUP(pi_loiter_lon,   "HLD_LON_", APM_PI),

    // variables not in the g class which contain EEPROM saved variables

    // @Group: COMPASS_
    // @Path: ../libraries/AP_Compass/Compass.cpp
    GOBJECT(compass,        "COMPASS_", Compass),

    // @Group: INS_
    // @Path: ../libraries/AP_InertialSensor/AP_InertialSensor_Oilpan.cpp
#if HIL_MODE == HIL_MODE_DISABLED && CONFIG_APM_HARDWARE == APM_HARDWARE_APM1
    GOBJECT(ins,            "INS_", AP_InertialSensor_Oilpan),
#endif

    GOBJECT(gcs0,                   "SR0_",     GCS_MAVLINK),
    GOBJECT(gcs3,                   "SR3_",     GCS_MAVLINK),

    // @Group: IMU_
    // @Path: ../libraries/AP_IMU/IMU.cpp
    GOBJECT(imu,                    "IMU_",     IMU),

    // @Group: AHRS_
    // @Path: ../libraries/AP_AHRS/AP_AHRS.cpp
    GOBJECT(ahrs,                   "AHRS_",    AP_AHRS),

#if MOUNT == ENABLED
    // @Group: MNT_
    // @Path: ../libraries/AP_Mount/AP_Mount.cpp
    GOBJECT(camera_mount,           "MNT_", AP_Mount),
#endif

#if MOUNT2 == ENABLED
    // @Group: MNT2_
    // @Path: ../libraries/AP_Mount/AP_Mount.cpp
    GOBJECT(camera_mount2,           "MNT2_",       AP_Mount),
#endif

#ifdef DESKTOP_BUILD
    GOBJECT(sitl, "SIM_", SITL),
#endif

    //@Group: LIM_
    //@Path: ../libraries/AP_Limits/AP_Limits.cpp,../libraries/AP_Limits/AP_Limit_GPSLock.cpp, ../libraries/AP_Limits/AP_Limit_Geofence.cpp, ../libraries/AP_Limits/AP_Limit_Altitude.cpp, ../libraries/AP_Limits/AP_Limit_Module.cpp
    GOBJECT(limits,                 "LIM_",    AP_Limits),
    GOBJECT(gpslock_limit,          "LIM_",    AP_Limit_GPSLock),
    GOBJECT(geofence_limit,         "LIM_",    AP_Limit_Geofence),
    GOBJECT(altitude_limit,         "LIM_",    AP_Limit_Altitude),

#if FRAME_CONFIG ==     HELI_FRAME
    // @Group: H_
    // @Path: ../libraries/AP_Motors/AP_MotorsHeli.cpp
    GOBJECT(motors, "H_",           AP_MotorsHeli),
#else
    GOBJECT(motors, "MOT_",         AP_Motors),
#endif

    AP_VAREND
};


static void load_parameters(void)
{
    // change the default for the AHRS_GPS_GAIN for ArduCopter
    // if it hasn't been set by the user
    if (!ahrs.gps_gain.load()) {
        ahrs.gps_gain.set_and_save(0.0);
    }

    // setup different AHRS gains for ArduCopter than the default
    // but allow users to override in their config
    if (!ahrs._kp.load()) {
        ahrs._kp.set_and_save(0.1);
    }
    if (!ahrs._kp_yaw.load()) {
        ahrs._kp_yaw.set_and_save(0.1);
    }

#if SECONDARY_DMP_ENABLED == ENABLED
    if (!ahrs2._kp.load()) {
        ahrs2._kp.set(0.1);
    }
    if (!ahrs2._kp_yaw.load()) {
        ahrs2._kp_yaw.set(0.1);
    }
#endif


    if (!g.format_version.load() ||
        g.format_version != Parameters::k_format_version) {

        // erase all parameters
        Serial.printf_P(PSTR("Firmware change: erasing EEPROM...\n"));
        AP_Param::erase_all();

        // save the current format version
        g.format_version.set_and_save(Parameters::k_format_version);
        default_dead_zones();
        Serial.println_P(PSTR("done."));
    } else {
        uint32_t before = micros();
        // Load all auto-loaded EEPROM variables
        AP_Param::load_all();

        Serial.printf_P(PSTR("load_all took %luus\n"), micros() - before);
    }
}
// -*- tab-width: 4; Mode: C++; c-basic-offset: 4; indent-tabs-mode: nil -*-

// These are function definitions so the Menu can be constructed before the functions
// are defined below. Order matters to the compiler.
static int8_t   planner_gcs(uint8_t argc,               const Menu::arg *argv);

// Creates a constant array of structs representing menu options
// and stores them in Flash memory, not RAM.
// User enters the string in the console to call the functions on the right.
// See class Menu in AP_Common for implementation details
const struct Menu::command planner_menu_commands[] PROGMEM = {
    {"gcs",         planner_gcs},
};

// A Macro to create the Menu
MENU(planner_menu, "planner", planner_menu_commands);

static int8_t
planner_mode(uint8_t argc, const Menu::arg *argv)
{
    Serial.printf_P(PSTR("Planner Mode\nNot intended for manual use\n\n"));
    planner_menu.run();
    return (0);
}

static int8_t
planner_gcs(uint8_t argc, const Menu::arg *argv)
{
    gcs0.init(&Serial);

    int16_t loopcount = 0;

    while (1) {
        if (millis()-fast_loopTimer > 19) {
            fast_loopTimer                  = millis();

            gcs_update();

            read_radio();

            gcs_data_stream_send();

            if ((loopcount % 16) == 0) { // 3 hz
                gcs_send_message(MSG_HEARTBEAT);
            }

            loopcount++;
        }
    }
    return 0;
}

// -*- tab-width: 4; Mode: C++; c-basic-offset: 4; indent-tabs-mode: nil -*-

//Function that will read the radio data, limit servos and trigger a failsafe
// ----------------------------------------------------------------------------
static int8_t failsafeCounter = 0;              // we wait a second to take over the throttle and send the plane circling


extern RC_Channel* rc_ch[NUM_CHANNELS];

static void default_dead_zones()
{
    g.rc_1.set_dead_zone(60);
    g.rc_2.set_dead_zone(60);
#if FRAME_CONFIG == HELI_FRAME
    g.rc_3.set_dead_zone(20);
    g.rc_4.set_dead_zone(30);
#else
    g.rc_3.set_dead_zone(60);
    g.rc_4.set_dead_zone(80);
#endif
}

static void init_rc_in()
{
    // set rc channel ranges
    g.rc_1.set_angle(4500);
    g.rc_2.set_angle(4500);
#if FRAME_CONFIG == HELI_FRAME
    // we do not want to limit the movment of the heli's swash plate
    g.rc_3.set_range(0, 1000);
#else
    g.rc_3.set_range(g.throttle_min, g.throttle_max);
#endif
    g.rc_4.set_angle(4500);

    // reverse: CW = left
    // normal:  CW = left???

    g.rc_1.set_type(RC_CHANNEL_ANGLE_RAW);
    g.rc_2.set_type(RC_CHANNEL_ANGLE_RAW);
    g.rc_4.set_type(RC_CHANNEL_ANGLE_RAW);

    rc_ch[CH_1] = &g.rc_1;
    rc_ch[CH_2] = &g.rc_2;
    rc_ch[CH_3] = &g.rc_3;
    rc_ch[CH_4] = &g.rc_4;
    rc_ch[CH_5] = &g.rc_5;
    rc_ch[CH_6] = &g.rc_6;
    rc_ch[CH_7] = &g.rc_7;
    rc_ch[CH_8] = &g.rc_8;

    //set auxiliary ranges
    g.rc_5.set_range(0,1000);
    g.rc_6.set_range(0,1000);
    g.rc_7.set_range(0,1000);
    g.rc_8.set_range(0,1000);

#if MOUNT == ENABLED
    update_aux_servo_function(&g.rc_5, &g.rc_6, &g.rc_7, &g.rc_8, &g.rc_10, &g.rc_11);
#endif
}

static void init_rc_out()
{
    APM_RC.Init( &isr_registry );               // APM Radio initialization

    motors.set_update_rate(g.rc_speed);
    motors.set_frame_orientation(g.frame_orientation);
    motors.Init();                                              // motor initialisation
    motors.set_min_throttle(g.throttle_min);
    motors.set_max_throttle(g.throttle_max);

    for(byte i = 0; i < 5; i++) {
        delay(20);
        read_radio();
    }

    // we want the input to be scaled correctly
    g.rc_3.set_range_out(0,1000);

    // sanity check - prevent unconfigured radios from outputting
    if(g.rc_3.radio_min >= 1300) {
        g.rc_3.radio_min = g.rc_3.radio_in;
    }

    // we are full throttle
    if(g.rc_3.control_in >= (MAXIMUM_THROTTLE - 50)) {
        if(g.esc_calibrate == 0) {
            // we will enter esc_calibrate mode on next reboot
            g.esc_calibrate.set_and_save(1);
            // send miinimum throttle out to ESC
            motors.output_min();
            // display message on console
            Serial.printf_P(PSTR("Entering ESC Calibration: please restart APM.\n"));
            // block until we restart
            while(1) {
                delay(200);
                dancing_light();
            }
        }else{
            Serial.printf_P(PSTR("ESC Calibration active: passing throttle through to ESCs.\n"));
            // clear esc flag
            g.esc_calibrate.set_and_save(0);
            // block until we restart
            init_esc();
        }
    }else{
        // did we abort the calibration?
        if(g.esc_calibrate == 1)
            g.esc_calibrate.set_and_save(0);

        // send miinimum throttle out to ESC
        output_min();
    }

#if TOY_EDF == ENABLED
    // add access to CH8 and CH6
    APM_RC.enable_out(CH_8);
    APM_RC.enable_out(CH_6);
#endif
}

void output_min()
{
    // enable motors
    motors.enable();
    motors.output_min();
}
static void read_radio()
{
    if (APM_RC.GetState() == 1) {
        new_radio_frame = true;
        g.rc_1.set_pwm(APM_RC.InputCh(CH_1));
        g.rc_2.set_pwm(APM_RC.InputCh(CH_2));
        g.rc_3.set_pwm(APM_RC.InputCh(CH_3));
        g.rc_4.set_pwm(APM_RC.InputCh(CH_4));
        g.rc_5.set_pwm(APM_RC.InputCh(CH_5));
        g.rc_6.set_pwm(APM_RC.InputCh(CH_6));
        g.rc_7.set_pwm(APM_RC.InputCh(CH_7));
        g.rc_8.set_pwm(APM_RC.InputCh(CH_8));

#if FRAME_CONFIG != HELI_FRAME
        // limit our input to 800 so we can still pitch and roll
        g.rc_3.control_in = min(g.rc_3.control_in, MAXIMUM_THROTTLE);
#endif

        throttle_failsafe(g.rc_3.radio_in);
    }
}
#define FS_COUNTER 3
static void throttle_failsafe(uint16_t pwm)
{
    // Don't enter Failsafe if not enabled by user
    if(g.throttle_fs_enabled == 0)
        return;

    //check for failsafe and debounce funky reads
    // ------------------------------------------
    if (pwm < (unsigned)g.throttle_fs_value) {
        // we detect a failsafe from radio
        // throttle has dropped below the mark
        failsafeCounter++;
        if (failsafeCounter == FS_COUNTER-1) {
            // called right before trigger
            // do nothing
        }else if(failsafeCounter == FS_COUNTER) {
            // Don't enter Failsafe if we are not armed
            // home distance is in meters
            // This is to prevent accidental RTL
            if(motors.armed() && takeoff_complete) {
                Serial.print_P(PSTR("MSG FS ON "));
                Serial.println(pwm, DEC);
                set_failsafe(true);
            }
        }else if (failsafeCounter > FS_COUNTER) {
            failsafeCounter = FS_COUNTER+1;
        }

    }else if(failsafeCounter > 0) {
        // we are no longer in failsafe condition
        // but we need to recover quickly
        failsafeCounter--;
        if (failsafeCounter > 3) {
            failsafeCounter = 3;
        }
        if (failsafeCounter == 1) {
            Serial.print_P(PSTR("MSG FS OFF "));
            Serial.println(pwm, DEC);
        }else if(failsafeCounter == 0) {
            set_failsafe(false);
        }else if (failsafeCounter <0) {
            failsafeCounter = -1;
        }
    }
}

static void trim_radio()
{
    for (byte i = 0; i < 30; i++) {
        read_radio();
    }

    g.rc_1.trim();      // roll
    g.rc_2.trim();      // pitch
    g.rc_4.trim();      // yaw

    g.rc_1.save_eeprom();
    g.rc_2.save_eeprom();
    g.rc_4.save_eeprom();
}

Make sure you update the libraries from the arducopter trunk and the latest code from the ardupilotmega branch.

Radio setup:
ch1 = roll
ch2 = pitch
ch3 = throttle
ch4 = yaw
ch5 = mode switch - use your 3 position switch
ch6 = used for in-air tuning - see AP_Config.h for options
ch7 = use to set throttle hold value while hovering (quick toggle), hold to trim in air values - don't use your radio's trims!
ch8 = NOT used!!! - this is the hardware manual - it's dangerous to use for quads BEWARE!!!

CLI interactive setup - You must go through each item and set the values to match your hardware

"setup" menu:
erase			- when installing ACM for the first time, run this to erases bad values from EEPROMS – just in case
reset			- Performs factory reset and initialization of EEPROM values
radio			- records the limits of ALL radio channels - very important!!!
pid				- restores default PID values - - only needed if you have changed them in flight with CGS, not for setup.
frame			- sets your frame config: [x, +, tri, hexax, hexa+, y6]
motors			- interactive setup of your ESC and motors, enter this mode, then plug-in battery,
					point at motors to make them spin
					throttle will output full range to each motor - this is good for esc calibration
level			- sets initial value of accelerometers - hold copter level
modes			- sets the flight modes assigned to each switch position (you have 5 available)
current			- enables an Attopilot current sensor: [on, off, milliamp hours]
compass			- enables the compass [on, off]
declination		- sets your local declination value – lookup online for accuracy [decimal degrees]
sonar			- Sonar hooks to the "pitot" port which is an analog input [on, off]
show			- a formatted output of all the settings

"test" menu:
pwm				- outputs the pwm values of all 8 radio channels
radio			- outputs the control values of all 8 radio channels in degrees * 100 or other value (see radio.pde)
gps				- outputs GPS data
rawgps			- outputs raw, unparsed GPS data
adc				- outputs raw adc values
imu				- outputs euler angles
battery			- outputs voltage readings to analog in 0-3
current			- outputs voltage and current from an AttoPilot current sensor
relay			- toggles the relay
sonar			- outputs sonar data in cm
waypoints		- dumps stored waypoint commands
airpressure		- raw output of absolute presure sensor
compass			- outputs compass angles in degrees (0 = north)
xbee			- outputs an XBEE sequence used for range testing
mission			- writes a default mission to EEPROM [null, 'wp']
				- choosing 'wp' option will send the copter 15 meters North and back again.
eedump			- raw output of bytes in eeprom

"logs" Menu:
See the APM wiki to better understand how to dump logs and how to set the types of data you want to record.


ACM Flight modes:
Set these up in 'setup'/'modes'. Use your three position switch (channel 5) to select. Change the setting with your roll (Aileron) stick. Hit enter to save.
All of the modes allow the user to control the copter with the normal controls. You can get yourself out of a jam sometimes by simply nudging the copter while in AUTO or LOITER modes.
Options include:
ACRO		- rate control only. not for beginners
STABILIZE	- copter will hold any angle from -45 to 45° based on roll and pitch stick input. Manual throttle.
SIMPLE		- Remembers the yaw orientation of the copter when first entering SIMPLE mode, allowing the user to fly more intuitivey. Manual throttle.
ALT_HOLD	- altitude is controlled by the throttle lever. Middle is hold, high = rise, low = fall.
LOITER 		- When selected, it will hold the current altitude, position and yaw. Yaw is user controllable. roll and pitch can be overridden temporarily with the radio.
				altitude is controlled by the throttle lever. Middle is hold, high = rise, low = fall.
RTL 		- Will try and fly back to home at the current altitude.
AUTO 		- Will fly the mission loaded by the Waypoint writer
GUIDED	- A future mode where the copter can be flown interactively from the GCS


Special note:
The props will NOT spin in stabilize when throttle is in the off position, even when armed.
Arming is Yaw right for 1 sec, disarm is yaw left for 1 sec. Just give it some juice to confirm arming.

Auto modes will NOT engage until the throttle is above neutral. So if you put the control switch to positio hold while it's on the ground, it will no spin up. Or at leat it shouldn't ;)
// -*- tab-width: 4; Mode: C++; c-basic-offset: 4; indent-tabs-mode: nil -*-

// Sensors are not available in HIL_MODE_ATTITUDE
#if HIL_MODE != HIL_MODE_ATTITUDE

static void ReadSCP1000(void) {
}

 #if CONFIG_SONAR == ENABLED
static void init_sonar(void)
{
  #if CONFIG_SONAR_SOURCE == SONAR_SOURCE_ADC
    sonar.calculate_scaler(g.sonar_type, 3.3);
  #else
    sonar.calculate_scaler(g.sonar_type, 5.0);
  #endif
}
 #endif

static void init_barometer(void)
{
    barometer.calibrate(mavlink_delay);
    ahrs.set_barometer(&barometer);
    gcs_send_text_P(SEVERITY_LOW, PSTR("barometer calibration complete"));
}

// return barometric altitude in centimeters
static int32_t read_barometer(void)
{
    barometer.read();
    return baro_filter.apply(barometer.get_altitude() * 100.0);
}


#endif // HIL_MODE != HIL_MODE_ATTITUDE

static void init_compass()
{
    compass.set_orientation(MAG_ORIENTATION);                                                   // set compass's orientation on aircraft
    if (!compass.init() || !compass.read()) {
        // make sure we don't pass a broken compass to DCM
        Serial.println_P(PSTR("COMPASS INIT ERROR"));
        return;
    }
    ahrs.set_compass(&compass);
#if SECONDARY_DMP_ENABLED == ENABLED
    ahrs2.set_compass(&compass);
#endif
}

static void init_optflow()
{
#ifdef OPTFLOW_ENABLED
    if( optflow.init(false, &timer_scheduler, &spi_semaphore, &spi3_semaphore) == false ) {
        g.optflow_enabled = false;
        Serial.print_P(PSTR("\nFailed to Init OptFlow "));
    }
    // suspend timer while we set-up SPI communication
    timer_scheduler.suspend_timer();

    optflow.set_orientation(OPTFLOW_ORIENTATION);                       // set optical flow sensor's orientation on aircraft
    optflow.set_frame_rate(2000);                                                       // set minimum update rate (which should lead to maximum low light performance
    optflow.set_resolution(OPTFLOW_RESOLUTION);                                 // set optical flow sensor's resolution
    optflow.set_field_of_view(OPTFLOW_FOV);                                     // set optical flow sensor's field of view

    // resume timer
    timer_scheduler.resume_timer();
#endif
}

static void read_battery(void)
{

    if(g.battery_monitoring == 0) {
        battery_voltage1 = 0;
        return;
    }

    if(g.battery_monitoring == 3 || g.battery_monitoring == 4) {
        static AP_AnalogSource_Arduino batt_volt_pin(g.battery_volt_pin);
        batt_volt_pin.set_pin(g.battery_volt_pin);
        battery_voltage1 = BATTERY_VOLTAGE(batt_volt_pin.read_average());
    }
    if(g.battery_monitoring == 4) {
        static AP_AnalogSource_Arduino batt_curr_pin(g.battery_curr_pin);
        batt_curr_pin.set_pin(g.battery_curr_pin);
        current_amps1    = CURRENT_AMPS(batt_curr_pin.read_average());
        current_total1   += current_amps1 * 0.02778;            // called at 100ms on average, .0002778 is 1/3600 (conversion to hours)
    }

#if BATTERY_EVENT == ENABLED
    //if(battery_voltage < g.low_voltage)
    //	low_battery_event();

    if((battery_voltage1 < g.low_voltage) || (g.battery_monitoring == 4 && current_total1 > g.pack_capacity)) {
        low_battery_event();

 #if COPTER_LEDS == ENABLED
        if ( bitRead(g.copter_leds_mode, 3) ) {         // Only Activate if a battery is connected to avoid alarm on USB only
            if (battery_voltage1 > 1) {
                piezo_on();
            }else{
                piezo_off();
            }
        }


    }else if ( bitRead(g.copter_leds_mode, 3) ) {
        piezo_off();
 #endif                // COPTER_LEDS
    }
#endif         //BATTERY_EVENT
}

//v: 10.9453, a: 17.4023, mah: 8.2
// -*- tab-width: 4; Mode: C++; c-basic-offset: 4; indent-tabs-mode: nil -*-

#if CLI_ENABLED == ENABLED

// Functions called from the setup menu
static int8_t   setup_radio                             (uint8_t argc, const Menu::arg *argv);
static int8_t   setup_motors                    (uint8_t argc, const Menu::arg *argv);
static int8_t   setup_accel                             (uint8_t argc, const Menu::arg *argv);
static int8_t   setup_accel_scale               (uint8_t argc, const Menu::arg *argv);
static int8_t   setup_frame                             (uint8_t argc, const Menu::arg *argv);
static int8_t   setup_factory                   (uint8_t argc, const Menu::arg *argv);
static int8_t   setup_erase                             (uint8_t argc, const Menu::arg *argv);
static int8_t   setup_flightmodes               (uint8_t argc, const Menu::arg *argv);
static int8_t   setup_batt_monitor              (uint8_t argc, const Menu::arg *argv);
static int8_t   setup_sonar                             (uint8_t argc, const Menu::arg *argv);
static int8_t   setup_compass                   (uint8_t argc, const Menu::arg *argv);
static int8_t   setup_tune                              (uint8_t argc, const Menu::arg *argv);
static int8_t   setup_range                             (uint8_t argc, const Menu::arg *argv);
//static int8_t	setup_mag_offset		(uint8_t argc, const Menu::arg *argv);
static int8_t   setup_declination               (uint8_t argc, const Menu::arg *argv);
static int8_t   setup_optflow                   (uint8_t argc, const Menu::arg *argv);


 #if FRAME_CONFIG == HELI_FRAME
static int8_t   setup_heli                              (uint8_t argc, const Menu::arg *argv);
static int8_t   setup_gyro                              (uint8_t argc, const Menu::arg *argv);
 #endif

// Command/function table for the setup menu
const struct Menu::command setup_menu_commands[] PROGMEM = {
    // command			function called
    // =======          ===============
    {"erase",                       setup_erase},
    {"reset",                       setup_factory},
    {"radio",                       setup_radio},
    {"frame",                       setup_frame},
    {"motors",                      setup_motors},
    {"level",                       setup_accel},
    {"accel",                       setup_accel_scale},
    {"modes",                       setup_flightmodes},
    {"battery",                     setup_batt_monitor},
    {"sonar",                       setup_sonar},
    {"compass",                     setup_compass},
    {"tune",                        setup_tune},
    {"range",                       setup_range},
//	{"offsets",			setup_mag_offset},
    {"declination",         setup_declination},
    {"optflow",                     setup_optflow},
 #if FRAME_CONFIG == HELI_FRAME
    {"heli",                        setup_heli},
    {"gyro",                        setup_gyro},
 #endif
    {"show",                        setup_show}
};

// Create the setup menu object.
MENU(setup_menu, "setup", setup_menu_commands);

// Called from the top-level menu to run the setup menu.
static int8_t
setup_mode(uint8_t argc, const Menu::arg *argv)
{
    // Give the user some guidance
    Serial.printf_P(PSTR("Setup Mode\n\n\n"));
    //"\n"
    //"IMPORTANT: if you have not previously set this system up, use the\n"
    //"'reset' command to initialize the EEPROM to sensible default values\n"
    //"and then the 'radio' command to configure for your radio.\n"
    //"\n"));

    if(g.rc_1.radio_min >= 1300) {
        delay(1000);
        Serial.printf_P(PSTR("\n!Warning, radio not configured!"));
        delay(1000);
        Serial.printf_P(PSTR("\n Type 'radio' now.\n\n"));
    }

    // Run the setup menu.  When the menu exits, we will return to the main menu.
    setup_menu.run();
    return 0;
}

// Print the current configuration.
// Called by the setup menu 'show' command.
static int8_t
setup_show(uint8_t argc, const Menu::arg *argv)
{
    // clear the area
    print_blanks(8);

    report_version();
    report_radio();
    report_frame();
    report_batt_monitor();
    report_sonar();
    //report_gains();
    //report_xtrack();
    //report_throttle();
    report_flight_modes();
    report_imu();
    report_compass();
    report_optflow();

 #if FRAME_CONFIG == HELI_FRAME
    report_heli();
    report_gyro();
 #endif

    AP_Param::show_all();

    return(0);
}

// Initialise the EEPROM to 'factory' settings (mostly defined in APM_Config.h or via defaults).
// Called by the setup menu 'factoryreset' command.
static int8_t
setup_factory(uint8_t argc, const Menu::arg *argv)
{
    int16_t c;

    Serial.printf_P(PSTR("\n'Y' = factory reset, any other key to abort:\n"));

    do {
        c = Serial.read();
    } while (-1 == c);

    if (('y' != c) && ('Y' != c))
        return(-1);

    AP_Param::erase_all();
    Serial.printf_P(PSTR("\nReboot APM"));

    delay(1000);
    //default_gains();

    for (;; ) {
    }
    // note, cannot actually return here
    return(0);
}

// Perform radio setup.
// Called by the setup menu 'radio' command.
static int8_t
setup_radio(uint8_t argc, const Menu::arg *argv)
{
    Serial.println_P(PSTR("\n\nRadio Setup:"));
    uint8_t i;

    for(i = 0; i < 100; i++) {
        delay(20);
        read_radio();
    }

    if(g.rc_1.radio_in < 500) {
        while(1) {
            //Serial.printf_P(PSTR("\nNo radio; Check connectors."));
            delay(1000);
            // stop here
        }
    }

    g.rc_1.radio_min = g.rc_1.radio_in;
    g.rc_2.radio_min = g.rc_2.radio_in;
    g.rc_3.radio_min = g.rc_3.radio_in;
    g.rc_4.radio_min = g.rc_4.radio_in;
    g.rc_5.radio_min = g.rc_5.radio_in;
    g.rc_6.radio_min = g.rc_6.radio_in;
    g.rc_7.radio_min = g.rc_7.radio_in;
    g.rc_8.radio_min = g.rc_8.radio_in;

    g.rc_1.radio_max = g.rc_1.radio_in;
    g.rc_2.radio_max = g.rc_2.radio_in;
    g.rc_3.radio_max = g.rc_3.radio_in;
    g.rc_4.radio_max = g.rc_4.radio_in;
    g.rc_5.radio_max = g.rc_5.radio_in;
    g.rc_6.radio_max = g.rc_6.radio_in;
    g.rc_7.radio_max = g.rc_7.radio_in;
    g.rc_8.radio_max = g.rc_8.radio_in;

    g.rc_1.radio_trim = g.rc_1.radio_in;
    g.rc_2.radio_trim = g.rc_2.radio_in;
    g.rc_4.radio_trim = g.rc_4.radio_in;
    // 3 is not trimed
    g.rc_5.radio_trim = 1500;
    g.rc_6.radio_trim = 1500;
    g.rc_7.radio_trim = 1500;
    g.rc_8.radio_trim = 1500;


    Serial.printf_P(PSTR("\nMove all controls to extremes. Enter to save: "));
    while(1) {

        delay(20);
        // Filters radio input - adjust filters in the radio.pde file
        // ----------------------------------------------------------
        read_radio();

        g.rc_1.update_min_max();
        g.rc_2.update_min_max();
        g.rc_3.update_min_max();
        g.rc_4.update_min_max();
        g.rc_5.update_min_max();
        g.rc_6.update_min_max();
        g.rc_7.update_min_max();
        g.rc_8.update_min_max();

        if(Serial.available() > 0) {
            delay(20);
            Serial.flush();

            g.rc_1.save_eeprom();
            g.rc_2.save_eeprom();
            g.rc_3.save_eeprom();
            g.rc_4.save_eeprom();
            g.rc_5.save_eeprom();
            g.rc_6.save_eeprom();
            g.rc_7.save_eeprom();
            g.rc_8.save_eeprom();

            print_done();
            break;
        }
    }
    report_radio();
    return(0);
}

static int8_t
setup_motors(uint8_t argc, const Menu::arg *argv)
{
    Serial.printf_P(PSTR(
                        "Now connect the main lipo and follow the instruction on the wiki for your frame setup.\n"
                        "For security remember to disconnect the main lipo after the test, then hit any key to exit.\n"
                        "Any key to exit.\n"));
    while(1) {
        delay(20);
        read_radio();
        motors.output_test();
        if(Serial.available() > 0) {
            g.esc_calibrate.set_and_save(0);
            return(0);
        }
    }
}

static int8_t
setup_accel(uint8_t argc, const Menu::arg *argv)
{
    imu.init(IMU::COLD_START, delay, flash_leds, &timer_scheduler);
    imu.init_accel(delay, flash_leds);
    print_accel_offsets();
    report_imu();
    return(0);
}


static int8_t
setup_accel_scale(uint8_t argc, const Menu::arg *argv)
{
 #if CONFIG_ADC == ENABLED && HIL_MODE == HIL_MODE_DISABLED
    int8_t accel_num;
    float accel_avg = 0;

    if (!strcmp_P(argv[1].str, PSTR("x"))) {
        accel_num = 4;
    }else if (!strcmp_P(argv[1].str, PSTR("y"))) {
        accel_num = 5;
    }else if (!strcmp_P(argv[1].str, PSTR("z"))) {
        accel_num = 6;
    }else{
        Serial.printf_P(PSTR("x, y, or z\n"));
        return 0;
    }
    print_hit_enter();
    Serial.printf_P(PSTR("ADC\n"));

    adc.Init(&timer_scheduler);                           // APM ADC library initialization

    int16_t low, high;

    delay(1000);
    accel_avg = adc.Ch(accel_num);
    low = high = accel_avg;

    while(1) {
        delay(50);
        accel_avg = accel_avg * .95 + adc.Ch(accel_num) * .05;

        if(accel_avg > high)
            high = ceil(accel_avg);

        if(accel_avg < low)
            low = floor(accel_avg);

        Serial.printf_P(PSTR("%1.2f, %d, %d\n"), accel_avg, low, high);

        if(Serial.available() > 0) {
            if(wait_for_yes()) {
                if(accel_num == 4) {
                    ins._x_high     = high;
                    ins._x_low              = low;
                    ins._x_high.save();
                    ins._x_low.save();
                }else if(accel_num == 5) {
                    ins._y_high     = high;
                    ins._y_low              = low;
                    ins._y_high.save();
                    ins._y_low.save();
                }else{
                    ins._z_high     = high;
                    ins._z_low              = low;
                    ins._z_high.save();
                    ins._z_low.save();
                }
                print_done();
            }
            return (0);
        }
    }
 #else
    return 0;
 #endif        // CONFIG_ADC
}

static int8_t
setup_frame(uint8_t argc, const Menu::arg *argv)
{
    if (!strcmp_P(argv[1].str, PSTR("x"))) {
        g.frame_orientation.set_and_save(X_FRAME);
    } else if (!strcmp_P(argv[1].str, PSTR("p"))) {
        g.frame_orientation.set_and_save(PLUS_FRAME);
    } else if (!strcmp_P(argv[1].str, PSTR("+"))) {
        g.frame_orientation.set_and_save(PLUS_FRAME);
    } else if (!strcmp_P(argv[1].str, PSTR("v"))) {
        g.frame_orientation.set_and_save(V_FRAME);
    }else{
        Serial.printf_P(PSTR("\nOp:[x,+,v]\n"));
        report_frame();
        return 0;
    }

    report_frame();
    return 0;
}

static int8_t
setup_flightmodes(uint8_t argc, const Menu::arg *argv)
{
    byte _switchPosition = 0;
    byte _oldSwitchPosition = 0;
    int8_t mode = 0;

    Serial.printf_P(PSTR("\nMode switch to edit, aileron: select modes, rudder: Simple on/off\n"));
    print_hit_enter();

    while(1) {
        delay(20);
        read_radio();
        _switchPosition = readSwitch();


        // look for control switch change
        if (_oldSwitchPosition != _switchPosition) {

            mode = flight_modes[_switchPosition];
            mode = constrain(mode, 0, NUM_MODES-1);

            // update the user
            print_switch(_switchPosition, mode, (g.simple_modes & (1<<_switchPosition)));

            // Remember switch position
            _oldSwitchPosition = _switchPosition;
        }

        // look for stick input
        if (abs(g.rc_1.control_in) > 3000) {
            mode++;
            if(mode >= NUM_MODES)
                mode = 0;

            // save new mode
            flight_modes[_switchPosition] = mode;

            // print new mode
            print_switch(_switchPosition, mode, (g.simple_modes & (1<<_switchPosition)));
            delay(500);
        }

        // look for stick input
        if (g.rc_4.control_in > 3000) {
            g.simple_modes |= (1<<_switchPosition);
            // print new mode
            print_switch(_switchPosition, mode, (g.simple_modes & (1<<_switchPosition)));
            delay(500);
        }

        // look for stick input
        if (g.rc_4.control_in < -3000) {
            g.simple_modes &= ~(1<<_switchPosition);
            // print new mode
            print_switch(_switchPosition, mode, (g.simple_modes & (1<<_switchPosition)));
            delay(500);
        }

        // escape hatch
        if(Serial.available() > 0) {
            for (mode = 0; mode < 6; mode++)
                flight_modes[mode].save();

            g.simple_modes.save();
            print_done();
            report_flight_modes();
            return (0);
        }
    }
}

static int8_t
setup_declination(uint8_t argc, const Menu::arg *argv)
{
    compass.set_declination(radians(argv[1].f));
    report_compass();
    return 0;
}

static int8_t
setup_tune(uint8_t argc, const Menu::arg *argv)
{
    g.radio_tuning.set_and_save(argv[1].i);
    //g.radio_tuning_high.set_and_save(1000);
    //g.radio_tuning_low.set_and_save(0);
    report_tuning();
    return 0;
}

static int8_t
setup_range(uint8_t argc, const Menu::arg *argv)
{
    Serial.printf_P(PSTR("\nCH 6 Ranges are divided by 1000: [low, high]\n"));

    g.radio_tuning_low.set_and_save(argv[1].i);
    g.radio_tuning_high.set_and_save(argv[2].i);
    report_tuning();
    return 0;
}



static int8_t
setup_erase(uint8_t argc, const Menu::arg *argv)
{
    zero_eeprom();
    return 0;
}

static int8_t
setup_compass(uint8_t argc, const Menu::arg *argv)
{
    if (!strcmp_P(argv[1].str, PSTR("on"))) {
        g.compass_enabled.set_and_save(true);
        init_compass();

    } else if (!strcmp_P(argv[1].str, PSTR("off"))) {
        clear_offsets();
        g.compass_enabled.set_and_save(false);

    }else{
        Serial.printf_P(PSTR("\nOp:[on,off]\n"));
        report_compass();
        return 0;
    }

    g.compass_enabled.save();
    report_compass();
    return 0;
}

static int8_t
setup_batt_monitor(uint8_t argc, const Menu::arg *argv)
{
    if (!strcmp_P(argv[1].str, PSTR("off"))) {
        g.battery_monitoring.set_and_save(0);

    } else if(argv[1].i > 0 && argv[1].i <= 4) {
        g.battery_monitoring.set_and_save(argv[1].i);

    } else {
        Serial.printf_P(PSTR("\nOp: off, 3-4"));
    }

    report_batt_monitor();
    return 0;
}

static int8_t
setup_sonar(uint8_t argc, const Menu::arg *argv)
{
    if (!strcmp_P(argv[1].str, PSTR("on"))) {
        g.sonar_enabled.set_and_save(true);

    } else if (!strcmp_P(argv[1].str, PSTR("off"))) {
        g.sonar_enabled.set_and_save(false);

    } else if (argc > 1 && (argv[1].i >= 0 && argv[1].i <= 3)) {
        g.sonar_enabled.set_and_save(true);      // if you set the sonar type, surely you want it on
        g.sonar_type.set_and_save(argv[1].i);

    }else{
        Serial.printf_P(PSTR("\nOp:[on, off, 0-3]\n"));
        report_sonar();
        return 0;
    }

    report_sonar();
    return 0;
}

 #if FRAME_CONFIG == HELI_FRAME

// Perform heli setup.
// Called by the setup menu 'radio' command.
static int8_t
setup_heli(uint8_t argc, const Menu::arg *argv)
{

    uint8_t active_servo = 0;
    int16_t value = 0;
    int16_t temp;
    int16_t state = 0;       // 0 = set rev+pos, 1 = capture min/max
    int16_t max_roll=0, max_pitch=0, min_collective=0, max_collective=0, min_tail=0, max_tail=0;

    // initialise swash plate
    motors.init_swash();

    // source swash plate movements directly from radio
    motors.servo_manual = true;

    // display initial settings
    report_heli();

    // display help
    Serial.printf_P(PSTR("Instructions:"));
    print_divider();
    Serial.printf_P(PSTR("\td\t\tdisplay settings\n"));
    Serial.printf_P(PSTR("\t1~4\t\tselect servo\n"));
    Serial.printf_P(PSTR("\ta or z\t\tmove mid up/down\n"));
    Serial.printf_P(PSTR("\tc\t\tset coll when blade pitch zero\n"));
    Serial.printf_P(PSTR("\tm\t\tset roll, pitch, coll min/max\n"));
    Serial.printf_P(PSTR("\tp<angle>\tset pos (i.e. p0 = front, p90 = right)\n"));
    Serial.printf_P(PSTR("\tr\t\treverse servo\n"));
    Serial.printf_P(PSTR("\tu a|d\t\tupdate rate (a=analog servo, d=digital)\n"));
    Serial.printf_P(PSTR("\tt<angle>\tset trim (-500 ~ 500)\n"));
    Serial.printf_P(PSTR("\tx\t\texit & save\n"));

    // start capturing
    while( value != 'x' ) {

        // read radio although we don't use it yet
        read_radio();

        // allow swash plate to move
        motors.output_armed();

        // record min/max
        if( state == 1 ) {
            if( abs(g.rc_1.control_in) > max_roll )
                max_roll = abs(g.rc_1.control_in);
            if( abs(g.rc_2.control_in) > max_pitch )
                max_pitch = abs(g.rc_2.control_in);
            if( g.rc_3.radio_out < min_collective )
                min_collective = g.rc_3.radio_out;
            if( g.rc_3.radio_out > max_collective )
                max_collective = g.rc_3.radio_out;
            min_tail = min(g.rc_4.radio_out, min_tail);
            max_tail = max(g.rc_4.radio_out, max_tail);
        }

        if( Serial.available() ) {
            value = Serial.read();

            // process the user's input
            switch( value ) {
            case '1':
                active_servo = CH_1;
                break;
            case '2':
                active_servo = CH_2;
                break;
            case '3':
                active_servo = CH_3;
                break;
            case '4':
                active_servo = CH_4;
                break;
            case 'a':
            case 'A':
                heli_get_servo(active_servo)->radio_trim += 10;
                break;
            case 'c':
            case 'C':
                if( g.rc_3.radio_out >= 900 && g.rc_3.radio_out <= 2100 ) {
                    motors.collective_mid = g.rc_3.radio_out;
                    Serial.printf_P(PSTR("Collective when blade pitch at zero: %d\n"),(int)motors.collective_mid);
                }
                break;
            case 'd':
            case 'D':
                // display settings
                report_heli();
                break;
            case 'm':
            case 'M':
                if( state == 0 ) {
                    state = 1;                          // switch to capture min/max mode
                    Serial.printf_P(PSTR("Move coll, roll, pitch and tail to extremes, press 'm' when done\n"));

                    // reset servo ranges
                    motors.roll_max = motors.pitch_max = 4500;
                    motors.collective_min = 1000;
                    motors.collective_max = 2000;
                    motors._servo_4->radio_min = 1000;
                    motors._servo_4->radio_max = 2000;

                    // set sensible values in temp variables
                    max_roll = abs(g.rc_1.control_in);
                    max_pitch = abs(g.rc_2.control_in);
                    min_collective = 2000;
                    max_collective = 1000;
                    min_tail = max_tail = abs(g.rc_4.radio_out);
                }else{
                    state = 0;                          // switch back to normal mode
                    // double check values aren't totally terrible
                    if( max_roll <= 1000 || max_pitch <= 1000 || (max_collective - min_collective < 200) || (max_tail - min_tail < 200) || min_tail < 1000 || max_tail > 2000 )
                        Serial.printf_P(PSTR("Invalid min/max captured roll:%d,  pitch:%d,  collective min: %d max: %d,  tail min:%d max:%d\n"),max_roll,max_pitch,min_collective,max_collective,min_tail,max_tail);
                    else{
                        motors.roll_max = max_roll;
                        motors.pitch_max = max_pitch;
                        motors.collective_min = min_collective;
                        motors.collective_max = max_collective;
                        motors._servo_4->radio_min = min_tail;
                        motors._servo_4->radio_max = max_tail;

                        // reinitialise swash
                        motors.init_swash();

                        // display settings
                        report_heli();
                    }
                }
                break;
            case 'p':
            case 'P':
                temp = read_num_from_serial();
                if( temp >= -360 && temp <= 360 ) {
                    if( active_servo == CH_1 )
                        motors.servo1_pos = temp;
                    if( active_servo == CH_2 )
                        motors.servo2_pos = temp;
                    if( active_servo == CH_3 )
                        motors.servo3_pos = temp;
                    motors.init_swash();
                    Serial.printf_P(PSTR("Servo %d\t\tpos:%d\n"),active_servo+1, temp);
                }
                break;
            case 'r':
            case 'R':
                heli_get_servo(active_servo)->set_reverse(!heli_get_servo(active_servo)->get_reverse());
                break;
            case 't':
            case 'T':
                temp = read_num_from_serial();
                if( temp > 1000 )
                    temp -= 1500;
                if( temp > -500 && temp < 500 ) {
                    heli_get_servo(active_servo)->radio_trim = 1500 + temp;
                    motors.init_swash();
                    Serial.printf_P(PSTR("Servo %d\t\ttrim:%d\n"),active_servo+1, 1500 + temp);
                }
                break;
            case 'u':
            case 'U':
                temp = 0;
                // delay up to 2 seconds for servo type from user
                while( !Serial.available() && temp < 20 ) {
                    temp++;
                    delay(100);
                }
                if( Serial.available() ) {
                    value = Serial.read();
                    if( value == 'a' || value == 'A' ) {
                        g.rc_speed.set_and_save(AP_MOTORS_HELI_SPEED_ANALOG_SERVOS);
                        //motors._speed_hz = AP_MOTORS_HELI_SPEED_ANALOG_SERVOS;  // need to force this update to take effect immediately
                        Serial.printf_P(PSTR("Analog Servo %dhz\n"),(int)g.rc_speed);
                    }
                    if( value == 'd' || value == 'D' ) {
                        g.rc_speed.set_and_save(AP_MOTORS_HELI_SPEED_ANALOG_SERVOS);
                        //motors._speed_hz = AP_MOTORS_HELI_SPEED_ANALOG_SERVOS;  // need to force this update to take effect immediately
                        Serial.printf_P(PSTR("Digital Servo %dhz\n"),(int)g.rc_speed);
                    }
                }
                break;
            case 'z':
            case 'Z':
                heli_get_servo(active_servo)->radio_trim -= 10;
                break;
            }
        }

        delay(20);
    }

    // display final settings
    report_heli();

    // save to eeprom
    motors._servo_1->save_eeprom();
    motors._servo_2->save_eeprom();
    motors._servo_3->save_eeprom();
    motors._servo_4->save_eeprom();
    motors.servo1_pos.save();
    motors.servo2_pos.save();
    motors.servo3_pos.save();
    motors.roll_max.save();
    motors.pitch_max.save();
    motors.collective_min.save();
    motors.collective_max.save();
    motors.collective_mid.save();

    // return swash plate movements to attitude controller
    motors.servo_manual = false;

    return(0);
}

// setup for external tail gyro (for heli only)
static int8_t
setup_gyro(uint8_t argc, const Menu::arg *argv)
{
    if (!strcmp_P(argv[1].str, PSTR("on"))) {
        motors.ext_gyro_enabled.set_and_save(true);

        // optionally capture the gain
        if( argc >= 2 && argv[2].i >= 1000 && argv[2].i <= 2000 ) {
            motors.ext_gyro_gain = argv[2].i;
            motors.ext_gyro_gain.save();
        }

    } else if (!strcmp_P(argv[1].str, PSTR("off"))) {
        motors.ext_gyro_enabled.set_and_save(false);

        // capture gain if user simply provides a number
    } else if( argv[1].i >= 1000 && argv[1].i <= 2000 ) {
        motors.ext_gyro_enabled.set_and_save(true);
        motors.ext_gyro_gain = argv[1].i;
        motors.ext_gyro_gain.save();

    }else{
        Serial.printf_P(PSTR("\nOp:[on, off] gain\n"));
    }

    report_gyro();
    return 0;
}

 #endif // FRAME_CONFIG == HELI

static void clear_offsets()
{
    Vector3f _offsets(0.0,0.0,0.0);
    compass.set_offsets(_offsets);
    compass.save_offsets();
}

static int8_t
setup_optflow(uint8_t argc, const Menu::arg *argv)
{
 #ifdef OPTFLOW_ENABLED
    if (!strcmp_P(argv[1].str, PSTR("on"))) {
        g.optflow_enabled = true;
        init_optflow();

    } else if (!strcmp_P(argv[1].str, PSTR("off"))) {
        g.optflow_enabled = false;

    }else{
        Serial.printf_P(PSTR("\nOp:[on, off]\n"));
        report_optflow();
        return 0;
    }

    g.optflow_enabled.save();
    report_optflow();
 #endif
    return 0;
}



/***************************************************************************/
// CLI reports
/***************************************************************************/

static void report_batt_monitor()
{
    Serial.printf_P(PSTR("\nBatt Mon:\n"));
    print_divider();
    if(g.battery_monitoring == 0) print_enabled(false);
    if(g.battery_monitoring == 3) Serial.printf_P(PSTR("volts"));
    if(g.battery_monitoring == 4) Serial.printf_P(PSTR("volts and cur"));
    print_blanks(2);
}

static void report_wp(byte index = 255)
{
    if(index == 255) {
        for(byte i = 0; i < g.command_total; i++) {
            struct Location temp = get_cmd_with_index(i);
            print_wp(&temp, i);
        }
    }else{
        struct Location temp = get_cmd_with_index(index);
        print_wp(&temp, index);
    }
}

static void report_sonar()
{
    Serial.printf_P(PSTR("Sonar\n"));
    print_divider();
    print_enabled(g.sonar_enabled.get());
    Serial.printf_P(PSTR("Type: %d (0=XL, 1=LV, 2=XLL, 3=HRLV)"), (int)g.sonar_type);
    print_blanks(2);
}

static void report_frame()
{
    Serial.printf_P(PSTR("Frame\n"));
    print_divider();

 #if FRAME_CONFIG == QUAD_FRAME
    Serial.printf_P(PSTR("Quad frame\n"));
 #elif FRAME_CONFIG == TRI_FRAME
    Serial.printf_P(PSTR("TRI frame\n"));
 #elif FRAME_CONFIG == HEXA_FRAME
    Serial.printf_P(PSTR("Hexa frame\n"));
 #elif FRAME_CONFIG == Y6_FRAME
    Serial.printf_P(PSTR("Y6 frame\n"));
 #elif FRAME_CONFIG == OCTA_FRAME
    Serial.printf_P(PSTR("Octa frame\n"));
 #elif FRAME_CONFIG == HELI_FRAME
    Serial.printf_P(PSTR("Heli frame\n"));
 #endif

 #if FRAME_CONFIG != HELI_FRAME
    if(g.frame_orientation == X_FRAME)
        Serial.printf_P(PSTR("X mode\n"));
    else if(g.frame_orientation == PLUS_FRAME)
        Serial.printf_P(PSTR("+ mode\n"));
    else if(g.frame_orientation == V_FRAME)
        Serial.printf_P(PSTR("V mode\n"));
 #endif

    print_blanks(2);
}

static void report_radio()
{
    Serial.printf_P(PSTR("Radio\n"));
    print_divider();
    // radio
    print_radio_values();
    print_blanks(2);
}

static void report_imu()
{
    Serial.printf_P(PSTR("IMU\n"));
    print_divider();

    print_gyro_offsets();
    print_accel_offsets();
    print_blanks(2);
}

static void report_compass()
{
    Serial.printf_P(PSTR("Compass\n"));
    print_divider();

    print_enabled(g.compass_enabled);

    // mag declination
    Serial.printf_P(PSTR("Mag Dec: %4.4f\n"),
                    degrees(compass.get_declination()));

    Vector3f offsets = compass.get_offsets();

    // mag offsets
    Serial.printf_P(PSTR("Mag off: %4.4f, %4.4f, %4.4f"),
                    offsets.x,
                    offsets.y,
                    offsets.z);
    print_blanks(2);
}

static void report_flight_modes()
{
    Serial.printf_P(PSTR("Flight modes\n"));
    print_divider();

    for(int16_t i = 0; i < 6; i++ ) {
        print_switch(i, flight_modes[i], (g.simple_modes & (1<<i)));
    }
    print_blanks(2);
}

void report_optflow()
{
 #ifdef OPTFLOW_ENABLED
    Serial.printf_P(PSTR("OptFlow\n"));
    print_divider();

    print_enabled(g.optflow_enabled);

    // field of view
    //Serial.printf_P(PSTR("FOV: %4.0f\n"),
    //						degrees(g.optflow_fov));

    print_blanks(2);
 #endif
}

 #if FRAME_CONFIG == HELI_FRAME
static void report_heli()
{
    Serial.printf_P(PSTR("Heli\n"));
    print_divider();

    // main servo settings
    Serial.printf_P(PSTR("Servo \tpos \tmin \tmax \trev\n"));
    Serial.printf_P(PSTR("1:\t%d \t%d \t%d \t%d\n"),(int)motors.servo1_pos, (int)motors._servo_1->radio_min, (int)motors._servo_1->radio_max, (int)motors._servo_1->get_reverse());
    Serial.printf_P(PSTR("2:\t%d \t%d \t%d \t%d\n"),(int)motors.servo2_pos, (int)motors._servo_2->radio_min, (int)motors._servo_2->radio_max, (int)motors._servo_2->get_reverse());
    Serial.printf_P(PSTR("3:\t%d \t%d \t%d \t%d\n"),(int)motors.servo3_pos, (int)motors._servo_3->radio_min, (int)motors._servo_3->radio_max, (int)motors._servo_3->get_reverse());
    Serial.printf_P(PSTR("tail:\t\t%d \t%d \t%d\n"), (int)motors._servo_4->radio_min, (int)motors._servo_4->radio_max, (int)motors._servo_4->get_reverse());

    Serial.printf_P(PSTR("roll max: \t%d\n"), (int)motors.roll_max);
    Serial.printf_P(PSTR("pitch max: \t%d\n"), (int)motors.pitch_max);
    Serial.printf_P(PSTR("coll min:\t%d\t mid:%d\t max:%d\n"),(int)motors.collective_min, (int)motors.collective_mid, (int)motors.collective_max);

    // calculate and print servo rate
    Serial.printf_P(PSTR("servo rate:\t%d hz\n"),(int)g.rc_speed);

    print_blanks(2);
}

static void report_gyro()
{

    Serial.printf_P(PSTR("Gyro:\n"));
    print_divider();

    print_enabled( motors.ext_gyro_enabled );
    if( motors.ext_gyro_enabled )
        Serial.printf_P(PSTR("gain: %d"),(int)motors.ext_gyro_gain);

    print_blanks(2);
}

 #endif // FRAME_CONFIG == HELI_FRAME

/***************************************************************************/
// CLI utilities
/***************************************************************************/

/*static void
 *  print_PID(PI * pid)
 *  {
 *       Serial.printf_P(PSTR("P: %4.2f, I:%4.2f, IMAX:%ld\n"),
 *                                               pid->kP(),
 *                                               pid->kI(),
 *                                               (long)pid->imax());
 *  }
 */

static void
print_radio_values()
{
    Serial.printf_P(PSTR("CH1: %d | %d\n"), (int)g.rc_1.radio_min, (int)g.rc_1.radio_max);
    Serial.printf_P(PSTR("CH2: %d | %d\n"), (int)g.rc_2.radio_min, (int)g.rc_2.radio_max);
    Serial.printf_P(PSTR("CH3: %d | %d\n"), (int)g.rc_3.radio_min, (int)g.rc_3.radio_max);
    Serial.printf_P(PSTR("CH4: %d | %d\n"), (int)g.rc_4.radio_min, (int)g.rc_4.radio_max);
    Serial.printf_P(PSTR("CH5: %d | %d\n"), (int)g.rc_5.radio_min, (int)g.rc_5.radio_max);
    Serial.printf_P(PSTR("CH6: %d | %d\n"), (int)g.rc_6.radio_min, (int)g.rc_6.radio_max);
    Serial.printf_P(PSTR("CH7: %d | %d\n"), (int)g.rc_7.radio_min, (int)g.rc_7.radio_max);
    //Serial.printf_P(PSTR("CH8: %d | %d\n"), (int)g.rc_8.radio_min, (int)g.rc_8.radio_max);
}

static void
print_switch(byte p, byte m, bool b)
{
    Serial.printf_P(PSTR("Pos %d:\t"),p);
    print_flight_mode(m);
    Serial.printf_P(PSTR(",\t\tSimple: "));
    if(b)
        Serial.printf_P(PSTR("ON\n"));
    else
        Serial.printf_P(PSTR("OFF\n"));
}

static void
print_done()
{
    Serial.printf_P(PSTR("\nSaved\n"));
}


static void zero_eeprom(void)
{
    byte b = 0;

    Serial.printf_P(PSTR("\nErasing EEPROM\n"));

    for (int16_t i = 0; i < EEPROM_MAX_ADDR; i++) {
        eeprom_write_byte((uint8_t *) i, b);
    }

    Serial.printf_P(PSTR("done\n"));
}

static void
print_accel_offsets(void)
{
    Serial.printf_P(PSTR("A_off: %4.2f, %4.2f, %4.2f\n"),
                    (float)imu.ax(),                                    // Pitch
                    (float)imu.ay(),                                    // Roll
                    (float)imu.az());                                   // YAW
}

static void
print_gyro_offsets(void)
{
    Serial.printf_P(PSTR("G_off: %4.2f, %4.2f, %4.2f\n"),
                    (float)imu.gx(),
                    (float)imu.gy(),
                    (float)imu.gz());
}

 #if FRAME_CONFIG == HELI_FRAME

static RC_Channel *
heli_get_servo(int16_t servo_num){
    if( servo_num == CH_1 )
        return motors._servo_1;
    if( servo_num == CH_2 )
        return motors._servo_2;
    if( servo_num == CH_3 )
        return motors._servo_3;
    if( servo_num == CH_4 )
        return motors._servo_4;
    return NULL;
}

// Used to read integer values from the serial port
static int16_t read_num_from_serial() {
    byte index = 0;
    byte timeout = 0;
    char data[5] = "";

    do {
        if (Serial.available() == 0) {
            delay(10);
            timeout++;
        }else{
            data[index] = Serial.read();
            timeout = 0;
            index++;
        }
    } while (timeout < 5 && index < 5);

    return atoi(data);
}
 #endif

#endif // CLI_ENABLED

static void
print_blanks(int16_t num)
{
    while(num > 0) {
        num--;
        Serial.println("");
    }
}


static bool
wait_for_yes()
{
    int c;
    Serial.flush();
    Serial.printf_P(PSTR("Y to save\n"));

    do {
        c = Serial.read();
    } while (-1 == c);

    if (('y' == c) || ('Y' == c))
        return true;
    else
        return false;
}

static void
print_divider(void)
{
    for (int i = 0; i < 40; i++) {
        Serial.print_P(PSTR("-"));
    }
    Serial.println();
}

static void print_enabled(boolean b)
{
    if(b)
        Serial.print_P(PSTR("en"));
    else
        Serial.print_P(PSTR("dis"));
    Serial.print_P(PSTR("abled\n"));
}


static void
init_esc()
{
    motors.enable();
    motors.armed(true);
    while(1) {
        read_radio();
        delay(100);
        dancing_light();
        motors.throttle_pass_through();
    }
}

static void print_wp(struct Location *cmd, byte index)
{
   	//float t1 = (float)cmd->lat / t7;
    //float t2 = (float)cmd->lng / t7;

    Serial.printf_P(PSTR("cmd#: %d | %d, %d, %d, %ld, %ld, %ld\n"),
                    index,
                    cmd->id,
                    cmd->options,
                    cmd->p1,
                    cmd->alt,
                    cmd->lat,
                    cmd->lng);

	/*
    Serial.printf_P(PSTR("cmd#: %d id:%d op:%d p1:%d p2:%ld p3:%4.7f p4:%4.7f \n"),
                    (int)index,
                    (int)cmd->id,
                    (int)cmd->options,
                    (int)cmd->p1,
                    (long)cmd->alt,
                    t1,
                    t2);
	*/
}

static void report_version()
{
    Serial.printf_P(PSTR("FW Ver: %d\n"),(int)g.k_format_version);
    print_divider();
    print_blanks(2);
}


static void report_tuning()
{
    Serial.printf_P(PSTR("\nTUNE:\n"));
    print_divider();
    if (g.radio_tuning == 0) {
        print_enabled(g.radio_tuning.get());
    }else{
        float low  = (float)g.radio_tuning_low.get() / 1000;
        float high = (float)g.radio_tuning_high.get() / 1000;
        Serial.printf_P(PSTR(" %d, Low:%1.4f, High:%1.4f\n"),(int)g.radio_tuning.get(), low, high);
    }
    print_blanks(2);
}
// -*- tab-width: 4; Mode: C++; c-basic-offset: 4; indent-tabs-mode: nil -*-
/*****************************************************************************
*   The init_ardupilot function processes everything we need for an in - air restart
*        We will determine later if we are actually on the ground and process a
*        ground start in that case.
*
*****************************************************************************/

#if CLI_ENABLED == ENABLED
// Functions called from the top-level menu
static int8_t   process_logs(uint8_t argc, const Menu::arg *argv);      // in Log.pde
static int8_t   setup_mode(uint8_t argc, const Menu::arg *argv);        // in setup.pde
static int8_t   test_mode(uint8_t argc, const Menu::arg *argv);         // in test.cpp
static int8_t   planner_mode(uint8_t argc, const Menu::arg *argv);      // in planner.pde

// This is the help function
// PSTR is an AVR macro to read strings from flash memory
// printf_P is a version of print_f that reads from flash memory
static int8_t   main_menu_help(uint8_t argc, const Menu::arg *argv)
{
    Serial.printf_P(PSTR("Commands:\n"
                         "  logs\n"
                         "  setup\n"
                         "  test\n"
                         "  planner\n"
                         "\n"
                         "Move the slide switch and reset to FLY.\n"
                         "\n"));
    return(0);
}

// Command/function table for the top-level menu.
const struct Menu::command main_menu_commands[] PROGMEM = {
//   command		function called
//   =======        ===============
    {"logs",                process_logs},
    {"setup",               setup_mode},
    {"test",                test_mode},
    {"help",                main_menu_help},
    {"planner",             planner_mode}
};

// Create the top-level menu object.
MENU(main_menu, THISFIRMWARE, main_menu_commands);

// the user wants the CLI. It never exits
static void run_cli(void)
{
    while (1) {
        main_menu.run();
    }
}

#endif // CLI_ENABLED

static void init_ardupilot()
{
#if USB_MUX_PIN > 0
    // on the APM2 board we have a mux thet switches UART0 between
    // USB and the board header. If the right ArduPPM firmware is
    // installed we can detect if USB is connected using the
    // USB_MUX_PIN
    pinMode(USB_MUX_PIN, INPUT);

    usb_connected = !digitalRead(USB_MUX_PIN);
    if (!usb_connected) {
        // USB is not connected, this means UART0 may be a Xbee, with
        // its darned bricking problem. We can't write to it for at
        // least one second after powering up. Simplest solution for
        // now is to delay for 1 second. Something more elegant may be
        // added later
        delay(1000);
    }
#endif

    // Console serial port
    //
    // The console port buffers are defined to be sufficiently large to support
    // the MAVLink protocol efficiently
    //
    Serial.begin(SERIAL0_BAUD, 128, 256);

    // GPS serial port.
    //
#if GPS_PROTOCOL != GPS_PROTOCOL_IMU
    // standard gps running. Note that we need a 256 byte buffer for some
    // GPS types (eg. UBLOX)
    Serial1.begin(38400, 256, 16);
#endif

    Serial.printf_P(PSTR("\n\nInit " THISFIRMWARE
                         "\n\nFree RAM: %u\n"),
                    memcheck_available_memory());

    //
    // Initialize Wire and SPI libraries
    //
#ifndef DESKTOP_BUILD
    I2c.begin();
    I2c.timeOut(5);
    // initially set a fast I2c speed, and drop it on first failures
    I2c.setSpeed(true);
#endif
    SPI.begin();
    SPI.setClockDivider(SPI_CLOCK_DIV16); // 1MHZ SPI rate

#if CONFIG_APM_HARDWARE == APM_HARDWARE_APM2
    SPI3.begin();
    SPI3.setSpeed(SPI3_SPEED_2MHZ);
#endif

    //
    // Initialize the isr_registry.
    //
    isr_registry.init();

    //
    // Report firmware version code expect on console (check of actual EEPROM format version is done in load_parameters function)
    //
    report_version();

    // setup IO pins
    pinMode(A_LED_PIN, OUTPUT);                                 // GPS status LED
    digitalWrite(A_LED_PIN, LED_OFF);

    pinMode(B_LED_PIN, OUTPUT);                         // GPS status LED
    digitalWrite(B_LED_PIN, LED_OFF);

    pinMode(C_LED_PIN, OUTPUT);                         // GPS status LED
    digitalWrite(C_LED_PIN, LED_OFF);

#if SLIDE_SWITCH_PIN > 0
    pinMode(SLIDE_SWITCH_PIN, INPUT);           // To enter interactive mode
#endif
#if CONFIG_PUSHBUTTON == ENABLED
    pinMode(PUSHBUTTON_PIN, INPUT);                     // unused
#endif
#if CONFIG_RELAY == ENABLED
    DDRL |= B00000100;                                                  // Set Port L, pin 2 to output for the relay
#endif

#if COPTER_LEDS == ENABLED
    pinMode(COPTER_LED_1, OUTPUT);              //Motor LED
    pinMode(COPTER_LED_2, OUTPUT);              //Motor LED
    pinMode(COPTER_LED_3, OUTPUT);              //Motor LED
    pinMode(COPTER_LED_4, OUTPUT);              //Motor LED
    pinMode(COPTER_LED_5, OUTPUT);              //Motor or Aux LED
    pinMode(COPTER_LED_6, OUTPUT);              //Motor or Aux LED
    pinMode(COPTER_LED_7, OUTPUT);              //Motor or GPS LED
    pinMode(COPTER_LED_8, OUTPUT);              //Motor or GPS LED

    if ( !bitRead(g.copter_leds_mode, 3) ) {
        piezo_beep();
    }

#endif


    // load parameters from EEPROM
    load_parameters();

    // init the GCS
    gcs0.init(&Serial);

#if USB_MUX_PIN > 0
    if (!usb_connected) {
        // we are not connected via USB, re-init UART0 with right
        // baud rate
        Serial.begin(map_baudrate(g.serial3_baud, SERIAL3_BAUD));
    }
#else
    // we have a 2nd serial port for telemetry
    Serial3.begin(map_baudrate(g.serial3_baud, SERIAL3_BAUD), 128, 256);
    gcs3.init(&Serial3);
#endif

    // identify ourselves correctly with the ground station
    mavlink_system.sysid = g.sysid_this_mav;
    mavlink_system.type = 2; //MAV_QUADROTOR;

#if LOGGING_ENABLED == ENABLED
    DataFlash.Init();
    if (!DataFlash.CardInserted()) {
        gcs_send_text_P(SEVERITY_LOW, PSTR("No dataflash inserted"));
        g.log_bitmask.set(0);
    } else if (DataFlash.NeedErase()) {
        gcs_send_text_P(SEVERITY_LOW, PSTR("ERASING LOGS"));
        do_erase_logs();
    }
    if (g.log_bitmask != 0) {
        DataFlash.start_new_log();
    }
#endif

#ifdef RADIO_OVERRIDE_DEFAULTS
    {
        int16_t rc_override[8] = RADIO_OVERRIDE_DEFAULTS;
        APM_RC.setHIL(rc_override);
    }
#endif

#if FRAME_CONFIG == HELI_FRAME
    motors.servo_manual = false;
    motors.init_swash();              // heli initialisation
#endif

    RC_Channel::set_apm_rc(&APM_RC);
    init_rc_in();               // sets up rc channels from radio
    init_rc_out();              // sets up the timer libs

    timer_scheduler.init( &isr_registry );

    /*
     *  setup the 'main loop is dead' check. Note that this relies on
     *  the RC library being initialised.
     */
    timer_scheduler.set_failsafe(failsafe_check);

    // initialise the analog port reader
    AP_AnalogSource_Arduino::init_timer(&timer_scheduler);

#if HIL_MODE != HIL_MODE_ATTITUDE
 #if CONFIG_ADC == ENABLED
    // begin filtering the ADC Gyros
    adc.Init(&timer_scheduler);           // APM ADC library initialization
 #endif // CONFIG_ADC

    barometer.init(&timer_scheduler);

#endif // HIL_MODE

    // Do GPS init
    g_gps = &g_gps_driver;
    // GPS Initialization
    g_gps->init(GPS::GPS_ENGINE_AIRBORNE_1G);

    if(g.compass_enabled)
        init_compass();

    // init the optical flow sensor
    if(g.optflow_enabled) {
        init_optflow();
    }


// agmatthews USERHOOKS
#ifdef USERHOOK_INIT
    USERHOOK_INIT
#endif

#if CLI_ENABLED == ENABLED && CLI_SLIDER_ENABLED == ENABLED
    // If the switch is in 'menu' mode, run the main menu.
    //
    // Since we can't be sure that the setup or test mode won't leave
    // the system in an odd state, we don't let the user exit the top
    // menu; they must reset in order to fly.
    //
    if (check_startup_for_CLI()) {
        digitalWrite(A_LED_PIN, LED_ON);                        // turn on setup-mode LED
        Serial.printf_P(PSTR("\nCLI:\n\n"));
        run_cli();
    }
#else
    Serial.printf_P(PSTR("\nPress ENTER 3 times for CLI\n\n"));
#endif // CLI_ENABLED

#if HIL_MODE != HIL_MODE_ATTITUDE
    // read Baro pressure at ground
    //-----------------------------
    init_barometer();
#endif

    // initialise sonar
#if CONFIG_SONAR == ENABLED
    init_sonar();
#endif

    // initialize commands
    // -------------------
    init_commands();

    // set the correct flight mode
    // ---------------------------
    reset_control_switch();

    // init the Z damopener
    // --------------------
#if ACCEL_ALT_HOLD != 0
    init_z_damper();
#endif


    startup_ground();

    // now that initialisation of IMU has occurred increase SPI to 2MHz
    SPI.setClockDivider(SPI_CLOCK_DIV8); // 2MHZ SPI rate

#if LOGGING_ENABLED == ENABLED
    Log_Write_Startup();
    Log_Write_Data(10, (float)g.pi_stabilize_roll.kP());
    Log_Write_Data(11, (float)g.pi_stabilize_roll.kI());

    Log_Write_Data(12, (float)g.pid_rate_roll.kP());
    Log_Write_Data(13, (float)g.pid_rate_roll.kI());
    Log_Write_Data(14, (float)g.pid_rate_roll.kD());
    Log_Write_Data(15, (float)g.stabilize_d.get());

    Log_Write_Data(16, (float)g.pi_loiter_lon.kP());
    Log_Write_Data(17, (float)g.pi_loiter_lon.kI());

    Log_Write_Data(18, (float)g.pid_nav_lon.kP());
    Log_Write_Data(19, (float)g.pid_nav_lon.kI());
    Log_Write_Data(20, (float)g.pid_nav_lon.kD());

    Log_Write_Data(21, (int32_t)g.auto_slew_rate.get());

    Log_Write_Data(22, (float)g.pid_loiter_rate_lon.kP());
    Log_Write_Data(23, (float)g.pid_loiter_rate_lon.kI());
    Log_Write_Data(24, (float)g.pid_loiter_rate_lon.kD());
#endif


///////////////////////////////////////////////////////////////////////////////
// Experimental AP_Limits library - set constraints, limits, fences, minima, maxima on various parameters
////////////////////////////////////////////////////////////////////////////////
#ifdef AP_LIMITS

    // AP_Limits modules are stored as a _linked list_. That allows us to define an infinite number of modules
    // and also to allocate no space until we actually need to.

    // The linked list looks (logically) like this
    //   [limits module] -> [first limit module] -> [second limit module] -> [third limit module] -> NULL


    // The details of the linked list are handled by the methods
    // modules_first, modules_current, modules_next, modules_last, modules_add
    // in limits

    limits.modules_add(&gpslock_limit);
    limits.modules_add(&geofence_limit);
    limits.modules_add(&altitude_limit);


    if (limits.debug())  {
        gcs_send_text_P(SEVERITY_LOW,PSTR("Limits Modules Loaded"));

        AP_Limit_Module *m = limits.modules_first();
        while (m) {
            gcs_send_text_P(SEVERITY_LOW, get_module_name(m->get_module_id()));
            m = limits.modules_next();
        }
    }

#endif

    Serial.print_P(PSTR("\nReady to FLY "));
}


//********************************************************************************
//This function does all the calibrations, etc. that we need during a ground start
//********************************************************************************
static void startup_ground(void)
{
    gcs_send_text_P(SEVERITY_LOW,PSTR("GROUND START"));

    // Warm up and read Gyro offsets
    // -----------------------------
    imu.init(IMU::COLD_START, mavlink_delay, flash_leds, &timer_scheduler);
 #if CLI_ENABLED == ENABLED
    report_imu();
 #endif

    // initialise ahrs (may push imu calibration into the mpu6000 if using that device).
    ahrs.init(&timer_scheduler);

    // setup fast AHRS gains to get right attitude
    ahrs.set_fast_gains(true);

#if SECONDARY_DMP_ENABLED == ENABLED
    ahrs2.init(&timer_scheduler);
    ahrs2.set_as_secondary(true);
    ahrs2.set_fast_gains(true);
#endif

    // reset the leds
    // ---------------------------
    clear_leds();

    // when we re-calibrate the gyros,
    // all previous I values are invalid
    reset_I_all();
}

static void set_mode(byte mode)
{
    // if we don't have GPS lock
    if(home_is_set == false) {
        // THOR
        // We don't care about Home if we don't have lock yet in Toy mode
        if(mode == TOY_A || mode == TOY_M || mode == OF_LOITER) {
            // nothing
        }else if (mode > ALT_HOLD) {
            mode = STABILIZE;
        }
    }

    // nothing but OF_LOITER for OptFlow only
    if (g.optflow_enabled && g_gps->status() != GPS::GPS_OK) {
        if (mode > ALT_HOLD && mode != OF_LOITER)
            mode = STABILIZE;
    }

    control_mode            = mode;
    control_mode            = constrain(control_mode, 0, NUM_MODES - 1);

    // used to stop fly_aways
    // set to false if we have low throttle
    motors.auto_armed(g.rc_3.control_in > 0);

    // clearing value used in interactive alt hold
    reset_throttle_counter = 0;

    // clearing value used to force the copter down in landing mode
    landing_boost = 0;

    // do we want to come to a stop or pass a WP?
    slow_wp = false;

    // do not auto_land if we are leaving RTL
    loiter_timer = 0;

    // if we change modes, we must clear landed flag
    land_complete   = false;

    // have we acheived the proper altitude before RTL is enabled
    rtl_reached_alt = false;
    // debug to Serial terminal
    //Serial.println(flight_mode_strings[control_mode]);

    // report the GPS and Motor arming status
    led_mode = NORMAL_LEDS;

    switch(control_mode)
    {
    case ACRO:
        yaw_mode                = YAW_ACRO;
        roll_pitch_mode = ROLL_PITCH_ACRO;
        throttle_mode   = THROTTLE_MANUAL;
        // reset acro axis targets to current attitude
        if( g.axis_enabled ) {
            roll_axis = ahrs.roll_sensor;
            pitch_axis = ahrs.pitch_sensor;
            nav_yaw = ahrs.yaw_sensor;
        }
        break;

    case STABILIZE:
        yaw_mode                = YAW_HOLD;
        roll_pitch_mode = ROLL_PITCH_STABLE;
        throttle_mode   = THROTTLE_MANUAL;
        break;

    case ALT_HOLD:
        yaw_mode                = ALT_HOLD_YAW;
        roll_pitch_mode = ALT_HOLD_RP;
        throttle_mode   = ALT_HOLD_THR;

        force_new_altitude(max(current_loc.alt, 100));
        break;

    case AUTO:
        yaw_mode                = AUTO_YAW;
        roll_pitch_mode = AUTO_RP;
        throttle_mode   = AUTO_THR;

        // loads the commands from where we left off
        init_commands();
        break;

    case CIRCLE:
        yaw_mode                = CIRCLE_YAW;
        roll_pitch_mode = CIRCLE_RP;
        throttle_mode   = CIRCLE_THR;
        set_next_WP(&current_loc);
        circle_WP               = next_WP;
        circle_angle    = 0;
        break;

    case LOITER:
        yaw_mode                = LOITER_YAW;
        roll_pitch_mode = LOITER_RP;
        throttle_mode   = LOITER_THR;
        set_next_WP(&current_loc);
        break;

    case POSITION:
        yaw_mode                = YAW_HOLD;
        roll_pitch_mode = ROLL_PITCH_AUTO;
        throttle_mode   = THROTTLE_MANUAL;
        set_next_WP(&current_loc);
        break;

    case GUIDED:
        yaw_mode                = YAW_AUTO;
        roll_pitch_mode = ROLL_PITCH_AUTO;
        throttle_mode   = THROTTLE_AUTO;
        next_WP                 = current_loc;
        set_next_WP(&guided_WP);
        break;

    case LAND:
        yaw_mode                = LOITER_YAW;
        roll_pitch_mode = LOITER_RP;
        throttle_mode   = THROTTLE_AUTO;
        do_land();
        break;

    case RTL:
        yaw_mode                = RTL_YAW;
        roll_pitch_mode = RTL_RP;
        throttle_mode   = RTL_THR;
        rtl_reached_alt = false;
        set_next_WP(&current_loc);
        set_new_altitude(get_RTL_alt());
        break;

    case OF_LOITER:
        yaw_mode                = OF_LOITER_YAW;
        roll_pitch_mode = OF_LOITER_RP;
        throttle_mode   = OF_LOITER_THR;
        set_next_WP(&current_loc);
        break;

    // THOR
    // These are the flight modes for Toy mode
    // See the defines for the enumerated values
    case TOY_A:
        yaw_mode                = YAW_TOY;
        roll_pitch_mode = ROLL_PITCH_TOY;
        throttle_mode   = THROTTLE_AUTO;
        wp_control              = NO_NAV_MODE;

        // save throttle for fast exit of Alt hold
        saved_toy_throttle = g.rc_3.control_in;

        // hold the current altitude
        set_new_altitude(current_loc.alt);
        break;

    case TOY_M:
        yaw_mode                = YAW_TOY;
        roll_pitch_mode = ROLL_PITCH_TOY;
        wp_control              = NO_NAV_MODE;
        throttle_mode   = THROTTLE_MANUAL;
        break;

    default:
        break;
    }

    if(failsafe) {
        // this is to allow us to fly home without interactive throttle control
        throttle_mode = THROTTLE_AUTO;
        // does not wait for us to be in high throttle, since the
        // Receiver will be outputting low throttle
        motors.auto_armed(true);
    }

    if(roll_pitch_mode <= ROLL_PITCH_ACRO) {
        // We are under manual attitude control
        // remove the navigation from roll and pitch command
        reset_nav_params();
        // remove the wind compenstaion
        reset_wind_I();
        // Clears the alt hold compensation
        reset_throttle_I();
    }

    Log_Write_Mode(control_mode);
}

static void set_failsafe(boolean mode)
{
    // only act on changes
    // -------------------
    if(failsafe != mode) {

        // store the value so we don't trip the gate twice
        // -----------------------------------------------
        failsafe = mode;

        if (failsafe == false) {
            // We've regained radio contact
            // ----------------------------
            failsafe_off_event();

        }else{
            // We've lost radio contact
            // ------------------------
            failsafe_on_event();
        }
    }
}

static void
init_simple_bearing()
{
    initial_simple_bearing = ahrs.yaw_sensor;
}

static void update_throttle_cruise(int16_t tmp)
{
    if(tmp != 0) {
        g.throttle_cruise += tmp;
        reset_throttle_I();
    }

    // recalc kp
    //g.pid_throttle.kP((float)g.throttle_cruise.get() / 981.0);
    //Serial.printf("kp:%1.4f\n",kp);
}

#if CLI_SLIDER_ENABLED == ENABLED && CLI_ENABLED == ENABLED
static boolean
check_startup_for_CLI()
{
    return (digitalRead(SLIDE_SWITCH_PIN) == 0);
}
#endif // CLI_ENABLED

/*
 *  map from a 8 bit EEPROM baud rate to a real baud rate
 */
static uint32_t map_baudrate(int8_t rate, uint32_t default_baud)
{
    switch (rate) {
    case 1:    return 1200;
    case 2:    return 2400;
    case 4:    return 4800;
    case 9:    return 9600;
    case 19:   return 19200;
    case 38:   return 38400;
    case 57:   return 57600;
    case 111:  return 111100;
    case 115:  return 115200;
    }
    //Serial.println_P(PSTR("Invalid SERIAL3_BAUD"));
    return default_baud;
}

#if USB_MUX_PIN > 0
static void check_usb_mux(void)
{
    bool usb_check = !digitalRead(USB_MUX_PIN);
    if (usb_check == usb_connected) {
        return;
    }

    // the user has switched to/from the telemetry port
    usb_connected = usb_check;
    if (usb_connected) {
        Serial.begin(SERIAL0_BAUD);
    } else {
        Serial.begin(map_baudrate(g.serial3_baud, SERIAL3_BAUD));
    }
}
#endif

/*
 *  called by gyro/accel init to flash LEDs so user
 *  has some mesmerising lights to watch while waiting
 */
void flash_leds(bool on)
{
    digitalWrite(A_LED_PIN, on ? LED_OFF : LED_ON);
    digitalWrite(C_LED_PIN, on ? LED_ON : LED_OFF);
}

#ifndef DESKTOP_BUILD
/*
 * Read Vcc vs 1.1v internal reference
 */
uint16_t board_voltage(void)
{
    static AP_AnalogSource_Arduino vcc(ANALOG_PIN_VCC);
    return vcc.read_vcc();
}
#endif

//
// print_flight_mode - prints flight mode to serial port.
//
static void
print_flight_mode(uint8_t mode)
{
    switch (mode) {
    case STABILIZE:
        Serial.print_P(PSTR("STABILIZE"));
        break;
    case ACRO:
        Serial.print_P(PSTR("ACRO"));
        break;
    case ALT_HOLD:
        Serial.print_P(PSTR("ALT_HOLD"));
        break;
    case AUTO:
        Serial.print_P(PSTR("AUTO"));
        break;
    case GUIDED:
        Serial.print_P(PSTR("GUIDED"));
        break;
    case LOITER:
        Serial.print_P(PSTR("LOITER"));
        break;
    case RTL:
        Serial.print_P(PSTR("RTL"));
        break;
    case CIRCLE:
        Serial.print_P(PSTR("CIRCLE"));
        break;
    case POSITION:
        Serial.print_P(PSTR("POSITION"));
        break;
    case LAND:
        Serial.print_P(PSTR("LAND"));
        break;
    case OF_LOITER:
        Serial.print_P(PSTR("OF_LOITER"));
        break;
    case TOY_M:
        Serial.print_P(PSTR("TOY_M"));
        break;
    case TOY_A:
        Serial.print_P(PSTR("TOY_A"));
        break;
    default:
        Serial.print_P(PSTR("---"));
        break;
    }
}
// -*- tab-width: 4; Mode: C++; c-basic-offset: 4; indent-tabs-mode: nil -*-

#if CLI_ENABLED == ENABLED

// These are function definitions so the Menu can be constructed before the functions
// are defined below. Order matters to the compiler.
static int8_t   test_radio_pwm(uint8_t argc,    const Menu::arg *argv);
static int8_t   test_radio(uint8_t argc,                const Menu::arg *argv);
//static int8_t	test_failsafe(uint8_t argc,     const Menu::arg *argv);
//static int8_t	test_stabilize(uint8_t argc,    const Menu::arg *argv);
static int8_t   test_gps(uint8_t argc,                  const Menu::arg *argv);
//static int8_t	test_tri(uint8_t argc,          const Menu::arg *argv);
//static int8_t	test_adc(uint8_t argc,          const Menu::arg *argv);
static int8_t   test_ins(uint8_t argc,                  const Menu::arg *argv);
//static int8_t	test_imu(uint8_t argc,          const Menu::arg *argv);
//static int8_t	test_dcm_eulers(uint8_t argc,   const Menu::arg *argv);
//static int8_t	test_dcm(uint8_t argc,          const Menu::arg *argv);
//static int8_t	test_omega(uint8_t argc,        const Menu::arg *argv);
//static int8_t	test_stab_d(uint8_t argc,       const Menu::arg *argv);
static int8_t   test_battery(uint8_t argc,              const Menu::arg *argv);
//static int8_t	test_toy(uint8_t argc,      const Menu::arg *argv);
static int8_t   test_wp_nav(uint8_t argc,               const Menu::arg *argv);
//static int8_t	test_reverse(uint8_t argc,      const Menu::arg *argv);
static int8_t   test_tuning(uint8_t argc,               const Menu::arg *argv);
static int8_t   test_relay(uint8_t argc,                const Menu::arg *argv);
static int8_t   test_wp(uint8_t argc,                   const Menu::arg *argv);
#if HIL_MODE != HIL_MODE_ATTITUDE
static int8_t   test_baro(uint8_t argc,                 const Menu::arg *argv);
static int8_t   test_sonar(uint8_t argc,                const Menu::arg *argv);
#endif
static int8_t   test_mag(uint8_t argc,                  const Menu::arg *argv);
static int8_t   test_optflow(uint8_t argc,              const Menu::arg *argv);
static int8_t   test_logging(uint8_t argc,              const Menu::arg *argv);
//static int8_t	test_xbee(uint8_t argc,         const Menu::arg *argv);
static int8_t   test_eedump(uint8_t argc,               const Menu::arg *argv);
static int8_t   test_rawgps(uint8_t argc,               const Menu::arg *argv);
//static int8_t	test_mission(uint8_t argc,      const Menu::arg *argv);

// this is declared here to remove compiler errors
extern void             print_latlon(BetterStream *s, int32_t lat_or_lon);      // in Log.pde

// This is the help function
// PSTR is an AVR macro to read strings from flash memory
// printf_P is a version of printf that reads from flash memory
/*static int8_t	help_test(uint8_t argc,             const Menu::arg *argv)
 *  {
 *       Serial.printf_P(PSTR("\n"
 *                                                "Commands:\n"
 *                                                "  radio\n"
 *                                                "  servos\n"
 *                                                "  g_gps\n"
 *                                                "  imu\n"
 *                                                "  battery\n"
 *                                                "\n"));
 *  }*/

// Creates a constant array of structs representing menu options
// and stores them in Flash memory, not RAM.
// User enters the string in the console to call the functions on the right.
// See class Menu in AP_Coommon for implementation details
const struct Menu::command test_menu_commands[] PROGMEM = {
    {"pwm",                 test_radio_pwm},
    {"radio",               test_radio},
//	{"failsafe",	test_failsafe},
//	{"stabilize",	test_stabilize},
    {"gps",                 test_gps},
//	{"adc",         test_adc},
    {"ins",                 test_ins},
//	{"imu",			test_imu},
//	{"dcm",			test_dcm_eulers},
    //{"omega",		test_omega},
//	{"stab_d",		test_stab_d},
    {"battery",             test_battery},
    {"tune",                test_tuning},
    //{"tri",			test_tri},
    {"relay",               test_relay},
    {"wp",                  test_wp},
//	{"toy",			test_toy},
#if HIL_MODE != HIL_MODE_ATTITUDE
    {"altitude",    test_baro},
    {"sonar",               test_sonar},
#endif
    {"compass",             test_mag},
    {"optflow",             test_optflow},
    //{"xbee",		test_xbee},
    {"eedump",              test_eedump},
    {"logging",             test_logging},
//	{"rawgps",		test_rawgps},
//	{"mission",		test_mission},
    //{"reverse",		test_reverse},
    {"nav",                 test_wp_nav},
};

// A Macro to create the Menu
MENU(test_menu, "test", test_menu_commands);

static int8_t
test_mode(uint8_t argc, const Menu::arg *argv)
{
    //Serial.printf_P(PSTR("Test Mode\n\n"));
    test_menu.run();
    return 0;
}

static int8_t
test_eedump(uint8_t argc, const Menu::arg *argv)
{
    int i, j;

    // hexdump the EEPROM
    for (i = 0; i < EEPROM_MAX_ADDR; i += 16) {
        Serial.printf_P(PSTR("%04x:"), i);
        for (j = 0; j < 16; j++)
            Serial.printf_P(PSTR(" %02x"), eeprom_read_byte((const uint8_t *)(i + j)));
        Serial.println();
    }
    return(0);
}


static int8_t
test_radio_pwm(uint8_t argc, const Menu::arg *argv)
{
#if defined( __AVR_ATmega1280__ )          // test disabled to save code size for 1280
    print_test_disabled();
    return (0);
#else
    print_hit_enter();
    delay(1000);

    while(1) {
        delay(20);

        // Filters radio input - adjust filters in the radio.pde file
        // ----------------------------------------------------------
        read_radio();

        // servo Yaw
        //APM_RC.OutputCh(CH_7, g.rc_4.radio_out);

        Serial.printf_P(PSTR("IN: 1: %d\t2: %d\t3: %d\t4: %d\t5: %d\t6: %d\t7: %d\t8: %d\n"),
                        g.rc_1.radio_in,
                        g.rc_2.radio_in,
                        g.rc_3.radio_in,
                        g.rc_4.radio_in,
                        g.rc_5.radio_in,
                        g.rc_6.radio_in,
                        g.rc_7.radio_in,
                        g.rc_8.radio_in);

        if(Serial.available() > 0) {
            return (0);
        }
    }
#endif
}

/*
 *  //static int8_t
 *  //test_tri(uint8_t argc, const Menu::arg *argv)
 *  {
 *       print_hit_enter();
 *       delay(1000);
 *
 *       while(1){
 *               delay(20);
 *
 *               // Filters radio input - adjust filters in the radio.pde file
 *               // ----------------------------------------------------------
 *               read_radio();
 *               g.rc_4.servo_out = g.rc_4.control_in;
 *               g.rc_4.calc_pwm();
 *
 *               Serial.printf_P(PSTR("input: %d\toutput%d\n"),
 *                                                       g.rc_4.control_in,
 *                                                       g.rc_4.radio_out);
 *
 *               APM_RC.OutputCh(CH_TRI_YAW, g.rc_4.radio_out);
 *
 *               if(Serial.available() > 0){
 *                       return (0);
 *               }
 *       }
 *  }*/


/*static int8_t
 *  //test_toy(uint8_t argc, const Menu::arg *argv)
 *  {
 *       int16_t yaw_rate;
 *       int16_t roll_rate;
 *       g.rc_1.control_in = -2500;
 *       g.rc_2.control_in = 2500;
 *
 *       g.toy_yaw_rate = 3;
 *       yaw_rate = g.rc_1.control_in / g.toy_yaw_rate;
 *       roll_rate = ((int32_t)g.rc_2.control_in * (yaw_rate/100)) /40;
 *       Serial.printf("yaw_rate, %d, roll_rate, %d\n", yaw_rate, roll_rate);
 *
 *       g.toy_yaw_rate = 2;
 *       yaw_rate = g.rc_1.control_in / g.toy_yaw_rate;
 *       roll_rate = ((int32_t)g.rc_2.control_in * (yaw_rate/100)) /40;
 *       Serial.printf("yaw_rate, %d, roll_rate, %d\n", yaw_rate, roll_rate);
 *
 *       g.toy_yaw_rate = 1;
 *       yaw_rate = g.rc_1.control_in / g.toy_yaw_rate;
 *       roll_rate = ((int32_t)g.rc_2.control_in * (yaw_rate/100)) /40;
 *       Serial.printf("yaw_rate, %d, roll_rate, %d\n", yaw_rate, roll_rate);
 *  }*/

static int8_t
test_radio(uint8_t argc, const Menu::arg *argv)
{
    print_hit_enter();
    delay(1000);

    while(1) {
        delay(20);
        read_radio();


        Serial.printf_P(PSTR("IN  1: %d\t2: %d\t3: %d\t4: %d\t5: %d\t6: %d\t7: %d\n"),
                        g.rc_1.control_in,
                        g.rc_2.control_in,
                        g.rc_3.control_in,
                        g.rc_4.control_in,
                        g.rc_5.control_in,
                        g.rc_6.control_in,
                        g.rc_7.control_in);

        //Serial.printf_P(PSTR("OUT 1: %d\t2: %d\t3: %d\t4: %d\n"), (g.rc_1.servo_out / 100), (g.rc_2.servo_out / 100), g.rc_3.servo_out, (g.rc_4.servo_out / 100));

        /*Serial.printf_P(PSTR(	"min: %d"
         *                                               "\t in: %d"
         *                                               "\t pwm_in: %d"
         *                                               "\t sout: %d"
         *                                               "\t pwm_out %d\n"),
         *                                               g.rc_3.radio_min,
         *                                               g.rc_3.control_in,
         *                                               g.rc_3.radio_in,
         *                                               g.rc_3.servo_out,
         *                                               g.rc_3.pwm_out
         *                                               );
         */
        if(Serial.available() > 0) {
            return (0);
        }
    }
}

/*
 *  //static int8_t
 *  //test_failsafe(uint8_t argc, const Menu::arg *argv)
 *  {
 *
 * #if THROTTLE_FAILSAFE
 *       byte fail_test;
 *       print_hit_enter();
 *       for(int16_t i = 0; i < 50; i++){
 *               delay(20);
 *               read_radio();
 *       }
 *
 *       oldSwitchPosition = readSwitch();
 *
 *       Serial.printf_P(PSTR("Unplug battery, throttle in neutral, turn off radio.\n"));
 *       while(g.rc_3.control_in > 0){
 *               delay(20);
 *               read_radio();
 *       }
 *
 *       while(1){
 *               delay(20);
 *               read_radio();
 *
 *               if(g.rc_3.control_in > 0){
 *                       Serial.printf_P(PSTR("THROTTLE CHANGED %d \n"), g.rc_3.control_in);
 *                       fail_test++;
 *               }
 *
 *               if(oldSwitchPosition != readSwitch()){
 *                       Serial.printf_P(PSTR("CONTROL MODE CHANGED: "));
 *                       Serial.println(flight_mode_strings[readSwitch()]);
 *                       fail_test++;
 *               }
 *
 *               if(g.throttle_fs_enabled && g.rc_3.get_failsafe()){
 *                       Serial.printf_P(PSTR("THROTTLE FAILSAFE ACTIVATED: %d, "), g.rc_3.radio_in);
 *                       Serial.println(flight_mode_strings[readSwitch()]);
 *                       fail_test++;
 *               }
 *
 *               if(fail_test > 0){
 *                       return (0);
 *               }
 *               if(Serial.available() > 0){
 *                       Serial.printf_P(PSTR("LOS caused no change in ACM.\n"));
 *                       return (0);
 *               }
 *       }
 * #else
 *               return (0);
 * #endif
 *  }
 */

/*
 *  //static int8_t
 *  //test_stabilize(uint8_t argc, const Menu::arg *argv)
 *  {
 *       static byte ts_num;
 *
 *
 *       print_hit_enter();
 *       delay(1000);
 *
 *       // setup the radio
 *       // ---------------
 *       init_rc_in();
 *
 *       control_mode = STABILIZE;
 *       Serial.printf_P(PSTR("g.pi_stabilize_roll.kP: %4.4f\n"), g.pi_stabilize_roll.kP());
 *       Serial.printf_P(PSTR("max_stabilize_dampener:%d\n\n "), max_stabilize_dampener);
 *
 *       motors.auto_armed(false);
 *       motors.armed(true);
 *
 *       while(1){
 *               // 50 hz
 *               if (millis() - fast_loopTimer > 19) {
 *                       delta_ms_fast_loop     = millis() - fast_loopTimer;
 *                       fast_loopTimer		= millis();
 *                       G_Dt               = (float)delta_ms_fast_loop / 1000.f;
 *
 *                       if(g.compass_enabled){
 *                               medium_loopCounter++;
 *                               if(medium_loopCounter == 5){
 *                   Matrix3f m = dcm.get_dcm_matrix();
 *                                       compass.read();		                // Read magnetometer
 *                   compass.null_offsets();
 *                                       medium_loopCounter = 0;
 *                               }
 *                       }
 *
 *                       // for trim features
 *                       read_trim_switch();
 *
 *                       // Filters radio input - adjust filters in the radio.pde file
 *                       // ----------------------------------------------------------
 *                       read_radio();
 *
 *                       // IMU
 *                       // ---
 *                       read_AHRS();
 *
 *                       // allow us to zero out sensors with control switches
 *                       if(g.rc_5.control_in < 600){
 *                               dcm.roll_sensor = dcm.pitch_sensor = 0;
 *                       }
 *
 *                       // custom code/exceptions for flight modes
 *                       // ---------------------------------------
 *                       update_current_flight_mode();
 *
 *                       // write out the servo PWM values
 *                       // ------------------------------
 *                       set_servos_4();
 *
 *                       ts_num++;
 *                       if (ts_num > 10){
 *                               ts_num = 0;
 *                               Serial.printf_P(PSTR("r: %d, p:%d, rc1:%d, "),
 *                                       (int)(dcm.roll_sensor/100),
 *                                       (int)(dcm.pitch_sensor/100),
 *                                       g.rc_1.pwm_out);
 *
 *                               print_motor_out();
 *                       }
 *                       // R: 1417,  L: 1453  F: 1453  B: 1417
 *
 *                       //Serial.printf_P(PSTR("timer: %d, r: %d\tp: %d\t y: %d\n"), (int)delta_ms_fast_loop, ((int)dcm.roll_sensor/100), ((int)dcm.pitch_sensor/100), ((uint16_t)dcm.yaw_sensor/100));
 *                       //Serial.printf_P(PSTR("timer: %d, r: %d\tp: %d\t y: %d\n"), (int)delta_ms_fast_loop, ((int)dcm.roll_sensor/100), ((int)dcm.pitch_sensor/100), ((uint16_t)dcm.yaw_sensor/100));
 *
 *                       if(Serial.available() > 0){
 *                               if(g.compass_enabled){
 *                                       compass.save_offsets();
 *                                       report_compass();
 *                               }
 *                               return (0);
 *                       }
 *
 *               }
 *       }
 *  }
 */


/*
 * #if HIL_MODE != HIL_MODE_ATTITUDE && CONFIG_ADC == ENABLED
 *  //static int8_t
 *  //test_adc(uint8_t argc, const Menu::arg *argv)
 *  {
 *       print_hit_enter();
 *       Serial.printf_P(PSTR("ADC\n"));
 *       delay(1000);
 *
 *  adc.Init(&timer_scheduler);
 *
 *  delay(50);
 *
 *       while(1){
 *               for(int16_t i = 0; i < 9; i++){
 *                       Serial.printf_P(PSTR("%.1f,"),adc.Ch(i));
 *               }
 *               Serial.println();
 *               delay(20);
 *               if(Serial.available() > 0){
 *                       return (0);
 *               }
 *       }
 *  }
 * #endif
 */

/*
 *  static int8_t
 *  test_adc(uint8_t argc, const Menu::arg *argv)
 *  {
 *       ins.init(&timer_scheduler);
 *
 *       int8_t mytimer = 0;
 *       startup_ground();
 *       Serial.println("OK");
 *
 *       while(1){
 *               // We want this to execute fast
 *               // ----------------------------
 *               uint32_t timer             = micros();
 *
 *               if ((timer - fast_loopTimer) >= 10000 && imu.new_data_available()) {
 *                       G_Dt               = (float)(timer - fast_loopTimer) / 1000000.f;		// used by PI Loops
 *                       fast_loopTimer         = timer;
 *
 *                       read_AHRS();
 *
 *                       //calc_inertia();
 *                       accels_rotated		= ahrs.get_dcm_matrix() * imu.get_accel();
 *                       //accels_rotated		+= accels_offset;						// skew accels to account for long term error using calibration
 *
 *                       mytimer++;
 *
 *                       if ((timer - fiftyhz_loopTimer) >= 20000) {
 *                               fiftyhz_loopTimer		= timer;
 *                               //sensed_loc.lng = sensed_loc.lat = sensed_loc.alt = 0;
 *
 *                               // position fix
 *                               //inertial_error_correction();
 *                       }
 *
 *                       if (mytimer >= 10){
 *                               float test = sqrt(sq(accels_rotated.x) + sq(accels_rotated.y) + sq(accels_rotated.z)) / 9.80665;
 *
 *                               Vector3f _accels = imu.get_accel();
 *                               mytimer = 0;
 *
 *
 *                               Serial.printf("%1.4f, %1.4f, %1.4f  |   %1.4f, %1.4f, %1.4f   |  %d, %1.4f, %d, %1.4f \n",
 *                                                                       _accels.x,
 *                                                                       _accels.y,
 *                                                                       _accels.z,
 *                                                                       accels_rotated.x,
 *                                                                       accels_rotated.y,
 *                                                                       accels_rotated.z,
 *                                                                       test);
 *
 *
 *                       }
 *
 *                       if(Serial.available() > 0){
 *                               return (0);
 *                       }
 *               }
 *       }
 *       return (0);
 *  }
 */

static int8_t
test_ins(uint8_t argc, const Menu::arg *argv)
{
#if defined( __AVR_ATmega1280__ )          // test disabled to save code size for 1280
    print_test_disabled();
    return (0);
#else
    float gyro[3], accel[3], temp;
    print_hit_enter();
    Serial.printf_P(PSTR("InertialSensor\n"));
    delay(1000);

    ins.init(&timer_scheduler);

    delay(50);

    while(1) {
        ins.update();
        ins.get_gyros(gyro);
        ins.get_accels(accel);
        temp = ins.temperature();

        float test = sqrt(sq(accel[0]) + sq(accel[1]) + sq(accel[2])) / 9.80665;

        Serial.printf_P(PSTR("g"));

        for (int16_t i = 0; i < 3; i++) {
            Serial.printf_P(PSTR(" %7.4f"), gyro[i]);
        }

        Serial.printf_P(PSTR(" a"));

        for (int16_t i = 0; i < 3; i++) {
            Serial.printf_P(PSTR(" %7.4f"),accel[i]);
        }

        Serial.printf_P(PSTR(" t %7.4f "), temp);
        Serial.printf_P(PSTR(" | %7.4f \n"), test);

        delay(40);
        if(Serial.available() > 0) {
            return (0);
        }
    }
#endif
}


/*
 *  test the IMU interface
 */
/*
 *  static int8_t
 *  test_imu(uint8_t argc, const Menu::arg *argv)
 *  {
 * #if defined( __AVR_ATmega1280__ )  // test disabled to save code size for 1280
 *               print_test_disabled();
 *               return (0);
 * #else
 *               Vector3f gyro;
 *               Vector3f accel;
 *
 *               imu.init(IMU::WARM_START, delay, flash_leds, &timer_scheduler);
 *
 *               report_imu();
 *               imu.init_gyro(delay, flash_leds);
 *               report_imu();
 *
 *               print_hit_enter();
 *               delay(1000);
 *
 *               while(1){
 *                       delay(40);
 *
 *                       imu.update();
 *                       gyro = imu.get_gyro();
 *                       accel = imu.get_accel();
 *
 *                       Serial.printf_P(PSTR("g %8.4f %8.4f %8.4f"), gyro.x, gyro.y, gyro.z);
 *                       Serial.printf_P(PSTR("  a %8.4f %8.4f %8.4f\n"), accel.x, accel.y, accel.z);
 *
 *                       if(Serial.available() > 0){
 *                               return (0);
 *                       }
 *               }
 * #endif
 *  }
 */

/*
 *  static int8_t
 *  test_imu(uint8_t argc, const Menu::arg *argv)
 *  {
 *       print_hit_enter();
 *       Serial.printf_P(PSTR("ADC\n"));
 *       adc.Init(&timer_scheduler);
 *
 *       delay(1000);
 *       Vector3f avg;
 *       avg.x = adc.Ch(4);
 *       avg.y = adc.Ch(5);
 *       avg.z = adc.Ch(6);
 *
 *       //Serial.printf_P(PSTR("init %.2f, %.2f, %.2f\n"), avg.x, avg.y, avg.z);
 *       Vector3f low = avg;
 *       Vector3f high = avg;
 *
 *       while(1){
 *               delay(100);
 *               avg.x = avg.x * .95 + adc.Ch(4) * .05;
 *               avg.y = avg.y * .95 + adc.Ch(5) * .05;
 *               avg.z = avg.z * .95 + adc.Ch(6) * .05;
 *
 *               if(avg.x > high.x)
 *                       high.x = ceil(high.x *.9 + avg.x * .1);
 *
 *               if(avg.y > high.y)
 *                       high.y = ceil(high.y *.9 + avg.y * .1);
 *
 *               if(avg.z > high.z)
 *                       high.z = ceil(high.z *.9 + avg.z * .1);
 *
 *               //
 *               if(avg.x < low.x)
 *                       low.x = floor(low.x *.9 + avg.x * .1);
 *
 *               if(avg.y < low.y)
 *                       low.y = floor(low.y *.9 + avg.y * .1);
 *
 *               if(avg.z < low.z)
 *                       low.z = floor(low.z *.9 + avg.z * .1);
 *
 *               Serial.printf_P(PSTR("%.2f, %.2f, %.2f \t| %.2f, %.2f, %.2f \t| %.2f, %.2f, %.2f\n"), avg.x, avg.y, avg.z, low.x, low.y, low.z, high.x, high.y, high.z);
 *
 *               //Serial.printf_P(PSTR("%.2f, %.2f, %.2f \t| %d, %d\n"), avg.x, avg.y, avg.z, _count[0], _sum[0]);
 *
 *               //Serial.println();
 *               if(Serial.available() > 0){
 *                       Serial.printf_P(PSTR("Y to save\n"));
 *                       int16_t c;
 *                       c = Serial.read();
 *
 *                       do {
 *                               c = Serial.read();
 *                       } while (-1 == c);
 *
 *                       if (('y' == c) || ('Y' == c)){
 *                               ins._x_high    = high.x;
 *                               ins._x_low         = low.x;
 *                               ins._y_high    = high.y;
 *                               ins._y_low         = low.y;
 *                               ins._z_high    = high.z;
 *                               ins._z_low         = low.z;
 *                               ins._x_high.save();
 *                               ins._x_low.save();
 *                               ins._y_high.save();
 *                               ins._y_low.save();
 *                               ins._z_high.save();
 *                               ins._z_low.save();
 *                               Serial.printf_P(PSTR("saved\n"));
 *                       }
 *
 *                       return (0);
 *               }
 *       }
 *  }
 */



/*
 *  test the DCM code, printing Euler angles
 */
/*static int8_t
 *  //test_dcm_eulers(uint8_t argc, const Menu::arg *argv)
 *  {
 *
 *       //Serial.printf_P(PSTR("Calibrating."));
 *
 *       //dcm.kp_yaw(0.02);
 *       //dcm.ki_yaw(0);
 *
 *       imu.init(IMU::WARM_START, delay, flash_leds, &timer_scheduler);
 *
 *       report_imu();
 *       imu.init_gyro(delay, flash_leds);
 *       report_imu();
 *
 *       print_hit_enter();
 *       delay(1000);
 *
 *       //float cos_roll, sin_roll, cos_pitch, sin_pitch, cos_yaw, sin_yaw;
 *       fast_loopTimer = millis();
 *
 *       while(1){
 *               //delay(20);
 *               if (millis() - fast_loopTimer >=20) {
 *
 *                       // IMU
 *                       // ---
 *                       read_AHRS();
 *                       medium_loopCounter++;
 *
 *                       if(medium_loopCounter == 4){
 *                               update_trig();
 *                       }
 *
 *                       if(medium_loopCounter == 1){
 *                               medium_loopCounter = 0;
 *                               Serial.printf_P(PSTR("dcm: %6.1f, %6.1f, %6.1f   omega: %6.1f, %6.1f, %6.1f\n"),
 *                                                               dcm.roll_sensor/100.0,
 *                                                               dcm.pitch_sensor/100.0,
 *                                                               dcm.yaw_sensor/100.0,
 *                                                               degrees(omega.x),
 *                                                               degrees(omega.y),
 *                                                               degrees(omega.z));
 *
 *                               if(g.compass_enabled){
 *                                       compass.read();		                // Read magnetometer
 *                   compass.null_offsets();
 *                               }
 *                       }
 *                       fast_loopTimer = millis();
 *               }
 *               if(Serial.available() > 0){
 *                       return (0);
 *               }
 *       }
 *       return (0);
 *  }*/

static int8_t
test_gps(uint8_t argc, const Menu::arg *argv)
{
    // test disabled to save code size for 1280
#if defined( __AVR_ATmega1280__ ) || HIL_MODE != HIL_MODE_DISABLED
    print_test_disabled();
    return (0);
#else
    print_hit_enter();
    delay(1000);

    while(1) {
        delay(333);

        // Blink GPS LED if we don't have a fix
        // ------------------------------------
        update_GPS_light();

        g_gps->update();

        if (g_gps->new_data) {
            Serial.printf_P(PSTR("Lat: "));
            print_latlon(&Serial, g_gps->latitude);
            Serial.printf_P(PSTR(", Lon "));
            print_latlon(&Serial, g_gps->longitude);
            Serial.printf_P(PSTR(", Alt: %ldm, #sats: %d\n"),
                            g_gps->altitude/100,
                            g_gps->num_sats);
            g_gps->new_data = false;
        }else{
            Serial.print_P(PSTR("."));
        }
        if(Serial.available() > 0) {
            return (0);
        }
    }
    return 0;
#endif
}

// used to test the gain scheduler for Stab_D
/*
 *  static int8_t
 *  test_stab_d(uint8_t argc, const Menu::arg *argv)
 *  {
 *       int16_t i = 0;
 *       g.stabilize_d = 1;
 *
 *       g.stabilize_d_schedule = 1
 *       for (i = -4600; i < 4600; i+=10) {
 *               new_radio_frame = true;
 *               g.rc_1.control_in = i;
 *               g.rc_2.control_in = i;
 *               update_roll_pitch_mode();
 *       Serial.printf("rin:%d, d:%1.6f \tpin:%d, d:%1.6f\n",g.rc_1.control_in, roll_scale_d, g.rc_2.control_in, pitch_scale_d);
 *   }
 *       g.stabilize_d_schedule = .5
 *       for (i = -4600; i < 4600; i+=10) {
 *               new_radio_frame = true;
 *               g.rc_1.control_in = i;
 *               g.rc_2.control_in = i;
 *               update_roll_pitch_mode();
 *       Serial.printf("rin:%d, d:%1.6f \tpin:%d, d:%1.6f\n",g.rc_1.control_in, roll_scale_d, g.rc_2.control_in, pitch_scale_d);
 *   }
 *
 *       g.stabilize_d_schedule = 0
 *       for (i = -4600; i < 4600; i+=10) {
 *               new_radio_frame = true;
 *               g.rc_1.control_in = i;
 *               g.rc_2.control_in = i;
 *               update_roll_pitch_mode();
 *       Serial.printf("rin:%d, d:%1.6f \tpin:%d, d:%1.6f\n",g.rc_1.control_in, roll_scale_d, g.rc_2.control_in, pitch_scale_d);
 *   }
 *
 *  }*/

/*
 *  //static int8_t
 *  //test_dcm(uint8_t argc, const Menu::arg *argv)
 *  {
 *       print_hit_enter();
 *       delay(1000);
 *       Serial.printf_P(PSTR("Gyro | Accel\n"));
 *       Vector3f   _cam_vector;
 *       Vector3f   _out_vector;
 *
 *       G_Dt = .02;
 *
 *       while(1){
 *               for(byte i = 0; i <= 50; i++){
 *                       delay(20);
 *                       // IMU
 *                       // ---
 *                       read_AHRS();
 *               }
 *
 *               Matrix3f temp = dcm.get_dcm_matrix();
 *               Matrix3f temp_t = dcm.get_dcm_transposed();
 *
 *               Serial.printf_P(PSTR("dcm\n"
 *                                                        "%4.4f \t %4.4f \t %4.4f \n"
 *                                                        "%4.4f \t %4.4f \t %4.4f \n"
 *                                                        "%4.4f \t %4.4f \t %4.4f \n\n"),
 *                                                       temp.a.x, temp.a.y, temp.a.z,
 *                                                       temp.b.x, temp.b.y, temp.b.z,
 *                                                       temp.c.x, temp.c.y, temp.c.z);
 *
 *               int16_t _pitch         = degrees(-asin(temp.c.x));
 *               int16_t _roll      = degrees(atan2(temp.c.y, temp.c.z));
 *               int16_t _yaw       = degrees(atan2(temp.b.x, temp.a.x));
 *               Serial.printf_P(PSTR(	"angles\n"
 *                                                               "%d \t %d \t %d\n\n"),
 *                                                               _pitch,
 *                                                               _roll,
 *                                                               _yaw);
 *
 *               //_out_vector = _cam_vector * temp;
 *               //Serial.printf_P(PSTR(	"cam\n"
 *               //						"%d \t %d \t %d\n\n"),
 *               //						(int)temp.a.x * 100, (int)temp.a.y * 100, (int)temp.a.x * 100);
 *
 *               if(Serial.available() > 0){
 *                       return (0);
 *               }
 *       }
 *  }
 */
/*
 *  //static int8_t
 *  //test_dcm(uint8_t argc, const Menu::arg *argv)
 *  {
 *       print_hit_enter();
 *       delay(1000);
 *       Serial.printf_P(PSTR("Gyro | Accel\n"));
 *       delay(1000);
 *
 *       while(1){
 *               Vector3f accels = dcm.get_accel();
 *               Serial.print("accels.z:");
 *               Serial.print(accels.z);
 *               Serial.print("omega.z:");
 *               Serial.print(omega.z);
 *               delay(100);
 *
 *               if(Serial.available() > 0){
 *                       return (0);
 *               }
 *       }
 *  }
 */

/*static int8_t
 *  //test_omega(uint8_t argc, const Menu::arg *argv)
 *  {
 *       static byte ts_num;
 *       float old_yaw;
 *
 *       print_hit_enter();
 *       delay(1000);
 *       Serial.printf_P(PSTR("Omega"));
 *       delay(1000);
 *
 *       G_Dt = .02;
 *
 *       while(1){
 *               delay(20);
 *               // IMU
 *               // ---
 *               read_AHRS();
 *
 *               float my_oz = (dcm.yaw - old_yaw) * 50;
 *
 *               old_yaw = dcm.yaw;
 *
 *               ts_num++;
 *               if (ts_num > 2){
 *                       ts_num = 0;
 *                       //Serial.printf_P(PSTR("R: %4.4f\tP: %4.4f\tY: %4.4f\tY: %4.4f\n"), omega.x, omega.y, omega.z, my_oz);
 *                       Serial.printf_P(PSTR(" Yaw: %ld\tY: %4.4f\tY: %4.4f\n"), dcm.yaw_sensor, omega.z, my_oz);
 *               }
 *
 *               if(Serial.available() > 0){
 *                       return (0);
 *               }
 *       }
 *       return (0);
 *  }
 *  //*/

static int8_t
test_tuning(uint8_t argc, const Menu::arg *argv)
{
    print_hit_enter();

    while(1) {
        delay(200);
        read_radio();
        tuning();
        Serial.printf_P(PSTR("tune: %1.3f\n"), tuning_value);

        if(Serial.available() > 0) {
            return (0);
        }
    }
}

static int8_t
test_battery(uint8_t argc, const Menu::arg *argv)
{
#if defined( __AVR_ATmega1280__ )          // disable this test if we are using 1280
    print_test_disabled();
    return (0);
#else
    Serial.printf_P(PSTR("\nCareful! Motors will spin! Press Enter to start.\n"));
    Serial.flush();
    while(!Serial.available()) {
        delay(100);
    }
    Serial.flush();
    print_hit_enter();

    // allow motors to spin
    motors.enable();
    motors.armed(true);

    while(1) {
        delay(100);
        read_radio();
        read_battery();
        if (g.battery_monitoring == 3) {
            Serial.printf_P(PSTR("V: %4.4f\n"),
                            battery_voltage1,
                            current_amps1,
                            current_total1);
        } else {
            Serial.printf_P(PSTR("V: %4.4f, A: %4.4f, Ah: %4.4f\n"),
                            battery_voltage1,
                            current_amps1,
                            current_total1);
        }
        motors.throttle_pass_through();

        if(Serial.available() > 0) {
            motors.armed(false);
            return (0);
        }
    }
    motors.armed(false);
    return (0);
#endif
}

static int8_t test_relay(uint8_t argc, const Menu::arg *argv)
{
#if defined( __AVR_ATmega1280__ )          // test disabled to save code size for 1280
    print_test_disabled();
    return (0);
#else

    print_hit_enter();
    delay(1000);

    while(1) {
        Serial.printf_P(PSTR("Relay on\n"));
        relay.on();
        delay(3000);
        if(Serial.available() > 0) {
            return (0);
        }

        Serial.printf_P(PSTR("Relay off\n"));
        relay.off();
        delay(3000);
        if(Serial.available() > 0) {
            return (0);
        }
    }
#endif
}


static int8_t
test_wp(uint8_t argc, const Menu::arg *argv)
{
    delay(1000);

    // save the alitude above home option
    Serial.printf_P(PSTR("Hold alt "));
    if(g.RTL_altitude < 0) {
        Serial.printf_P(PSTR("\n"));
    }else{
        Serial.printf_P(PSTR("of %dm\n"), (int)g.RTL_altitude / 100);
    }

    Serial.printf_P(PSTR("%d wp\n"), (int)g.command_total);
    Serial.printf_P(PSTR("Hit rad: %dm\n"), (int)g.waypoint_radius);
    //Serial.printf_P(PSTR("Loiter radius: %d\n\n"), (int)g.loiter_radius);

    report_wp();

    return (0);
}

//static int8_t test_rawgps(uint8_t argc, const Menu::arg *argv) {
/*
 *  print_hit_enter();
 *  delay(1000);
 *  while(1){
 *          if (Serial3.available()){
 *                          digitalWrite(B_LED_PIN, LED_ON); // Blink Yellow LED if we are sending data to GPS
 *                          Serial1.write(Serial3.read());
 *                          digitalWrite(B_LED_PIN, LED_OFF);
 *          }
 *          if (Serial1.available()){
 *                          digitalWrite(C_LED_PIN, LED_ON); // Blink Red LED if we are receiving data from GPS
 *                          Serial3.write(Serial1.read());
 *                          digitalWrite(C_LED_PIN, LED_OFF);
 *          }
 *          if(Serial.available() > 0){
 *                          return (0);
 *  }
 *  }
 */
//}

/*static int8_t
 *  //test_xbee(uint8_t argc, const Menu::arg *argv)
 *  {
 *       print_hit_enter();
 *       delay(1000);
 *       Serial.printf_P(PSTR("Begin XBee X-CTU Range and RSSI Test:\n"));
 *
 *       while(1){
 *               if (Serial3.available())
 *                       Serial3.write(Serial3.read());
 *
 *               if(Serial.available() > 0){
 *                       return (0);
 *               }
 *       }
 *  }
 */

#if HIL_MODE != HIL_MODE_ATTITUDE
static int8_t
test_baro(uint8_t argc, const Menu::arg *argv)
{
 #if defined( __AVR_ATmega1280__ )         // test disabled to save code size for 1280
    print_test_disabled();
    return (0);
 #else
    print_hit_enter();
    init_barometer();

    while(1) {
        delay(100);
        int32_t alt = read_barometer();                 // calls barometer.read()

        int32_t pres = barometer.get_pressure();
        int16_t temp = barometer.get_temperature();
        int32_t raw_pres = barometer.get_raw_pressure();
        int32_t raw_temp = barometer.get_raw_temp();
        Serial.printf_P(PSTR("alt: %ldcm, pres: %ldmbar, temp: %d/100degC,"
                             " raw pres: %ld, raw temp: %ld\n"),
                        alt, pres,temp, raw_pres, raw_temp);
        if(Serial.available() > 0) {
            return (0);
        }
    }
    return 0;
 #endif
}
#endif


static int8_t
test_mag(uint8_t argc, const Menu::arg *argv)
{
#if defined( __AVR_ATmega1280__ )          // test disabled to save code size for 1280
    print_test_disabled();
    return (0);
#else
    if(g.compass_enabled) {
        print_hit_enter();

        while(1) {
            delay(100);
            if (compass.read()) {
                float heading = compass.calculate_heading(ahrs.get_dcm_matrix());
                Serial.printf_P(PSTR("Heading: %ld, XYZ: %d, %d, %d\n"),
                                (wrap_360(ToDeg(heading) * 100)) /100,
                                compass.mag_x,
                                compass.mag_y,
                                compass.mag_z);
            } else {
                Serial.println_P(PSTR("not healthy"));
            }

            if(Serial.available() > 0) {
                return (0);
            }
        }
    } else {
        Serial.printf_P(PSTR("Compass: "));
        print_enabled(false);
        return (0);
    }
    return (0);
#endif
}

/*
 *  //static int8_t
 *  //test_reverse(uint8_t argc,        const Menu::arg *argv)
 *  {
 *       print_hit_enter();
 *       delay(1000);
 *
 *       while(1){
 *               delay(20);
 *
 *               // Filters radio input - adjust filters in the radio.pde file
 *               // ----------------------------------------------------------
 *               g.rc_4.set_reverse(0);
 *               g.rc_4.set_pwm(APM_RC.InputCh(CH_4));
 *               g.rc_4.servo_out = g.rc_4.control_in;
 *               g.rc_4.calc_pwm();
 *               Serial.printf_P(PSTR("PWM:%d input: %d\toutput%d "),
 *                                                       APM_RC.InputCh(CH_4),
 *                                                       g.rc_4.control_in,
 *                                                       g.rc_4.radio_out);
 *               APM_RC.OutputCh(CH_6, g.rc_4.radio_out);
 *
 *
 *               g.rc_4.set_reverse(1);
 *               g.rc_4.set_pwm(APM_RC.InputCh(CH_4));
 *               g.rc_4.servo_out = g.rc_4.control_in;
 *               g.rc_4.calc_pwm();
 *               Serial.printf_P(PSTR("\trev input: %d\toutput%d\n"),
 *                                                       g.rc_4.control_in,
 *                                                       g.rc_4.radio_out);
 *
 *               APM_RC.OutputCh(CH_7, g.rc_4.radio_out);
 *
 *               if(Serial.available() > 0){
 *                       g.rc_4.set_reverse(0);
 *                       return (0);
 *               }
 *       }
 *  }*/

#if HIL_MODE != HIL_MODE_ATTITUDE
/*
 *  test the sonar
 */
static int8_t
test_sonar(uint8_t argc, const Menu::arg *argv)
{
    if(g.sonar_enabled == false) {
        Serial.printf_P(PSTR("Sonar disabled\n"));
        return (0);
    }

    // make sure sonar is initialised
    init_sonar();

    print_hit_enter();
    while(1) {
        delay(100);

        Serial.printf_P(PSTR("Sonar: %d cm\n"), sonar.read());
        //Serial.printf_P(PSTR("Sonar, %d, %d\n"), sonar.read(), sonar.raw_value);

        if(Serial.available() > 0) {
            return (0);
        }
    }

    return (0);
}
#endif


static int8_t
test_optflow(uint8_t argc, const Menu::arg *argv)
{
#ifdef OPTFLOW_ENABLED
    if(g.optflow_enabled) {
        Serial.printf_P(PSTR("man id: %d\t"),optflow.read_register(ADNS3080_PRODUCT_ID));
        print_hit_enter();

        while(1) {
            delay(200);
            optflow.update(millis());
            Log_Write_Optflow();
            Serial.printf_P(PSTR("x/dx: %d/%d\t y/dy %d/%d\t squal:%d\n"),
                            optflow.x,
                            optflow.dx,
                            optflow.y,
                            optflow.dy,
                            optflow.surface_quality);

            if(Serial.available() > 0) {
                return (0);
            }
        }
    } else {
        Serial.printf_P(PSTR("OptFlow: "));
        print_enabled(false);
    }
    return (0);

#else
    print_test_disabled();
    return (0);
#endif
}


static int8_t
test_wp_nav(uint8_t argc, const Menu::arg *argv)
{
    current_loc.lat = 389539260;
    current_loc.lng = -1199540200;

    next_WP.lat = 389538528;
    next_WP.lng = -1199541248;

    // got 23506;, should be 22800
    navigate();
    Serial.printf_P(PSTR("bear: %ld\n"), target_bearing);
    return 0;
}

/*
 *  test the dataflash is working
 */

static int8_t
test_logging(uint8_t argc, const Menu::arg *argv)
{
#if defined( __AVR_ATmega1280__ )          // test disabled to save code size for 1280
    print_test_disabled();
    return (0);
#else
    Serial.println_P(PSTR("Testing dataflash logging"));
    if (!DataFlash.CardInserted()) {
        Serial.println_P(PSTR("ERR: No dataflash inserted"));
        return 0;
    }
    DataFlash.ReadManufacturerID();
    Serial.printf_P(PSTR("Manufacturer: 0x%02x   Device: 0x%04x\n"),
                    (unsigned)DataFlash.df_manufacturer,
                    (unsigned)DataFlash.df_device);
    Serial.printf_P(PSTR("NumPages: %u  PageSize: %u\n"),
                    (unsigned)DataFlash.df_NumPages+1,
                    (unsigned)DataFlash.df_PageSize);
    DataFlash.StartRead(DataFlash.df_NumPages+1);
    Serial.printf_P(PSTR("Format version: %lx  Expected format version: %lx\n"),
                    (unsigned long)DataFlash.ReadLong(), (unsigned long)DF_LOGGING_FORMAT);
    return 0;
#endif
}


/*
 *  static int8_t
 *  //test_mission(uint8_t argc, const Menu::arg *argv)
 *  {
 *       //write out a basic mission to the EEPROM
 *
 *  //{
 *  //	uint8_t		id;					///< command id
 *  //	uint8_t		options;			///< options bitmask (1<<0 = relative altitude)
 *  //	uint8_t		p1;					///< param 1
 *  //	int32_t		alt;				///< param 2 - Altitude in centimeters (meters * 100)
 *  //	int32_t		lat;				///< param 3 - Lattitude * 10**7
 *  //	int32_t		lng;				///< param 4 - Longitude * 10**7
 *  //}
 *
 *       // clear home
 *       {Location t = {0,      0,	  0,        0,      0,          0};
 *       set_cmd_with_index(t,0);}
 *
 *       // CMD										opt						pitch       alt/cm
 *       {Location t = {MAV_CMD_NAV_TAKEOFF,        WP_OPTION_RELATIVE,	  0,        100,        0,          0};
 *       set_cmd_with_index(t,1);}
 *
 *       if (!strcmp_P(argv[1].str, PSTR("wp"))) {
 *
 *               // CMD											opt
 *               {Location t = {MAV_CMD_NAV_WAYPOINT,           WP_OPTION_RELATIVE,		15, 0, 0, 0};
 *               set_cmd_with_index(t,2);}
 *               // CMD											opt
 *               {Location t = {MAV_CMD_NAV_RETURN_TO_LAUNCH,       WP_OPTION_YAW,	  0,        0,      0,		0};
 *               set_cmd_with_index(t,3);}
 *
 *               // CMD											opt
 *               {Location t = {MAV_CMD_NAV_LAND,				0,	  0,        0,      0,		0};
 *               set_cmd_with_index(t,4);}
 *
 *       } else {
 *               //2250 = 25 meteres
 *               // CMD										opt		p1		//alt		//NS		//WE
 *               {Location t = {MAV_CMD_NAV_LOITER_TIME,    0,	  10,   0,          0,			0}; // 19
 *               set_cmd_with_index(t,2);}
 *
 *               // CMD										opt		dir		angle/deg	deg/s	relative
 *               {Location t = {MAV_CMD_CONDITION_YAW,		0,	  1,        360,        60,     1};
 *               set_cmd_with_index(t,3);}
 *
 *               // CMD										opt
 *               {Location t = {MAV_CMD_NAV_LAND,			0,	  0,        0,          0,      0};
 *               set_cmd_with_index(t,4);}
 *
 *       }
 *
 *       g.RTL_altitude.set_and_save(300);
 *       g.command_total.set_and_save(4);
 *       g.waypoint_radius.set_and_save(3);
 *
 *       test_wp(NULL, NULL);
 *       return (0);
 *  }
 */

static void print_hit_enter()
{
    Serial.printf_P(PSTR("Hit Enter to exit.\n\n"));
}

static void print_test_disabled()
{
    Serial.printf_P(PSTR("Sorry, not 1280 compat.\n"));
}

/*
 *  //static void fake_out_gps()
 *  {
 *       static float rads;
 *       g_gps->new_data    = true;
 *       g_gps->fix	    = true;
 *
 *       //int length = g.rc_6.control_in;
 *       rads += .05;
 *
 *       if (rads > 6.28){
 *               rads = 0;
 *       }
 *
 *       g_gps->latitude	= 377696000;	// Y
 *       g_gps->longitude	= -1224319000;	// X
 *       g_gps->altitude	= 9000;			// meters * 100
 *
 *       //next_WP.lng	    = home.lng - length * sin(rads);   // X
 *       //next_WP.lat  = home.lat + length * cos(rads);   // Y
 *  }
 *
 */
/*
 *  //static void print_motor_out(){
 *       Serial.printf("out: R: %d,  L: %d  F: %d  B: %d\n",
 *                               (motor_out[CH_1]   - g.rc_3.radio_min),
 *                               (motor_out[CH_2]   - g.rc_3.radio_min),
 *                               (motor_out[CH_3]   - g.rc_3.radio_min),
 *                               (motor_out[CH_4]   - g.rc_3.radio_min));
 *  }
 */
#endif // CLI_ENABLED
////////////////////////////////////////////////////////////////////////////////
// Toy Mode - THOR
////////////////////////////////////////////////////////////////////////////////
static boolean CH7_toy_flag;
//static boolean CH6_toy_flag;

#if TOY_MIXER == TOY_LOOKUP_TABLE
static const int16_t toy_lookup[] = {
    186,    373,    558,    745,
    372,    745,    1117,   1490,
    558,    1118,   1675,   2235,
    743,    1490,   2233,   2980,
    929,    1863,   2792,   3725,
    1115,   2235,   3350,   4470,
    1301,   2608,   3908,   4500,
    1487,   2980,   4467,   4500,
    1673,   3353,   4500,   4500
};
#endif

//called at 10hz
void update_toy_throttle()
{
    /*
     *  // Disabled, now handled by TOY_A (Alt hold) and TOY_M (Manual throttle)
     *  if (false == CH6_toy_flag && g.rc_6.radio_in >= CH_6_PWM_TRIGGER){
     *       CH6_toy_flag = true;
     *       throttle_mode  = THROTTLE_MANUAL;
     *
     *  }else if (CH6_toy_flag && g.rc_6.radio_in < CH_6_PWM_TRIGGER){
     *       CH6_toy_flag = false;
     *       throttle_mode  = THROTTLE_AUTO;
     *       set_new_altitude(current_loc.alt);
     *       saved_toy_throttle = g.rc_3.control_in;
     *  }*/

    // look for a change in throttle position to exit throttle hold
    if(abs(g.rc_3.control_in - saved_toy_throttle) > 40) {
        throttle_mode   = THROTTLE_MANUAL;
    }
}

#define TOY_ALT_SMALL 25
#define TOY_ALT_LARGE 100

//called at 10hz
void update_toy_altitude()
{
    int16_t input = g.rc_3.radio_in;     // throttle
    //int16_t input = g.rc_7.radio_in;

    // Trigger upward alt change
    if(false == CH7_toy_flag && input > 1666) {
        CH7_toy_flag = true;
        // go up
        if(next_WP.alt >= 400) {
            force_new_altitude(next_WP.alt + TOY_ALT_LARGE);
        }else{
            force_new_altitude(next_WP.alt + TOY_ALT_SMALL);
        }

        // Trigger downward alt change
    }else if(false == CH7_toy_flag && input < 1333) {
        CH7_toy_flag = true;
        // go down
        if(next_WP.alt >= (400 + TOY_ALT_LARGE)) {
            force_new_altitude(next_WP.alt - TOY_ALT_LARGE);
        }else if(next_WP.alt >= TOY_ALT_SMALL) {
            force_new_altitude(next_WP.alt - TOY_ALT_SMALL);
        }else if(next_WP.alt < TOY_ALT_SMALL) {
            force_new_altitude(0);
        }

        // clear flag
    }else if (CH7_toy_flag && ((input < 1666) && (input > 1333))) {
        CH7_toy_flag = false;
    }
}

// called at 50 hz from all flight modes
#if TOY_EDF == ENABLED
void edf_toy()
{
    // EDF control:
    g.rc_8.radio_out = 1000 + ((abs(g.rc_2.control_in) << 1) / 9);
    if(g.rc_8.radio_out < 1050)
        g.rc_8.radio_out = 1000;

    // output throttle to EDF
    if(motors.armed()) {
        APM_RC.OutputCh(CH_8, g.rc_8.radio_out);
    }else{
        APM_RC.OutputCh(CH_8, 1000);
    }

    // output Servo direction
    if(g.rc_2.control_in > 0) {
        APM_RC.OutputCh(CH_6, 1000);         // 1000 : 2000
    }else{
        APM_RC.OutputCh(CH_6, 2000);         // less than 1450
    }
}
#endif

// The function call for managing the flight mode Toy
void roll_pitch_toy()
{
#if TOY_MIXER == TOY_LOOKUP_TABLE || TOY_MIXER == TOY_LINEAR_MIXER
    int16_t yaw_rate = g.rc_1.control_in / g.toy_yaw_rate;

    if(g.rc_1.control_in != 0) {    // roll
        get_acro_yaw(yaw_rate/2);
        yaw_stopped = false;
        yaw_timer = 150;

    }else if (!yaw_stopped) {
        get_acro_yaw(0);
        yaw_timer--;

        if((yaw_timer == 0) || (fabs(omega.z) < .17)) {
            yaw_stopped = true;
            nav_yaw = ahrs.yaw_sensor;
        }
    }else{
        if(motors.armed() == false || g.rc_3.control_in == 0)
            nav_yaw = ahrs.yaw_sensor;

        get_stabilize_yaw(nav_yaw);
    }
#endif

    // roll_rate is the outcome of the linear equation or lookup table
    // based on speed and Yaw rate
    int16_t roll_rate = 0;

#if TOY_MIXER == TOY_LOOKUP_TABLE
    uint8_t xx, yy;
    // Lookup value
    //xx	= g_gps->ground_speed / 200;
    xx      = abs(g.rc_2.control_in / 1000);
    yy      = abs(yaw_rate / 500);

    // constrain to lookup Array range
    xx = constrain(xx, 0, 3);
    yy = constrain(yy, 0, 8);

    roll_rate = toy_lookup[yy * 4 + xx];

    if(yaw_rate == 0) {
        roll_rate = 0;
    }else if(yaw_rate < 0) {
        roll_rate = -roll_rate;
    }

    int16_t roll_limit = 4500 / g.toy_yaw_rate;
    roll_rate = constrain(roll_rate, -roll_limit, roll_limit);

#elif TOY_MIXER == TOY_LINEAR_MIXER
    roll_rate = -((int32_t)g.rc_2.control_in * (yaw_rate/100)) /30;
    //Serial.printf("roll_rate: %d\n",roll_rate);
    roll_rate = constrain(roll_rate, -2000, 2000);

#elif TOY_MIXER == TOY_EXTERNAL_MIXER
    // JKR update to allow external roll/yaw mixing
    roll_rate = g.rc_1.control_in;
#endif

#if TOY_EDF == ENABLED
    // Output the attitude
    //g.rc_1.servo_out = get_stabilize_roll(roll_rate);
    //g.rc_2.servo_out = get_stabilize_pitch(g.rc_6.control_in);             // use CH6 to trim pitch
    get_stabilize_roll(roll_rate);
    get_stabilize_pitch(g.rc_6.control_in);             // use CH6 to trim pitch

#else
    // Output the attitude
    //g.rc_1.servo_out = get_stabilize_roll(roll_rate);
    //g.rc_2.servo_out = get_stabilize_pitch(g.rc_2.control_in);
    get_stabilize_roll(roll_rate);
    get_stabilize_pitch(g.rc_2.control_in);
#endif

}// agmatthews USERHOOKS

void userhook_init()
{
    // put your initialisation code here


}

void userhook_50Hz()
{
    // put your 50Hz code here


}
// agmatthews USERHOOKS
// user defined variables

// example variables used in Wii camera testing - replace with your own
// variables
#if WII_CAMERA == 1
WiiCamera           ircam;
int                 WiiRange=0;
int                 WiiRotation=0;
int                 WiiDisplacementX=0;
int                 WiiDisplacementY=0;
#endif


